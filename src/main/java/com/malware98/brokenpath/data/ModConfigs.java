package com.malware98.brokenpath.data;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.minecraftforge.fml.loading.FMLPaths;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Path;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ModConfigs {

    //Preparación para la generación de archivo JSON
    private static ModConfigs INSTANCE;
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static final String CONFIG_FILE_NAME = "brokenpath_configs.json";
    private static final Path CONFIG_PATH = FMLPaths.CONFIGDIR.get().resolve(CONFIG_FILE_NAME);

    public static final int MAX_LEVEL = 50; // Define el nivel máximo del jugador

    public float maxLuckBonusMultiplier = 2.0f; //Define la bonificación máxima que puede tener la Suerte

    //Variables de manejo para Regeneración de Estadísticas

    //Regeneración de Salud
    public int healthRegenCooldownTicksBase = 60; //Tiempo base de espera entre cada "pulso" de curación
    public float healthAmountToHealPerPulse = 1.0f; //Cantidad de salud que se cura el jugador en cada pulso de regeneración
    public float healthExhaustionCostPerHealPulse = 2.5F; //Cantidad de agotamiento de comida en cada pulso de curación
    public int healthMinFoodLevelForRegen = 18; //Nivel mínimo de hambre para tener regeneración de salud
    public int healthDelayAfterCombatTicks = 100; //Retardo de espera al salir de combate para empezar la regeneración
    public int healthMinEffectiveCooldownTicks = 20; //Cooldown mínimo posible para la regeneración de salud
    public float healthRegenBonusPerConTicks = 0.0f; //Ticks del healthRegenCooldownTicksBase que se reducen por cada punto de CON

    //Regeneración de Maná
    public float manaRegenOutOfCombatBase = 0.05f; //Regeneración fuera de combate
    public float manaRegenInCombatBase = 0.01f; //Regeneración en combate
    public float manaRegenBonusPerInt = 0.0f; //Bono modificador de la Regeneración por puntos de INT
    public int manaDelayAfterCombatTicks = 40; // Retraso en ticks antes de que el Maná comience a regenerarse más rápido fuera de combate

    //Regeneración de Vigor
    public float vigorRegenOutOfCombatBase = 0.06f; //Regeneración fuera de combate
    public float vigorRegenInCombatBase = 0.015f; //Regeneración en combate
    public float vigorRegenBonusPerDex = 0.0f; //Bono modificador de la Regeneración por puntos de DEX
    public int vigorDelayAfterCombatTicks = 40; // Retraso en ticks antes de que el Vigor comience a regenerarse más rápido fuera de combate

    //Regeneración de Estadísticas Protección, Maná y Vigor
    public int protectionRegenSlowCooldownTicks = 60; // Tiempo (en ticks) entre pulsos de regeneración lenta de Protección
    public float protectionAmountPerSlowPulse = 1.0f; // Cantidad de Protección restaurada por pulso lento
    public float protectionRestoreAmountPerAbility = 5.0f; // Cantidad de Protección restaurada por una habilidad/ítem plano

    public int manaRegenCooldownTicksEffect = 40; // Cooldown predeterminado para el efecto de regeneración de Maná
    public float manaAmountPerEffectPulse = 0.5f; // Cantidad de Maná restaurada por pulso de efecto

    public int vigorRegenCooldownTicksEffect = 30; // Cooldown predeterminado para el efecto de regeneración de Vigor
    public float vigorAmountPerEffectPulse = 0.75f; // Cantidad de Vigor restaurada por pulso de efecto

    public float hungryModerateMovementSpeedPenalty = -0.15f; // Penalización de velocidad de movimiento (3-7 muslos de comida)
    public float hungryModerateVigorRegenPenalty = -0.20f; // Penalización de regeneración de Vigor (3-7 muslos de comida)
    public float hungryIntenseMovementSpeedPenalty = -0.30f; // Penalización de velocidad de movimiento (1-2 muslos de comida)
    public float hungryIntenseVigorRegenPenalty = -0.40f; // Penalización de regeneración de Vigor (1-2 muslos de comida)
    public float starvingMovementSpeedPenalty = -0.50f; // Penalización de velocidad de movimiento (0 muslos de comida)
    public float starvingVigorRegenPenalty = -0.60f; // Penalización de regeneración de Vigor (0 muslos de comida)
    public int starvingDamageIntervalTicks = 80; // Cada cuánto (en ticks) el jugador famélico recibe daño (20 ticks = 1 segundo)
    public float starvingDamageAmount = 1.0f; // Cantidad de daño que recibe el jugador famélico por pulso

    // Campos de Datos de Configuración (corresponden a la estructura JSON)
    public AttributeSettings attributeSettings = new AttributeSettings();
    public Map<String, RaceSettings> raceSettings = new HashMap<>();
    public Map<String, Map<String, List<String>>> classAffinities = new HashMap<>();
    public Map<String, List<String>> classAttributeBonuses = new HashMap<>();
    public Map<String, Integer> levelProgression = new HashMap<>();
    public Map<String, Float> luckActionModifiers = new HashMap<>();

    //Configuración para la progresión de XP
    public XpProgressionSettings xpProgressionSettings = new XpProgressionSettings();

    // Constructor Privado para Imponer el Patrón Singleton
    private ModConfigs() {
        initializeDefaults();
    }

    //Acceso al Metho Singleton
    public static ModConfigs getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new ModConfigs();
        }
        return INSTANCE;
    }

    //Lógica de Inicialización por Defecto
    private void initializeDefaults() {

        //Puntos Máximos de Atributos Fundamentales
        attributeSettings.manualAllocationLimit.put("CONSTITUTION", 70);
        attributeSettings.manualAllocationLimit.put("STRENGTH", 70);
        attributeSettings.manualAllocationLimit.put("DEXTERITY", 70);
        attributeSettings.manualAllocationLimit.put("INTELLIGENCE", 70);

        //Variable de manejo de puntos Máximos de Atributos Fundamentales
        final float CON_MAX_POINTS = attributeSettings.manualAllocationLimit.get("CONSTITUTION");
        final float INT_MAX_POINTS = attributeSettings.manualAllocationLimit.get("INTELLIGENCE");
        final float DEX_MAX_POINTS = attributeSettings.manualAllocationLimit.get("DEXTERITY");
        final float STR_MAX_POINTS = attributeSettings.manualAllocationLimit.get("STRENGTH");

        //TODO: Comprobar que no sea necesario
        //this.maxLuckBonusMultiplier = 2.0f;

        //Inicialización de los Valores por Defecto para XP
        xpProgressionSettings.baseXp = 100.0f;
        xpProgressionSettings.linearXpCoefficient = 50.0f;
        xpProgressionSettings.polynomialXpCoefficient = 1.2f;
        xpProgressionSettings.polynomialXpExponent = 2.5f;
        xpProgressionSettings.minXpPerLevel = 100;

        //Configuración inicial para cada raza en sus estadísticas base
        // HUMAN
        RaceSettings humanSettings = new RaceSettings();
        humanSettings.health = createStatConfig(20.0f, (120.0f - 20.0f) / CON_MAX_POINTS, 0.0f, 0.0f, 0.0f, 1.0f, 100.0f, 1.2f, 140.0f, 1.4f, 160.0f);
        humanSettings.protection = createProtectionConfig((100.0f - 0.0f) / STR_MAX_POINTS, 1.0f, 100.0f, 1.2f, 120.0f, 1.4f, 140.0f);
        humanSettings.protectionInnate = createProtectionInnateConfig(0.0f, 0.0f);
        humanSettings.mana = createStatConfig(20.0f, 0.0f, (100.0f - 20.0f) / INT_MAX_POINTS, 0.0f, 0.0f, 1.0f, 100.0f, 1.0f, 100.0f, 1.25f, 120.0f);
        humanSettings.vigor = createStatConfig(20.0f, 0.0f, 0.0f, (100.0f - 20.0f) / DEX_MAX_POINTS, 0.0f, 1.0f, 100.0f, 1.0f, 100.0f, 1.25f, 120.0f);
        humanSettings.luck = new LuckConfig(-3.0f, 2.0f, -3.0f); // baseLuck, maxLimit, minLimit
        raceSettings.put("HUMAN", humanSettings);

        // ELF
        RaceSettings elfSettings = new RaceSettings();
        elfSettings.health = createStatConfig(14.0f, (84.0f - 14.0f) / CON_MAX_POINTS, 0.0f, 0.0f, 0.0f, 1.0f, 84.0f, 1.1428571f, 94.0f, 1.3714286f, 110.0f);
        elfSettings.protection = createProtectionConfig((80.0f - 0.0f) / STR_MAX_POINTS, 1.0f, 80.0f, 1.25f, 100.0f, 1.5f, 120.0f);
        elfSettings.protectionInnate = createProtectionInnateConfig(0.0f, 0.0f);
        elfSettings.mana = createStatConfig(40.0f, 0.0f, (120.0f - 40.0f) / INT_MAX_POINTS, 0.0f, 0.0f, 1.0f, 120.0f, 1.5f, 160.0f, 2.0f, 200.0f);
        elfSettings.vigor = createStatConfig(20.0f, 0.0f, 0.0f, (100.0f - 20.0f) / DEX_MAX_POINTS, 0.0f, 1.0f, 100.0f, 1.0f, 100.0f, 1.25f, 120.0f);
        elfSettings.luck = new LuckConfig(-3.0f, -1.0f, -3.0f);
        raceSettings.put("ELF", elfSettings);

        // ORC
        RaceSettings orcSettings = new RaceSettings();
        orcSettings.health = createStatConfig(30.0f, (140.0f - 30.0f) / CON_MAX_POINTS, 0.0f, 0.0f, 0.0f, 1.0f, 140.0f, 1.1818182f, 160.0f, 1.5454545f, 200.0f);
        orcSettings.protection = createProtectionConfig((10.0f - 0.0f) / STR_MAX_POINTS, 1.0f, 10.0f, 4.0f, 40.0f, 8.0f, 80.0f);
        orcSettings.protectionInnate = createProtectionInnateConfig(0.0f, 0.0f);
        orcSettings.mana = createStatConfig(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f);
        orcSettings.vigor = createStatConfig(40.0f, 0.0f, 0.0f, (120.0f - 40.0f) / DEX_MAX_POINTS, 0.0f, 1.0f, 120.0f, 1.2f, 140.0f, 1.5f, 160.0f);
        orcSettings.luck = new LuckConfig(-3.0f, -1.0f, -3.0f);
        raceSettings.put("ORC", orcSettings);

        // DRACONID
        RaceSettings draconidSettings = new RaceSettings();
        draconidSettings.health = createStatConfig(16.0f, (100.0f - 16.0f) / CON_MAX_POINTS, 0.0f, 0.0f, 0.0f, 1.0f, 100.0f, 1.2380952f, 120.0f, 1.4761904f, 140.0f);
        draconidSettings.protection = createProtectionConfig((80.0f - 0.0f) / STR_MAX_POINTS, 1.0f, 80.0f, 1.2857143f, 100.0f, 1.5714285f, 120.0f);
        draconidSettings.protectionInnate = createProtectionInnateConfig(10.0f, 0.2f); // 10.0f base, 0.2f por nivel
        draconidSettings.mana = createStatConfig(30.0f, 0.0f, (90.0f - 30.0f) / INT_MAX_POINTS, 0.0f, 0.0f, 1.0f, 90.0f, 1.3333334f, 110.0f, 1.6666666f, 130.0f);
        draconidSettings.vigor = createStatConfig(20.0f, 0.0f, 0.0f, (100.0f - 20.0f) / DEX_MAX_POINTS, 0.0f, 1.0f, 100.0f, 1.5f, 140.0f, 1.75f, 160.0f);
        draconidSettings.luck = new LuckConfig(-3.0f, 1.0f, -3.0f);
        raceSettings.put("DRACONID", draconidSettings);

        // CHIMERA_AGILE
        RaceSettings chimeraAgileSettings = new RaceSettings();
        chimeraAgileSettings.health = createStatConfig(16.0f, (80.0f - 16.0f) / CON_MAX_POINTS, 0.0f, 0.0f, 0.0f, 1.0f, 80.0f, 1.3125f, 100.0f, 1.625f, 120.0f);
        chimeraAgileSettings.protection = createProtectionConfig((80.0f - 0.0f) / STR_MAX_POINTS, 1.0f, 80.0f, 1.2857143f, 100.0f, 1.5714285f, 120.0f);
        chimeraAgileSettings.protectionInnate = createProtectionInnateConfig(10.0f, 0.2f);
        chimeraAgileSettings.mana = createStatConfig(20.0f, 0.0f, (90.0f - 20.0f) / INT_MAX_POINTS, 0.0f, 0.0f, 1.0f, 90.0f, 1.2857143f, 110.0f, 1.5714285f, 130.0f);
        chimeraAgileSettings.vigor = createStatConfig(20.0f, 0.0f, 0.0f, (120.0f - 20.0f) / DEX_MAX_POINTS, 0.0f, 1.0f, 120.0f, 1.4f, 160.0f, 1.8f, 200.0f);
        chimeraAgileSettings.luck = new LuckConfig(-3.0f, 0.0f, -3.0f);
        raceSettings.put("CHIMERA_AGILE", chimeraAgileSettings);

        // CHIMERA_DEFENSIVE
        RaceSettings chimeraDefensiveSettings = new RaceSettings();
        chimeraDefensiveSettings.health = createStatConfig(20.0f, (100.0f - 20.0f) / CON_MAX_POINTS, 0.0f, 0.0f, 0.0f, 1.0f, 100.0f, 1.25f, 120.0f, 1.5f, 140.0f);
        chimeraDefensiveSettings.protection = createProtectionConfig((100.0f - 0.0f) / STR_MAX_POINTS, 1.0f, 100.0f, 1.2222222f, 120.0f, 1.4444444f, 140.0f);
        chimeraDefensiveSettings.protectionInnate = createProtectionInnateConfig(10.0f, 0.2f);
        chimeraDefensiveSettings.mana = createStatConfig(20.0f, 0.0f, (60.0f - 20.0f) / INT_MAX_POINTS, 0.0f, 0.0f, 1.0f, 60.0f, 1.5f, 80.0f, 2.0f, 100.0f);
        chimeraDefensiveSettings.vigor = createStatConfig(20.0f, 0.0f, 0.0f, (80.0f - 20.0f) / DEX_MAX_POINTS, 0.0f, 1.0f, 80.0f, 1.6666666f, 120.0f, 2.0f, 140.0f);
        chimeraDefensiveSettings.luck = new LuckConfig(-3.0f, 0.0f, -3.0f);
        raceSettings.put("CHIMERA_DEFENSIVE", chimeraDefensiveSettings);

        // TRITON
        RaceSettings tritonSettings = new RaceSettings();
        tritonSettings.health = createStatConfig(18.0f, (90.0f - 18.0f) / CON_MAX_POINTS, 0.0f, 0.0f, 0.0f, 1.0f, 90.0f, 1.1388888f, 100.0f, 1.6944444f, 120.0f);
        tritonSettings.protection = createProtectionConfig((80.0f - 0.0f) / STR_MAX_POINTS, 1.0f, 80.0f, 1.2857143f, 100.0f, 1.5714285f, 120.0f);
        tritonSettings.protectionInnate = createProtectionInnateConfig(10.0f, 0.2f);
        tritonSettings.mana = createStatConfig(20.0f, 0.0f, (100.0f - 20.0f) / INT_MAX_POINTS, 0.0f, 0.0f, 1.0f, 100.0f, 1.25f, 120.0f, 1.75f, 160.0f);
        tritonSettings.vigor = createStatConfig(20.0f, 0.0f, 0.0f, (80.0f - 20.0f) / DEX_MAX_POINTS, 0.0f, 1.0f, 80.0f, 1.6666666f, 120.0f, 2.0f, 140.0f);
        tritonSettings.luck = new LuckConfig(-3.0f, 2.0f, -3.0f);
        raceSettings.put("TRITON", tritonSettings);

        // AASIMAR
        RaceSettings aasimarSettings = new RaceSettings();
        aasimarSettings.health = createStatConfig(16.0f, (90.0f - 16.0f) / CON_MAX_POINTS, 0.0f, 0.0f, 0.0f, 1.0f, 90.0f, 1.1351351f, 100.0f, 1.945946f, 160.0f);
        aasimarSettings.protection = createProtectionConfig((80.0f - 0.0f) / STR_MAX_POINTS, 1.0f, 80.0f, 1.2857143f, 100.0f, 1.5714285f, 120.0f);
        aasimarSettings.protectionInnate = createProtectionInnateConfig(10.0f, 0.2f);
        aasimarSettings.mana = createStatConfig(20.0f, 0.0f, (100.0f - 20.0f) / INT_MAX_POINTS, 0.0f, 0.0f, 1.0f, 100.0f, 1.5f, 140.0f, 1.75f, 160.0f);
        aasimarSettings.vigor = createStatConfig(20.0f, 0.0f, 0.0f, (80.0f - 20.0f) / DEX_MAX_POINTS, 0.0f, 1.0f, 80.0f, 1.6666666f, 120.0f, 2.3333333f, 160.0f);
        aasimarSettings.luck = new LuckConfig(-3.0f, 3.0f, -3.0f);
        raceSettings.put("AASIMAR", aasimarSettings);

        // ANDROID
        RaceSettings androidSettings = new RaceSettings();
        androidSettings.health = createStatConfig(10.0f, (60.0f - 10.0f) / CON_MAX_POINTS, 0.0f, 0.0f, 0.0f, 1.0f, 60.0f, 1.0f, 60.0f, 1.4f, 80.0f);
        androidSettings.protection = createProtectionConfig((140.0f - 0.0f) / STR_MAX_POINTS, 1.0f, 140.0f, 1.1666666f, 160.0f, 1.5f, 200.0f);
        androidSettings.protectionInnate = createProtectionInnateConfig(20.0f, 0.2f); // 20.0f base, 0.2f por nivel
        androidSettings.mana = createStatConfig(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f);
        androidSettings.vigor = createStatConfig(40.0f, 0.0f, 0.0f, (100.0f - 40.0f) / DEX_MAX_POINTS, 0.0f, 1.0f, 100.0f, 1.3333334f, 120.0f, 2.0f, 160.0f);
        androidSettings.luck = new LuckConfig(-3.0f, 2.0f, -3.0f);
        raceSettings.put("ANDROID", androidSettings);

        //Afinidades de Clase
        classAffinities.put("CHAMPION", Map.of("HEALTH", List.of("HUMAN"), "PROTECTION", List.of("HUMAN")));
        classAffinities.put("SORCERER", Map.of("MANA", List.of("ELF"), "PROTECTION", List.of("ELF")));
        classAffinities.put("BERSERKER", Map.of("HEALTH", List.of("ORC"), "VIGOR", List.of("ORC")));
        classAffinities.put("SHAMAN", Map.of("MANA", List.of("DRACONID"), "VIGOR", List.of("DRACONID")));
        classAffinities.put("EXPLORER", Map.of("VIGOR", List.of("CHIMERA_AGILE"), "PROTECTION", List.of("CHIMERA_AGILE")));
        classAffinities.put("CHANNELER", Map.of("MANA", List.of("TRITON"), "HEALTH", List.of("TRITON")));
        classAffinities.put("VESTAL", Map.of("PROTECTION", List.of("AASIMAR"), "MANA", List.of("AASIMAR")));
        classAffinities.put("TECHNOMANCER", Map.of("PROTECTION", List.of("ANDROID"), "VIGOR", List.of("ANDROID")));
        classAffinities.put("NO_CLASS", Map.of(
                "HEALTH", Collections.emptyList(),
                "MANA", Collections.emptyList(),
                "VIGOR", Collections.emptyList(),
                "PROTECTION", Collections.emptyList()
        ));

        //Bonificaciones de Atributo Fundamental por Clase
        classAttributeBonuses.put("CHAMPION", List.of("CONSTITUTION", "STRENGTH"));
        classAttributeBonuses.put("SORCERER", List.of("INTELLIGENCE", "STRENGTH"));
        classAttributeBonuses.put("BERSERKER", List.of("CONSTITUTION", "DEXTERITY"));
        classAttributeBonuses.put("SHAMAN", List.of("INTELLIGENCE", "DEXTERITY"));
        classAttributeBonuses.put("EXPLORER", List.of("DEXTERITY", "STRENGTH"));
        classAttributeBonuses.put("CHANNELER", List.of("INTELLIGENCE", "CONSTITUTION"));
        classAttributeBonuses.put("VESTAL", List.of("STRENGTH", "INTELLIGENCE"));
        classAttributeBonuses.put("TECHNOMANCER", List.of("STRENGTH", "DEXTERITY"));
        classAttributeBonuses.put("NO_CLASS", Collections.emptyList());

        //Asignación de Puntos de Atributo en la Progresión de nivel.
        levelProgression.put("1-1", 0);
        levelProgression.put("2-10", 1);
        levelProgression.put("11-20", 2);
        levelProgression.put("21-30", 3);
        levelProgression.put("31-40", 4);
        levelProgression.put("41-49", 5);
        levelProgression.put("50-50", 6);

        //VALORES DE ACCIONES QUE PROPORCIONAN SUERTE
        //Interacción con Animales (Aumento de Suerte)
        luckActionModifiers.put("TAME_WOLF", 0.03f);
        luckActionModifiers.put("TAME_CAT", 0.03f);
        luckActionModifiers.put("TAME_HORSE", 0.03f);
        luckActionModifiers.put("TAME_DONKEY", 0.03f);
        luckActionModifiers.put("TAME_MULE", 0.03f);
        luckActionModifiers.put("TAME_LLAMA", 0.03f);
        luckActionModifiers.put("FEED_CHICKEN", 0.02f);
        luckActionModifiers.put("FEED_COW", 0.02f);
        luckActionModifiers.put("FEED_PIG", 0.02f);
        luckActionModifiers.put("FEED_SHEEP", 0.02f);
        luckActionModifiers.put("FEED_PARROT", 0.02f);
        luckActionModifiers.put("FEED_PANDA", 0.02f);
        luckActionModifiers.put("FEED_FOX", 0.02f);

        //Interacción con Animales (Disminución de Suerte)
        luckActionModifiers.put("KILL_WOLF", -0.05f);
        luckActionModifiers.put("KILL_CAT", -0.05f);
        luckActionModifiers.put("KILL_HORSE", -0.05f);
        luckActionModifiers.put("KILL_DONKEY", -0.05f);
        luckActionModifiers.put("KILL_MULE", -0.05f);
        luckActionModifiers.put("KILL_LLAMA", -0.05f);
        luckActionModifiers.put("KILL_PARROT", -0.05f);
        luckActionModifiers.put("KILL_PANDA", -0.05f);
        luckActionModifiers.put("KILL_FOX", -0.05f);

        //Interacción con Aldeanos - Fácil (Aumento de Suerte)
        luckActionModifiers.put("TRADE_FARMER", 0.015f);
        luckActionModifiers.put("TRADE_FISHERMAN", 0.015f);
        luckActionModifiers.put("TRADE_SHEPHERD", 0.015f);
        luckActionModifiers.put("TRADE_LEATHERWORKER", 0.015f);
        luckActionModifiers.put("TRADE_MASON", 0.015f);

        //Interacción con Aldeanos - Medio (Aumento de Suerte)
        luckActionModifiers.put("TRADE_CARTOGRAPHER", 0.02f);
        luckActionModifiers.put("TRADE_FLETCHER", 0.02f);
        luckActionModifiers.put("TRADE_BUTCHER", 0.02f);
        luckActionModifiers.put("TRADE_TOOLSMITH", 0.025f);
        luckActionModifiers.put("TRADE_WEAPONSMITH", 0.025f);

        //Interacción con Aldeanos - Difícil (Aumento de Suerte)
        luckActionModifiers.put("TRADE_LIBRARIAN", 0.05f);
        luckActionModifiers.put("TRADE_CLERIC", 0.04f);
        luckActionModifiers.put("TRADE_ARMORER", 0.035f);
        luckActionModifiers.put("DEFEND_RAID", 0.50f);

        //Interacción con Aldeanos - Profesiones por defecto / Sin profesión
        luckActionModifiers.put("TRADE_VILLAGER", 0.01f);


        //Interacción con Aldeanos (Disminución de Suerte)
        luckActionModifiers.put("ATTACK_VILLAGER", -0.03f);
        luckActionModifiers.put("ATTACK_FARMER", -0.04f);
        luckActionModifiers.put("ATTACK_FISHERMAN", -0.04f);
        luckActionModifiers.put("ATTACK_SHEPHERD", -0.04f);
        luckActionModifiers.put("ATTACK_LEATHERWORKER", -0.04f);
        luckActionModifiers.put("ATTACK_MASON", -0.04f);
        luckActionModifiers.put("ATTACK_CARTOGRAPHER", -0.05f);
        luckActionModifiers.put("ATTACK_FLETCHER", -0.05f);
        luckActionModifiers.put("ATTACK_BUTCHER", -0.05f);
        luckActionModifiers.put("ATTACK_TOOLSMITH", -0.06f);
        luckActionModifiers.put("ATTACK_WEAPONSMITH", -0.06f);
        luckActionModifiers.put("ATTACK_ARMORER", -0.06f);
        luckActionModifiers.put("ATTACK_LIBRARIAN", -0.07f);
        luckActionModifiers.put("ATTACK_CLERIC", -0.08f);
        luckActionModifiers.put("KILL_VILLAGER", -0.15f);
        luckActionModifiers.put("DESTROY_VILLAGE_BLOCK", -0.05f);


        //Interacción con Golems (Aumento de Suerte)
        luckActionModifiers.put("REPAIR_GOLEM", 0.04f);

        //Interacción con Golems (Disminución de Suerte)
        luckActionModifiers.put("DAMAGE_GOLEM", -0.02f);
        luckActionModifiers.put("SHEAR_SNOW_GOLEM_PUMPKIN", -0.05f);
        luckActionModifiers.put("KILL_GOLEM", -0.10f);

    }

    // Métodos de ayuda para crear objetos de configuración
    private StatConfig createStatConfig(float baseInitial,
                                        float conMult, float intMult, float dexMult, float strMult,
                                        float baseMult, float baseLimit,
                                        float classBonusMult, float classBonusLimit,
                                        float racialAffinityMult, float racialAffinityLimit) {
        StatConfig config = new StatConfig();
        config.baseInitialValue = baseInitial;
        config.conMultiplierPerPoint = conMult;
        config.intMultiplierPerPoint = intMult;
        config.dexMultiplierPerPoint = dexMult;
        config.strMultiplierPerPoint = strMult;

        config.affinityLimits.put("BASE", new AffinityLimit(baseMult, baseLimit));
        config.affinityLimits.put("CLASS_BONUS", new AffinityLimit(classBonusMult, classBonusLimit));
        config.affinityLimits.put("RACIAL_AFFINITY", new AffinityLimit(racialAffinityMult, racialAffinityLimit));
        return config;
    }

    //Configuración y cálculo de escalado para la Protección Innata
    private ProtectionInnateConfig createProtectionInnateConfig(float baseValue, float perLevelIncrease) {
        return new ProtectionInnateConfig(baseValue, perLevelIncrease);
    }

    // Modificación del method existente 'createProtectionConfig'
    private ProtectionConfig createProtectionConfig(float strEfficacyMult,
                                                    float baseMult, float baseLimit,
                                                    float classBonusMult, float classBonusLimit,
                                                    float racialAffinityMult, float racialAffinityLimit) {
        ProtectionConfig config = new ProtectionConfig();
        config.strEfficacyMultiplierPerPoint = strEfficacyMult;

        config.affinityLimits.put("BASE", new AffinityLimit(baseMult, baseLimit));
        config.affinityLimits.put("CLASS_BONUS", new AffinityLimit(classBonusMult, classBonusLimit));
        config.affinityLimits.put("RACIAL_AFFINITY", new AffinityLimit(racialAffinityMult, racialAffinityLimit));
        return config;
    }

    //Carga y guardado de la configuración
    public static void loadConfig() {
        File configFile = CONFIG_PATH.toFile();

        if (configFile.exists()) {
            try (FileReader reader = new FileReader(configFile)) {
                INSTANCE = GSON.fromJson(reader, ModConfigs.class);
                if (INSTANCE == null) {
                    INSTANCE = new ModConfigs();
                }
            } catch (IOException e) {
                INSTANCE = new ModConfigs(); // Fallback to defaults on read error
            }
        } else {
            INSTANCE = new ModConfigs();
            saveConfig();
        }

        // Validación Post-Carga
        if (INSTANCE.attributeSettings == null) INSTANCE.attributeSettings = new AttributeSettings();
        if (INSTANCE.raceSettings == null) INSTANCE.raceSettings = new HashMap<>();
        if (INSTANCE.classAffinities == null) INSTANCE.classAffinities = new HashMap<>();
        if (INSTANCE.classAttributeBonuses == null) INSTANCE.classAttributeBonuses = new HashMap<>();
        if (INSTANCE.levelProgression == null) INSTANCE.levelProgression = new HashMap<>();
        if (INSTANCE.luckActionModifiers == null) INSTANCE.luckActionModifiers = new HashMap<>();
        if (INSTANCE.xpProgressionSettings == null) INSTANCE.xpProgressionSettings = new XpProgressionSettings();
    }

    //Guardar configuración actual del mod
    public static void saveConfig() {
        File configFile = CONFIG_PATH.toFile();
        try (FileWriter writer = new FileWriter(configFile)) {
            GSON.toJson(INSTANCE, writer);
        } catch (IOException e) {
            System.err.println("BrokenPath: Failed to save config file: " + e.getMessage());
        }
    }

    //Proceso de cálculo para nivel de XP
    public int getXPForNextLevel(int currentLevel) {
        if (currentLevel >= MAX_LEVEL) {
            return 0;
        }

        final float A = xpProgressionSettings.baseXp;
        final float B = xpProgressionSettings.linearXpCoefficient;
        final float C = xpProgressionSettings.polynomialXpCoefficient;
        final float EXP = xpProgressionSettings.polynomialXpExponent; // El exponente configurable

        // Fórmula: XP_Necesaria = A + (B * Nivel) + (C * Nivel^EXP)
        double xpNeededDouble = A + (B * currentLevel) + (C * Math.pow(currentLevel, EXP));

        // Redondeamos al entero más cercano
        int xpNeeded = (int) Math.round(xpNeededDouble);

        // Aseguramos un mínimo, si la fórmula da muy bajo al inicio
        if (xpNeeded < xpProgressionSettings.minXpPerLevel) {
            xpNeeded = xpProgressionSettings.minXpPerLevel;
        }
        return xpNeeded;
    }


    //Clases Anidadas para Mapeo JSON
    public static class AttributeSettings {
        public Map<String, Integer> manualAllocationLimit = new HashMap<>();
    }

    public static class RaceSettings {
        public StatConfig health;
        public StatConfig mana;
        public StatConfig vigor;
        public ProtectionConfig protection;
        public ProtectionInnateConfig protectionInnate;
        public LuckConfig luck;
    }

    public static class StatConfig {
        public float baseInitialValue;
        public float conMultiplierPerPoint;
        public float intMultiplierPerPoint;
        public float dexMultiplierPerPoint;
        public float strMultiplierPerPoint;
        public Map<String, AffinityLimit> affinityLimits = new HashMap<>();
    }

    public static class ProtectionConfig {
        public float strEfficacyMultiplierPerPoint;
        public Map<String, AffinityLimit> affinityLimits = new HashMap<>();
        public ProtectionConfig() {}
    }

    public static class LuckConfig {
        public float baseLuck;
        public float maxLimit;
        public float minLimit;

        // Constructor que GSON usará al cargar desde JSON
        public LuckConfig() {
            this.baseLuck = -3.0f;
            this.maxLimit = 3.0f;
            this.minLimit = -3.0f;
        }

        // Constructor que usarás para inicializar por código en initializeDefaults()
        // Este es el constructor que toma 3 parámetros: baseLuck, maxLimit, minLimit
        public LuckConfig(float baseLuck, float maxLimit, float minLimit) {
            this.baseLuck = baseLuck;
            this.maxLimit = maxLimit;
            this.minLimit = minLimit;
        }
    }

    public static class AffinityLimit {
        public float multiplier;
        public float limit;
        public AffinityLimit(float multiplier, float limit) {
            this.multiplier = multiplier;
            this.limit = limit;
        }
        public AffinityLimit() {} // Default constructor required for GSON
    }

    //Configuración de XP
    public static class XpProgressionSettings {
        public float baseXp;
        public float linearXpCoefficient;
        public float polynomialXpCoefficient;
        public float polynomialXpExponent;
        public int minXpPerLevel;
        public XpProgressionSettings() {}
    }

    //Getters Útiles

    public int getManualAttributeLimit(String attributeName) {
        return attributeSettings.manualAllocationLimit.getOrDefault(attributeName.toUpperCase(), 1);
    }

    public StatConfig getRaceStatConfig(String raceName, String statName) {
        RaceSettings raceSetting = raceSettings.get(raceName.toUpperCase());
        if (raceSetting == null) {
            System.err.println("BrokenPath: Race setting not found for: " + raceName);
            return null;
        }

        switch (statName.toUpperCase()) {
            case "HEALTH": return raceSetting.health;
            case "MANA": return raceSetting.mana;
            case "VIGOR": return raceSetting.vigor;
            default:
                return null;
        }
    }

    public ProtectionConfig getRaceProtectionConfig(String raceName) {
        RaceSettings raceSetting = raceSettings.get(raceName.toUpperCase());
        if (raceSetting == null) {
            System.err.println("BrokenPath: Race setting not found for: " + raceName);
            return null;
        }
        return raceSetting.protection;
    }

    public LuckConfig getRaceLuckConfig(String raceName) {
        RaceSettings raceSetting = raceSettings.get(raceName.toUpperCase());
        if (raceSetting == null) {
            System.err.println("BrokenPath: Race setting not found for: " + raceName);
            return null;
        }
        return raceSetting.luck;
    }

    //Getters de Regeneración
    public float getManaRegenOutOfCombatBase() { return manaRegenOutOfCombatBase; }
    public float getManaRegenInCombatBase() { return manaRegenInCombatBase; }
    public float getManaRegenBonusPerInt() { return manaRegenBonusPerInt; }
    public int getManaDelayAfterCombatTicks() { return manaDelayAfterCombatTicks; }

    public float getVigorRegenOutOfCombatBase() { return vigorRegenOutOfCombatBase; }
    public float getVigorRegenInCombatBase() { return vigorRegenInCombatBase; }
    public float getVigorRegenBonusPerDex() { return vigorRegenBonusPerDex; }
    public int getVigorDelayAfterCombatTicks() { return vigorDelayAfterCombatTicks; }

    public int getHealthRegenCooldownTicksBase() { return healthRegenCooldownTicksBase; }
    public float getHealthAmountToHealPerPulse() { return healthAmountToHealPerPulse; }
    public float getHealthExhaustionCostPerHealPulse() { return healthExhaustionCostPerHealPulse; }
    public int getHealthMinFoodLevelForRegen() { return healthMinFoodLevelForRegen; }
    public int getHealthDelayAfterCombatTicks() { return healthDelayAfterCombatTicks; }
    public int getHealthMinEffectiveCooldownTicks() { return healthMinEffectiveCooldownTicks; }
    public float getHealthRegenBonusPerConTicks() { return healthRegenBonusPerConTicks; }

    public int getProtectionRegenSlowCooldownTicks() { return protectionRegenSlowCooldownTicks; }
    public float getProtectionAmountPerSlowPulse() { return protectionAmountPerSlowPulse; }
    public float getProtectionRestoreAmountPerAbility() { return protectionRestoreAmountPerAbility; }

    public int getManaRegenCooldownTicksEffect() { return manaRegenCooldownTicksEffect; }
    public float getManaAmountPerEffectPulse() { return manaAmountPerEffectPulse; }

    public int getVigorRegenCooldownTicksEffect() { return vigorRegenCooldownTicksEffect; }
    public float getVigorAmountPerEffectPulse() { return vigorAmountPerEffectPulse; }

    public float getHungryModerateMovementSpeedPenalty() { return hungryModerateMovementSpeedPenalty; }
    public float getHungryModerateVigorRegenPenalty() { return hungryModerateVigorRegenPenalty; }
    public float getHungryIntenseMovementSpeedPenalty() { return hungryIntenseMovementSpeedPenalty; }
    public float getHungryIntenseVigorRegenPenalty() { return hungryIntenseVigorRegenPenalty; }
    public float getStarvingMovementSpeedPenalty() { return starvingMovementSpeedPenalty; }
    public float getStarvingVigorRegenPenalty() { return starvingVigorRegenPenalty; }
    public int getStarvingDamageIntervalTicks() { return starvingDamageIntervalTicks; }
    public float getStarvingDamageAmount() { return starvingDamageAmount; }


    //Proceso para confirmar si es una clase afín.
    public boolean isClassAffinToStat(String raceName, String className, String statName) {
        Map<String, List<String>> affinitiesForClass = classAffinities.get(className.toUpperCase());
        if (affinitiesForClass == null) return false;
        List<String> affineRaces = affinitiesForClass.get(statName.toUpperCase());
        return affineRaces != null && affineRaces.contains(raceName.toUpperCase());
    }

    //Proceso para saber qué atributos bonifica la clase
    public boolean doesClassBoostAttribute(String className, String attributeName) {
        List<String> boostedAttributes = classAttributeBonuses.get(className.toUpperCase());
        return boostedAttributes != null && boostedAttributes.contains(attributeName.toUpperCase());
    }

    //Recoge el número de puntos de atributo fundamental que gana por nivel
    public int getAttributePointsForLevelRange(int level) {
        for (Map.Entry<String, Integer> entry : levelProgression.entrySet()) {
            String[] range = entry.getKey().split("-");
            try {
                int min = Integer.parseInt(range[0]);
                int max = Integer.parseInt(range[1]);
                if (level >= min && level <= max) {
                    return entry.getValue();
                }
            } catch (NumberFormatException e) {
                System.err.println("BrokenPath: Error parsing level range in config: " + entry.getKey() + ". " + e.getMessage());
            }
        }
        return 0;
    }

    //Dentro de las configuraciones de Raza
    public static class ProtectionInnateConfig {
        public float baseValue;
        public float perLevelIncrease;

        public ProtectionInnateConfig(float baseValue, float perLevelIncrease) {
            this.baseValue = baseValue;
            this.perLevelIncrease = perLevelIncrease;
        }
        public ProtectionInnateConfig() {}
    }

    //Obtiene la configuración de protección innata (base y escalado por nivel) para la raza especificada.
    public ModConfigs.ProtectionInnateConfig getRaceProtectionInnateConfig(String raceName) {
        RaceSettings raceSetting = raceSettings.get(raceName.toUpperCase());
        if (raceSetting == null) {
            System.err.println("BrokenPath: Race setting not found for: " + raceName);
            return null;
        }
        return raceSetting.protectionInnate;
    }

}