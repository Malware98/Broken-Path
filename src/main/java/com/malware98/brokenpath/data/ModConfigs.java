package com.malware98.brokenpath.data;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;
import com.malware98.brokenpath.BrokenPath;
import net.minecraftforge.fml.loading.FMLPaths;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Path;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Main configuration class for the "BrokenPath" mod.
 * Manages all configurable variables related to player stats, races, classes,
 * XP progression, regeneration, penalties, and achievements.
 * Provides functionality to load and save these configurations from/to a JSON file.
 */
public class ModConfigs {

    // --- Configuration Constants ---
    // Singleton instance of ModConfigs.
    private static ModConfigs INSTANCE;
    // Gson object for pretty-printed JSON serialization/deserialization.
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    // Name of the configuration file.
    private static final String CONFIG_FILE_NAME = "brokenpath_configs.json";
    // Full path to the configuration file within Forge's config directory.
    private static final Path CONFIG_PATH = FMLPaths.CONFIGDIR.get().resolve(CONFIG_FILE_NAME);

    // Maximum player level.
    public static final int MAX_LEVEL = 50;

    // Maximum multiplier for Favor bonus.
    public float maxFavorBonusMultiplier = 2.0f;

    // --- Configuration Variables Grouped by Category ---
    // Regeneration settings for health, mana, vigor, and protection.
    public RegenSettings regenSettings;
    // Combat-related settings, such as damage penetration.
    public CombatSettings combatSettings;
    // XP progression and smelting XP rewards.
    public XpSettings xpSettings;
    // Achievement definitions, including XP rewards and thresholds.
    public Map<String, AchievementConfig> achievements;

    // Core attribute settings, like manual allocation limits.
    public AttributeSettings attributeSettings;
    // Base stat configurations for each race.
    public Map<String, RaceSettings> raceSettings;
    // Class affinities, defining which stats a class is strong with for certain races.
    public Map<String, Map<String, List<String>>> classAffinities;
    // Fundamental attribute bonuses granted by specific classes.
    public Map<String, List<String>> classAttributeBonuses; // Will be removed/repurposed later
    // Flat stat bonuses granted by classes.
    public Map<String, Map<String, Float>> classStatBonuses;
    // Flat stat bonuses granted by specializations.
    public Map<String, Map<String, Float>> specializationStatBonuses;
    // Attribute point progression per level range.
    public Map<String, Integer> levelProgression;
    // Favor modifiers applied for specific player actions.
    public Map<String, Float> favorActionModifiers;

    public VillagerTradeSettings villagerTradeSettings;


    // --- Constructor and Singleton Pattern ---
    // Private constructor to enforce the Singleton pattern.
    private ModConfigs() {
        // Initialize all values with their default settings.
        // This ensures valid default configurations even if JSON loading fails or the file doesn't exist.
        initializeDefaults();
    }

    /**
     * Provides the single instance of {@link ModConfigs}.
     * Implements the Singleton pattern to ensure a consistent configuration across the mod.
     * @return The singleton instance of ModConfigs.
     */
    public static ModConfigs getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new ModConfigs();
        }
        return INSTANCE;
    }

    // --- Default Initialization Logic ---
    // Initializes all configuration values with their default settings.
    private void initializeDefaults() {
        // Initialize maps to prevent NullPointerExceptions if JSON sections are missing or malformed.
        attributeSettings = new AttributeSettings();
        raceSettings = new HashMap<>();
        classAffinities = new HashMap<>();
        classAttributeBonuses = new HashMap<>(); // Will be removed/repurposed.
        classStatBonuses = new HashMap<>();
        specializationStatBonuses = new HashMap<>();
        levelProgression = new HashMap<>();
        favorActionModifiers = new HashMap<>();
        achievements = new HashMap<>();

        // Initialize nested configuration classes.
        regenSettings = new RegenSettings();
        combatSettings = new CombatSettings();
        xpSettings = new XpSettings();
        villagerTradeSettings = new VillagerTradeSettings();

        // --- Default Attribute Allocation Limits ---
        attributeSettings = new AttributeSettings();
        attributeSettings.manualAllocationLimit.put("CONSTITUTION", 70);
        attributeSettings.manualAllocationLimit.put("STRENGTH", 70);
        attributeSettings.manualAllocationLimit.put("DEXTERITY", 70);
        attributeSettings.manualAllocationLimit.put("INTELLIGENCE", 70);

        // NEW: Global multipliers for attribute points to stats
        attributeSettings.conMultiplier = 1.0f; // 1 Health per CON point
        attributeSettings.strMultiplier = 1.0f; // 1 Protection per STR point (efficacy)
        attributeSettings.intMultiplier = 1.0f; // 1 Mana per INT point
        attributeSettings.dexMultiplier = 1.0f; // 1 Vigor per DEX point

        // NEW: Global racial affinity multiplier
        attributeSettings.racialAffinityMultiplier = 1.2f; // Example: 20% bonus if race is affine to class

        // NEW: Global Innate Protection per level increase
        attributeSettings.innateProtectionPerLevelIncrease = 0.2f; // 0.2 innate protection per player level (beyond level 1)

        // --- Default XP Progression Settings ---
        xpSettings.xpProgression.baseXp = 100.0f;
        xpSettings.xpProgression.linearXpCoefficient = 50.0f;
        xpSettings.xpProgression.polynomialXpCoefficient = 1.2f;
        xpSettings.xpProgression.polynomialXpExponent = 2.5f;
        xpSettings.xpProgression.minXpPerLevel = 100;

        // --- Initial Race Stat Configurations ---
        // Defines the base stats for each playable race.
        // These are only initial values, attributes and affinities will apply multipliers later.

        RaceSettings spiritSettings = new RaceSettings();
        spiritSettings.health = createStatConfig(20.0f, HealthStatConfig.class);
        spiritSettings.protection = createStatConfig(0.0f, ProtectionStatConfig.class);
        spiritSettings.protectionInnate = createProtectionInnateConfig(0.0f);
        spiritSettings.mana = createStatConfig(0.0f, ManaStatConfig.class);
        spiritSettings.vigor = createStatConfig(0.0f, VigorStatConfig.class);
        spiritSettings.favor = new FavorConfig(50.0f, 200.0f, 0.0f);
        raceSettings.put("SPIRIT", spiritSettings);

        RaceSettings humanSettings = new RaceSettings();
        humanSettings.health = createStatConfig(20.0f, HealthStatConfig.class);
        humanSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        humanSettings.protectionInnate = createProtectionInnateConfig(0.0f);
        humanSettings.mana = createStatConfig(20.0f, ManaStatConfig.class);
        humanSettings.vigor = createStatConfig(20.0f, VigorStatConfig.class);
        humanSettings.favor = new FavorConfig(70.0f, 200.0f, 0.0f);
        raceSettings.put("HUMAN", humanSettings);

        RaceSettings elfSettings = new RaceSettings();
        elfSettings.health = createStatConfig(14.0f, HealthStatConfig.class);
        elfSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        elfSettings.protectionInnate = createProtectionInnateConfig(0.0f);
        elfSettings.mana = createStatConfig(40.0f, ManaStatConfig.class);
        elfSettings.vigor = createStatConfig(20.0f, VigorStatConfig.class);
        elfSettings.favor = new FavorConfig(0.0f, 200.0f, 0.0f);
        raceSettings.put("ELF", elfSettings);

        RaceSettings orcSettings = new RaceSettings();
        orcSettings.health = createStatConfig(30.0f, HealthStatConfig.class);
        orcSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        orcSettings.protectionInnate = createProtectionInnateConfig(0.0f);
        orcSettings.mana = createStatConfig(0.0f, ManaStatConfig.class);
        orcSettings.vigor = createStatConfig(40.0f, VigorStatConfig.class);
        orcSettings.favor = new FavorConfig(50.0f, 200.0f, 0.0f);
        raceSettings.put("ORC", orcSettings);

        RaceSettings draconidSettings = new RaceSettings();
        draconidSettings.health = createStatConfig(16.0f, HealthStatConfig.class);
        draconidSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        draconidSettings.protectionInnate = createProtectionInnateConfig(10.0f);
        draconidSettings.mana = createStatConfig(30.0f, ManaStatConfig.class);
        draconidSettings.vigor = createStatConfig(20.0f, VigorStatConfig.class);
        draconidSettings.favor = new FavorConfig(20.0f, 200.0f, 0.0f);
        raceSettings.put("DRACONID", draconidSettings);

        RaceSettings chimeraAgileSettings = new RaceSettings();
        chimeraAgileSettings.health = createStatConfig(16.0f, HealthStatConfig.class);
        chimeraAgileSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        chimeraAgileSettings.protectionInnate = createProtectionInnateConfig(10.0f);
        chimeraAgileSettings.mana = createStatConfig(20.0f, ManaStatConfig.class);
        chimeraAgileSettings.vigor = createStatConfig(20.0f, VigorStatConfig.class);
        chimeraAgileSettings.favor = new FavorConfig(50.0f, 200.0f, 0.0f);
        raceSettings.put("CHIMERA_AGILE", chimeraAgileSettings);

        RaceSettings chimeraDefensiveSettings = new RaceSettings();
        chimeraDefensiveSettings.health = createStatConfig(20.0f, HealthStatConfig.class);
        chimeraDefensiveSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        chimeraDefensiveSettings.protectionInnate = createProtectionInnateConfig(10.0f);
        chimeraDefensiveSettings.mana = createStatConfig(20.0f, ManaStatConfig.class);
        chimeraDefensiveSettings.vigor = createStatConfig(20.0f, VigorStatConfig.class);
        chimeraDefensiveSettings.favor = new FavorConfig(50.0f, 200.0f, 0.0f);
        raceSettings.put("CHIMERA_DEFENSIVE", chimeraDefensiveSettings);

        RaceSettings tritonSettings = new RaceSettings();
        tritonSettings.health = createStatConfig(18.0f, HealthStatConfig.class);
        tritonSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        tritonSettings.protectionInnate = createProtectionInnateConfig(10.0f);
        tritonSettings.mana = createStatConfig(20.0f, ManaStatConfig.class);
        tritonSettings.vigor = createStatConfig(20.0f, VigorStatConfig.class);
        tritonSettings.favor = new FavorConfig(80.0f, 200.0f, 0.0f);
        raceSettings.put("TRITON", tritonSettings);

        RaceSettings aasimarSettings = new RaceSettings();
        aasimarSettings.health = createStatConfig(16.0f, HealthStatConfig.class);
        aasimarSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        aasimarSettings.protectionInnate = createProtectionInnateConfig(10.0f);
        aasimarSettings.mana = createStatConfig(20.0f, ManaStatConfig.class);
        aasimarSettings.vigor = createStatConfig(20.0f, VigorStatConfig.class);
        aasimarSettings.favor = new FavorConfig(100.0f, 200.0f, 0.0f);
        raceSettings.put("AASIMAR", aasimarSettings);

        RaceSettings androidSettings = new RaceSettings();
        androidSettings.health = createStatConfig(10.0f, HealthStatConfig.class);
        androidSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        androidSettings.protectionInnate = createProtectionInnateConfig(20.0f);
        androidSettings.mana = createStatConfig(0.0f, ManaStatConfig.class);
        androidSettings.vigor = createStatConfig(40.0f, VigorStatConfig.class);
        androidSettings.favor = new FavorConfig(80.0f, 200.0f, 0.0f);
        raceSettings.put("ANDROID", androidSettings);

        // --- Class Affinities (remains as is, defines which race-class combos get affinity bonus) ---
        classAffinities.put("CHAMPION", Map.of("HEALTH", List.of("HUMAN"), "PROTECTION", List.of("HUMAN")));
        classAffinities.put("SORCERER", Map.of("MANA", List.of("ELF"), "PROTECTION", List.of("ELF")));
        classAffinities.put("BERSERKER", Map.of("HEALTH", List.of("ORC"), "VIGOR", List.of("ORC")));
        classAffinities.put("SHAMAN", Map.of("MANA", List.of("DRACONID"), "VIGOR", List.of("DRACONID")));
        classAffinities.put("EXPLORER", Map.of("VIGOR", List.of("CHIMERA_AGILE"), "PROTECTION", List.of("CHIMERA_AGILE")));
        classAffinities.put("CHANNELER", Map.of("MANA", List.of("TRITON"), "HEALTH", List.of("TRITON")));
        classAffinities.put("VESTAL", Map.of("PROTECTION", List.of("AASIMAR"), "MANA", List.of("AASIMAR")));
        classAffinities.put("TECHNOMANCER", Map.of("PROTECTION", List.of("ANDROID"), "VIGOR", List.of("ANDROID")));
        classAffinities.put("NO_CLASS", Map.of(
                "HEALTH", Collections.emptyList(),
                "MANA", Collections.emptyList(),
                "VIGOR", Collections.emptyList(),
                "PROTECTION", Collections.emptyList()
        ));

        // --- Fundamental Attribute Bonuses per Class (will be removed as it's replaced by classStatBonuses) ---
        classAttributeBonuses.put("CHAMPION", List.of("CONSTITUTION", "STRENGTH"));
        classAttributeBonuses.put("SORCERER", List.of("INTELLIGENCE", "STRENGTH"));
        classAttributeBonuses.put("BERSERKER", List.of("CONSTITUTION", "DEXTERITY"));
        classAttributeBonuses.put("SHAMAN", List.of("INTELLIGENCE", "DEXTERITY"));
        classAttributeBonuses.put("EXPLORER", List.of("DEXTERITY", "STRENGTH"));
        classAttributeBonuses.put("CHANNELER", List.of("INTELLIGENCE", "CONSTITUTION"));
        classAttributeBonuses.put("VESTAL", List.of("STRENGTH", "INTELLIGENCE"));
        classAttributeBonuses.put("TECHNOMANCER", List.of("STRENGTH", "DEXTERITY"));
        classAttributeBonuses.put("NO_CLASS", Collections.emptyList());

        // NEW: Class Flat Stat Bonuses
        classStatBonuses.put("CHAMPION", Map.of("HEALTH", 5.0f));
        classStatBonuses.put("SORCERER", Map.of("MANA", 5.0f));
        classStatBonuses.put("BERSERKER", Map.of("VIGOR", 5.0f));
        classStatBonuses.put("SHAMAN", Map.of("MANA", 5.0f));
        classStatBonuses.put("EXPLORER", Map.of("VIGOR", 5.0f));
        classStatBonuses.put("CHANNELER", Map.of("HEALTH", 5.0f));
        classStatBonuses.put("VESTAL", Map.of("PROTECTION", 5.0f));
        classStatBonuses.put("TECHNOMANCER", Map.of("PROTECTION", 5.0f));
        classStatBonuses.put("NO_CLASS", Collections.emptyMap());

        // NEW: Specialization Flat Stat Bonuses
        specializationStatBonuses.put("NO_SPECIALIZATION", Collections.emptyMap()); // Placeholder
        // Example for a specific specialization (you'll need to define yours)
        // specializationStatBonuses.put("SWORD_MASTER", Map.of("PROTECTION", 3.0f));


        // --- Attribute Point Allocation per Level Progression ---
        levelProgression.put("1-1", 0);
        levelProgression.put("2-10", 1);
        levelProgression.put("11-20", 2);
        levelProgression.put("21-30", 3);
        levelProgression.put("31-40", 4);
        levelProgression.put("41-49", 5);
        levelProgression.put("50-50", 6);

        // --- Favor Action Modifiers ---
        favorActionModifiers.put("TAME_WOLF", 1.5f);
        favorActionModifiers.put("TAME_CAT", 1.5f);
        favorActionModifiers.put("TAME_HORSE", 1.5f);
        favorActionModifiers.put("TAME_DONKEY", 1.5f);
        favorActionModifiers.put("TAME_MULE", 1.5f);
        favorActionModifiers.put("TAME_LLAMA", 1.5f);
        favorActionModifiers.put("FEED_CHICKEN", 1.0f);
        favorActionModifiers.put("FEED_COW", 1.0f);
        favorActionModifiers.put("FEED_PIG", 1.0f);
        favorActionModifiers.put("FEED_SHEEP", 1.0f);
        favorActionModifiers.put("FEED_PARROT", 1.0f);
        favorActionModifiers.put("FEED_PANDA", 1.0f);
        favorActionModifiers.put("FEED_FOX", 1.0f);

        favorActionModifiers.put("KILL_WOLF", -2.5f);
        favorActionModifiers.put("KILL_CAT", -2.5f);
        favorActionModifiers.put("KILL_HORSE", -2.5f);
        favorActionModifiers.put("KILL_DONKEY", -2.5f);
        favorActionModifiers.put("KILL_MULE", -2.5f);
        favorActionModifiers.put("KILL_LLAMA", -2.5f);
        favorActionModifiers.put("KILL_PARROT", -2.5f);
        favorActionModifiers.put("KILL_PANDA", -2.5f);
        favorActionModifiers.put("KILL_FOX", -2.5f);

        favorActionModifiers.put("TRADE_FARMER", 0.75f);
        favorActionModifiers.put("TRADE_FISHERMAN", 0.75f);
        favorActionModifiers.put("TRADE_SHEPHERD", 0.75f);
        favorActionModifiers.put("TRADE_LEATHERWORKER", 0.75f);
        favorActionModifiers.put("TRADE_MASON", 0.75f);

        favorActionModifiers.put("TRADE_CARTOGRAPHER", 1.0f);
        favorActionModifiers.put("TRADE_FLETCHER", 1.0f);
        favorActionModifiers.put("TRADE_BUTCHER", 1.0f);
        favorActionModifiers.put("TRADE_TOOLSMITH", 1.25f);
        favorActionModifiers.put("TRADE_WEAPONSMITH", 1.25f);

        favorActionModifiers.put("TRADE_LIBRARIAN", 1.75f);
        favorActionModifiers.put("TRADE_CLERIC", 1.75f);
        favorActionModifiers.put("TRADE_ARMORER", 1.75f);
        favorActionModifiers.put("DEFEND_RAID", 15.0f);

        favorActionModifiers.put("TRADE_VILLAGER", 0.5f);

        favorActionModifiers.put("ATTACK_VILLAGER", -1.5f);
        favorActionModifiers.put("ATTACK_FARMER", -2.0f);
        favorActionModifiers.put("ATTACK_FISHERMAN", -2.0f);
        favorActionModifiers.put("ATTACK_SHEPHERD", -2.0f);
        favorActionModifiers.put("ATTACK_LEATHERWORKER", -2.0f);
        favorActionModifiers.put("ATTACK_MASON", -2.0f);
        favorActionModifiers.put("ATTACK_CARTOGRAPHER", -2.5f);
        favorActionModifiers.put("ATTACK_FLETCHER", -2.5f);
        favorActionModifiers.put("ATTACK_BUTCHER", -2.5f);
        favorActionModifiers.put("ATTACK_TOOLSMITH", -3.0f);
        favorActionModifiers.put("ATTACK_WEAPONSMITH", -3.0f);
        favorActionModifiers.put("ATTACK_ARMORER", -3.0f);
        favorActionModifiers.put("ATTACK_LIBRARIAN", -3.5f);
        favorActionModifiers.put("ATTACK_CLERIC", -4.0f);
        favorActionModifiers.put("KILL_VILLAGER", -7.5f);
        favorActionModifiers.put("DESTROY_VILLAGE_BLOCK", -2.5f);

        favorActionModifiers.put("REPAIR_GOLEM", 0.5f);

        favorActionModifiers.put("DAMAGE_GOLEM", -1.0f);
        favorActionModifiers.put("SHEAR_SNOW_GOLEM_PUMPKIN", -2.5f);
        favorActionModifiers.put("KILL_GOLEM", -5.0f);

        // --- Smelting XP Rewards ---
        xpSettings.smeltingXpRewards.put("minecraft:iron_ingot", 2);
        xpSettings.smeltingXpRewards.put("minecraft:gold_ingot", 3);
        xpSettings.smeltingXpRewards.put("minecraft:copper_ingot", 1);
        xpSettings.smeltingXpRewards.put("minecraft:cooked_beef", 1);
        xpSettings.smeltingXpRewards.put("minecraft:charcoal", 1);
        xpSettings.smeltingXpRewards.put("minecraft:lapis_lazuli", 2);
        xpSettings.smeltingXpRewards.put("minecraft:redstone", 2);
        xpSettings.smeltingXpRewards.put("minecraft:emerald", 2);
        xpSettings.smeltingXpRewards.put("minecraft:diamond", 4);
        xpSettings.smeltingXpRewards.put("minecraft:coal", 1);
        xpSettings.smeltingXpRewards.put("minecraft:quartz", 2);
        xpSettings.smeltingXpRewards.put("minecraft:netherite_scrap", 10);
        xpSettings.smeltingXpRewards.put("minecraft:cooked_porkchop", 1);
        xpSettings.smeltingXpRewards.put("minecraft:cooked_chicken", 1);
        xpSettings.smeltingXpRewards.put("minecraft:cooked_mutton", 1);
        xpSettings.smeltingXpRewards.put("minecraft:cooked_rabbit", 1);
        xpSettings.smeltingXpRewards.put("minecraft:cooked_fish", 1);
        xpSettings.smeltingXpRewards.put("minecraft:cooked_salmon", 1);
        xpSettings.smeltingXpRewards.put("minecraft:baked_potato", 1);
        xpSettings.smeltingXpRewards.put("minecraft:dried_kelp", 1);
        xpSettings.smeltingXpRewards.put("minecraft:stone", 1);
        xpSettings.smeltingXpRewards.put("minecraft:smooth_stone", 1);
        xpSettings.smeltingXpRewards.put("minecraft:brick", 1);
        xpSettings.smeltingXpRewards.put("minecraft:nether_brick", 1);
        xpSettings.smeltingXpRewards.put("minecraft:green_dye", 1);
        xpSettings.smeltingXpRewards.put("minecraft:sponge", 1);
        xpSettings.smeltingXpRewards.put("minecraft:glass", 1);

        xpSettings.xpLossPercentageOnDeath = 0.10f;
        xpSettings.xpMaxDebtPercentage = 0.15f;
        xpSettings.defaultSmeltingXp = 1;

        villagerTradeSettings.tradeFavorCooldownTicks = 20 * 60 * 5;
        villagerTradeSettings.maxTradesBeforeCooldown = 10;
        villagerTradeSettings.defaultTradeXp = 5;

        // --- Achievement Configurations ---
        achievements.put("EXPLORATION_ROOT", new AchievementConfig(20, 1));
        achievements.put("EXPLORER_NOVICE", new AchievementConfig(10, 5));
        achievements.put("LOCAL_ADVENTURER", new AchievementConfig(50, 10));
        achievements.put("ACCOMPLISHED_CARTOGRAPHER", new AchievementConfig(100, 15));
        achievements.put("UNKNOWN_PIONEER", new AchievementConfig(200, 1));

        achievements.put("FLEDGLING_ADVOCATE", new AchievementConfig(40, 10));
        achievements.put("CREATURE_HUNTER", new AchievementConfig(90, 50));
        achievements.put("THREATS_EXTERMINATOR", new AchievementConfig(300, 200));
        achievements.put("SHADOWS_TERROR", new AchievementConfig(600, 500));
        achievements.put("MASACRE_MASTER", new AchievementConfig(1000, 1000));

        achievements.put("ROCK_FINDER", new AchievementConfig(10, 64));
        achievements.put("AMATEUR_EXCAVATOR", new AchievementConfig(60, 100));
        achievements.put("SKILLED_MINERALOGIST", new AchievementConfig(180, 500));
        achievements.put("GEOLOGIST_EXPERT", new AchievementConfig(350, 1000));
        achievements.put("MINING_MASTER", new AchievementConfig(700, 2500));
        achievements.put("HIDDEN_TREASURE", new AchievementConfig(250, 50));
        achievements.put("MASTER_OBSIDIAN", new AchievementConfig(150, 20));

        achievements.put("NOVICE_SOWER", new AchievementConfig(30, 50));
        achievements.put("DEDICATED_FARMER", new AchievementConfig(80, 200));
        achievements.put("ACCOMPLISHED_AGRONOMIST", new AchievementConfig(180, 500));
        achievements.put("HARVEST_POWER", new AchievementConfig(350, 1000));
        achievements.put("BEAST_TAMER", new AchievementConfig(100, 3));
        achievements.put("TIRELESS_SHEPHERD", new AchievementConfig(200, 10));
        achievements.put("SUCCESSFUL_BREEDER", new AchievementConfig(150, 20));

        achievements.put("NOVICE_CRAFTER", new AchievementConfig(20, 25));
        achievements.put("CREATIVE_CRAFTER", new AchievementConfig(50, 50));
        achievements.put("ARTISAN_APPRENTICE", new AchievementConfig(100, 100));
        achievements.put("MASTER_CRAFTSMAN", new AchievementConfig(250, 150));
        achievements.put("ART_KITCHEN", new AchievementConfig(70, 50));
        achievements.put("TIRELESS_FURNACE", new AchievementConfig(160, 200));

        achievements.put("FIRST_STEPS", new AchievementConfig(10, 100));
        achievements.put("CONSTANT_WALKER", new AchievementConfig(100, 1000));
        achievements.put("TIRELESS_TRAVELER", new AchievementConfig(250, 5000));
        achievements.put("HUNGER_RESISTANT", new AchievementConfig(180, 1));
        achievements.put("A_WHOLE_DAY", new AchievementConfig(50, 1));
        achievements.put("ONE_WEEK_WORLD", new AchievementConfig(200, 7));
        achievements.put("IM_STILL_ALIVE", new AchievementConfig(800, 30));
        achievements.put("SURVIVAL_ROOT", new AchievementConfig(10, 1));
    }

    // --- Helper Methods for Configuration Creation ---
    // These methods simplify the creation of stat configuration objects,
    // ensuring consistency and readability in the default initialization.

    // NEW: Generic method to create a StatConfigBase or its subclass
    private <T extends StatConfigBase> T createStatConfig(float baseInitialValue, Class<T> clazz) {
        try {
            T config = clazz.getDeclaredConstructor().newInstance();
            config.baseInitialValue = baseInitialValue;
            return config;
        } catch (Exception e) {
            BrokenPath.LOGGER.error("Failed to create StatConfig of type {}. Error: {}", clazz.getName(), e.getMessage());
            // Fallback to a generic StatConfigBase to prevent null
            StatConfigBase fallback = new StatConfigBase() {};
            fallback.baseInitialValue = baseInitialValue;
            return (T) fallback; // This cast is safe if default constructor is always called as fallback
        }
    }

    /**
     * Configures the scaling for Innate Protection.
     * @param baseValue The base innate protection value.
     * @return A new {@link ProtectionInnateConfig} instance.
     */
    private ProtectionInnateConfig createProtectionInnateConfig(float baseValue) {
        return new ProtectionInnateConfig(baseValue);
    }

    // --- Configuration Loading and Saving ---

    /**
     * Loads the mod's configuration from the JSON file.
     * If the file does not exist, is empty, or is malformed, it creates a new one
     * with default values and saves it. This ensures robustness and ease of setup.
     */
    public static void loadConfig() {
        File configFile = CONFIG_PATH.toFile();

        if (configFile.exists()) {
            try (FileReader reader = new FileReader(configFile)) {
                INSTANCE = GSON.fromJson(reader, ModConfigs.class);
                if (INSTANCE == null) {
                    BrokenPath.LOGGER.warn("Configuration file '{}' was empty or invalid JSON. Loading default configurations.", CONFIG_FILE_NAME);
                    INSTANCE = new ModConfigs(); // Fallback to defaults if JSON is empty/invalid.
                }
            } catch (JsonSyntaxException e) {
                BrokenPath.LOGGER.error("Error parsing configuration file '{}'. Please check JSON syntax. Loading default configurations. Error: {}", CONFIG_FILE_NAME, e.getMessage());
                INSTANCE = new ModConfigs(); // Fallback on JSON syntax errors.
            } catch (IOException e) {
                BrokenPath.LOGGER.error("Failed to read configuration file '{}'. Loading default configurations. Error: {}", CONFIG_FILE_NAME, e.getMessage());
                INSTANCE = new ModConfigs(); // Fallback on I/O errors.
            }
        } else {
            BrokenPath.LOGGER.info("Configuration file '{}' not found. Creating with default configurations.", CONFIG_FILE_NAME);
            INSTANCE = new ModConfigs(); // Create new instance with defaults.
            saveConfig(); // Save the newly generated default configuration.
        }

        // --- Post-Load Safety Net ---
        // Ensures that all internal maps and objects are properly initialized
        // with default values if Gson couldn't load them (e.g., if a section was missing in JSON).
        // This is an additional layer of robustness against incomplete or older config files.
        INSTANCE.attributeSettings = Optional.ofNullable(INSTANCE.attributeSettings).orElseGet(AttributeSettings::new);
        INSTANCE.attributeSettings.manualAllocationLimit = Optional.ofNullable(INSTANCE.attributeSettings.manualAllocationLimit).orElseGet(HashMap::new);
        // NEW: Ensure global attribute multipliers and affinity multiplier are initialized
        if (INSTANCE.attributeSettings.conMultiplier == 0.0f) INSTANCE.attributeSettings.conMultiplier = 1.0f;
        if (INSTANCE.attributeSettings.strMultiplier == 0.0f) INSTANCE.attributeSettings.strMultiplier = 1.0f;
        if (INSTANCE.attributeSettings.intMultiplier == 0.0f) INSTANCE.attributeSettings.intMultiplier = 1.0f;
        if (INSTANCE.attributeSettings.dexMultiplier == 0.0f) INSTANCE.attributeSettings.dexMultiplier = 1.0f;
        if (INSTANCE.attributeSettings.racialAffinityMultiplier == 0.0f) INSTANCE.attributeSettings.racialAffinityMultiplier = 1.2f;
        // NEW: Ensure global innate protection per level increase is initialized
        if (INSTANCE.attributeSettings.innateProtectionPerLevelIncrease == 0.0f) INSTANCE.attributeSettings.innateProtectionPerLevelIncrease = 0.2f;


        INSTANCE.raceSettings = Optional.ofNullable(INSTANCE.raceSettings).orElseGet(HashMap::new);
        for (Map.Entry<String, RaceSettings> entry : INSTANCE.raceSettings.entrySet()) {
            RaceSettings rs = entry.getValue();
            rs.health = Optional.ofNullable(rs.health).orElseGet(HealthStatConfig::new);
            rs.mana = Optional.ofNullable(rs.mana).orElseGet(ManaStatConfig::new);
            rs.vigor = Optional.ofNullable(rs.vigor).orElseGet(VigorStatConfig::new);
            rs.protection = Optional.ofNullable(rs.protection).orElseGet(ProtectionStatConfig::new);
            rs.protectionInnate = Optional.ofNullable(rs.protectionInnate).orElseGet(ProtectionInnateConfig::new);
            rs.favor = Optional.ofNullable(rs.favor).orElseGet(FavorConfig::new);
        }

        INSTANCE.classAffinities = Optional.ofNullable(INSTANCE.classAffinities).orElseGet(HashMap::new);
        INSTANCE.classAttributeBonuses = Optional.ofNullable(INSTANCE.classAttributeBonuses).orElseGet(HashMap::new);
        INSTANCE.classStatBonuses = Optional.ofNullable(INSTANCE.classStatBonuses).orElseGet(HashMap::new);
        INSTANCE.specializationStatBonuses = Optional.ofNullable(INSTANCE.specializationStatBonuses).orElseGet(HashMap::new);
        INSTANCE.levelProgression = Optional.ofNullable(INSTANCE.levelProgression).orElseGet(HashMap::new);
        INSTANCE.favorActionModifiers = Optional.ofNullable(INSTANCE.favorActionModifiers).orElseGet(HashMap::new);
        INSTANCE.achievements = Optional.ofNullable(INSTANCE.achievements).orElseGet(HashMap::new);

        INSTANCE.regenSettings = Optional.ofNullable(INSTANCE.regenSettings).orElseGet(RegenSettings::new);
        INSTANCE.combatSettings = Optional.ofNullable(INSTANCE.combatSettings).orElseGet(CombatSettings::new);
        INSTANCE.xpSettings = Optional.ofNullable(INSTANCE.xpSettings).orElseGet(XpSettings::new);
        INSTANCE.xpSettings.xpProgression = Optional.ofNullable(INSTANCE.xpSettings.xpProgression).orElseGet(XpProgressionSettings::new);
        INSTANCE.xpSettings.smeltingXpRewards = Optional.ofNullable(INSTANCE.xpSettings.smeltingXpRewards).orElseGet(HashMap::new);

        INSTANCE.villagerTradeSettings = Optional.ofNullable(INSTANCE.villagerTradeSettings).orElseGet(VillagerTradeSettings::new);
    }

    /**
     * Saves the current mod configuration to the JSON file.
     * This allows users to persist their custom settings.
     */
    public static void saveConfig() {
        File configFile = CONFIG_PATH.toFile();
        try (FileWriter writer = new FileWriter(configFile)) {
            GSON.toJson(INSTANCE, writer);
        } catch (IOException e) {
            BrokenPath.LOGGER.error("Failed to save configuration file '{}'. Error: {}", CONFIG_FILE_NAME, e.getMessage());
        }
    }

    // --- Configuration Logic Methods ---

    /**
     * Calculates the amount of XP required for the next level based on a configurable formula.
     * @param currentLevel The player's current level.
     * @return The XP needed to reach the next level, or 0 if at max level.
     */
    public int getXPForNextLevel(int currentLevel) {
        if (currentLevel >= MAX_LEVEL) {
            return 0; // No more XP needed at max level.
        }

        final float A = xpSettings.xpProgression.baseXp;
        final float B = xpSettings.xpProgression.linearXpCoefficient;
        final float C = xpSettings.xpProgression.polynomialXpCoefficient;
        final float EXP = xpSettings.xpProgression.polynomialXpExponent;

        // Formula: XP_Needed = A + (B * Level) + (C * Level^EXP)
        double xpNeededDouble = A + (B * currentLevel) + (C * Math.pow(currentLevel, EXP));

        int xpNeeded = (int) Math.round(xpNeededDouble);

        // Ensure a minimum XP per level, especially at lower levels where the formula might yield low values.
        if (xpNeeded < xpSettings.xpProgression.minXpPerLevel) {
            xpNeeded = xpSettings.xpProgression.minXpPerLevel;
        }
        return xpNeeded;
    }

    /**
     * Checks if a specific class has an affinity with a given stat for a particular race.
     * Class affinities provide bonus scaling for certain stats.
     * @param raceName The name of the race.
     * @param className The name of the class.
     * @param statName The name of the stat (e.g., "HEALTH", "MANA").
     * @return True if the class is affine to the stat for that race, false otherwise.
     */
    public boolean isClassAffinToStat(String raceName, String className, String statName) {
        Map<String, List<String>> affinitiesForClass = classAffinities.get(className.toUpperCase());
        if (affinitiesForClass == null) return false;
        List<String> affineRaces = affinitiesForClass.get(statName.toUpperCase());
        return affineRaces != null && affineRaces.contains(raceName.toUpperCase());
    }

    /**
     * Checks if a specific class provides a bonus to a fundamental attribute.
     * @param className The name of the class.
     * @param attributeName The name of the attribute (e.g., "CONSTITUTION", "STRENGTH").
     * @return True if the class boosts the attribute, false otherwise.
     */
    public boolean doesClassBoostAttribute(String className, String attributeName) {
        List<String> boostedAttributes = classAttributeBonuses.get(className.toUpperCase());
        return boostedAttributes != null && boostedAttributes.contains(attributeName.toUpperCase());
    }

    /**
     * Retrieves the number of fundamental attribute points granted for reaching a specific level.
     * @param level The player's level.
     * @return The number of attribute points awarded for that level.
     */
    public int getAttributePointsForLevelRange(int level) {
        for (Map.Entry<String, Integer> entry : levelProgression.entrySet()) {
            String[] range = entry.getKey().split("-");
            try {
                int min = Integer.parseInt(range[0]);
                int max = Integer.parseInt(range[1]);
                if (level >= min && level <= max) {
                    return entry.getValue();
                }
            } catch (NumberFormatException e) {
                BrokenPath.LOGGER.error("Error parsing level range in configuration: {}. Error: {}", entry.getKey(), e.getMessage());
            }
        }
        return 0;
    }

    // --- Nested Classes for JSON Mapping ---

    /**
     * Configuration for manual attribute allocation limits and global attribute multipliers.
     */
    public static class AttributeSettings {
        public Map<String, Integer> manualAllocationLimit = new HashMap<>();
        public float conMultiplier;
        public float strMultiplier;
        public float intMultiplier;
        public float dexMultiplier;
        public float racialAffinityMultiplier;
        public float innateProtectionPerLevelIncrease;
        public AttributeSettings() {}
    }

    /**
     * Contains base stat configurations for each race.
     */
    public static class RaceSettings {
        public HealthStatConfig health;
        public ManaStatConfig mana;
        public VigorStatConfig vigor;
        public ProtectionStatConfig protection;
        public ProtectionInnateConfig protectionInnate;
        public FavorConfig favor;

        public RaceSettings() {
            health = new HealthStatConfig();
            mana = new ManaStatConfig();
            vigor = new VigorStatConfig();
            protection = new ProtectionStatConfig();
            protectionInnate = new ProtectionInnateConfig();
            favor = new FavorConfig();
        }
    }

    /**
     * Base class for stat configurations, containing common fields like base initial value.
     */
    public static abstract class StatConfigBase {
        public float baseInitialValue;
        public StatConfigBase() {}
    }

    /**
     * Specific configuration for Health stat.
     */
    public static class HealthStatConfig extends StatConfigBase {
        public HealthStatConfig() {}
    }

    /**
     * Specific configuration for Mana stat.
     */
    public static class ManaStatConfig extends StatConfigBase {
        public ManaStatConfig() {}
    }

    /**
     * Specific configuration for Vigor stat.
     */
    public static class VigorStatConfig extends StatConfigBase {
        public VigorStatConfig() {}
    }

    /**
     * Detailed configuration for the Protection stat.
     */
    public static class ProtectionStatConfig extends StatConfigBase {
        public ProtectionStatConfig() {}
        public ProtectionStatConfig(float baseInitialValue) {
            this.baseInitialValue = baseInitialValue;
        }
    }

    /**
     * Detailed configuration for the Favor system, including base value and limits.
     */
    public static class FavorConfig {
        public float baseFavor;
        public float maxLimit;
        public float minLimit;

        public FavorConfig() {
            this.baseFavor = 70f;
            this.maxLimit = 200.0f;
            this.minLimit = 0.0f;
        }

        public FavorConfig(float baseFavor, float maxLimit, float minLimit) {
            this.baseFavor = baseFavor;
            this.maxLimit = maxLimit;
            this.minLimit = minLimit;
        }
    }

    /**
     * Defines multiplier and limit for stat scaling based on affinities (Base, Class Bonus, Racial Affinity).
     * This class is now deprecated as affinity scaling is simplified.
     */
    public static class AffinityLimit {
        public float multiplier;
        public float limit;
        public AffinityLimit(float multiplier, float limit) {
            this.multiplier = multiplier;
            this.limit = limit;
        }
        public AffinityLimit() {}
    }

    /**
     * Configuration settings for XP progression, including formula coefficients.
     */
    public static class XpProgressionSettings {
        public float baseXp;
        public float linearXpCoefficient;
        public float polynomialXpCoefficient;
        public float polynomialXpExponent;
        public int minXpPerLevel;
        public XpProgressionSettings() {}
    }

    /**
     * Configuration for Innate Protection, defining its base value.
     */
    public static class ProtectionInnateConfig {
        public float baseValue;
        public ProtectionInnateConfig(float baseValue) {
            this.baseValue = baseValue;
        }
        public ProtectionInnateConfig() {}
    }

    /**
     * Groups all regeneration-related configurations.
     */
    public static class RegenSettings {

        // Common handlers
        public int baseRegenPulseCooldownTicks = 5;

        // Health Regeneration
        public float healthAmountToHealPerPulse = 0.15f;
        public float healthExhaustionCostPerHealPulse = 2.5f;
        public int healthMinFoodLevelForRegen = 16;
        public int healthDelayAfterCombatTicks = 100;
        public int healthMinEffectiveCooldownTicks = 20;
        public float healthRegenAmountPerConPoint = 0.05f;

        public float regenEffectHealingBonusMultiplier = 1.2f;

        // Innate Protection Regeneration
        public float innateProtectionAmountPerPulse = 0.2f;
        public int innateProtectionRegenCooldownTicks = 5;
        public int innateProtectionDelayAfterCombatTicks = 100;

        // Mana Regeneration
        public float manaRegenOutOfCombatBase = 0.05f;
        public float manaRegenInCombatBase = 0.015f;
        public float manaRegenBonusPerInt = 0.0f;
        public int manaDelayAfterCombatTicks = 40;

        // Vigor Regeneration
        public float vigorRegenOutOfCombatBase = 0.05f;
        public float vigorRegenInCombatBase = 0.015f;
        public float vigorRegenBonusPerDex = 0.0f;
        public int vigorDelayAfterCombatTicks = 40;

        // Specific regeneration settings for Mob Effects or Abilities
        public int protectionRegenSlowCooldownTicks = 60;
        public float protectionAmountPerSlowPulse = 1.0f;
        public float protectionRestoreAmountPerAbility = 5.0f;

        public int manaRegenCooldownTicksEffect = 40;
        public float manaAmountPerEffectPulse = 0.5f;

        public int vigorRegenCooldownTicksEffect = 30;
        public float vigorAmountPerEffectPulse = 0.75f;

        // Hunger Penalties
        public float hungryModerateVigorRegenPenalty = -0.15f;
        public float hungryIntenseVigorRegenPenalty = -0.40f;
        public float starvingVigorRegenPenalty = -0.40f;
        public int starvingDamageIntervalTicks = 80;
        public float starvingDamageAmount = 1.0f;

        // Passive Hunger Exhaustion
        public float hungryModeratePassiveExhaustionPerTick = 0.005f;
        public float hungryIntensePassiveExhaustionPerTick = 0.01f;
        public float starvingPassiveExhaustionPerTick = 0.02f;

        public RegenSettings() {}
    }

    /**
     * Groups all combat-related configurations.
     */
    public static class CombatSettings {
        public float damagePenetrationPercentage = 0.25f;
        public CombatSettings() {}
    }

    /**
     * Groups all XP-related configurations, including progression and rewards.
     */
    public static class XpSettings {
        public XpProgressionSettings xpProgression = new XpProgressionSettings();
        public Map<String, Integer> smeltingXpRewards = new HashMap<>();
        public float xpLossPercentageOnDeath = 0.10f;
        public float xpMaxDebtPercentage = 0.15f;
        public int defaultSmeltingXp = 0;

        public XpSettings() {}
    }

    /**
     * Configuration for a single achievement, including its XP reward and completion threshold.
     */
    public static class AchievementConfig {
        public int xpReward;
        public int threshold;

        public AchievementConfig(int xpReward, int threshold) {
            this.xpReward = xpReward;
            this.threshold = threshold;
        }

        public AchievementConfig() {}
    }

    // --- Utility Getters for Configuration Access ---

    /**
     * Groups all villager trading related configurations.
     */
    public static class VillagerTradeSettings {
        public int tradeFavorCooldownTicks; // Cooldown duration for favor gain from trading in ticks
        public int maxTradesBeforeCooldown; // Maximum trades a player can do within the cooldown period before no favor is gained
        public int defaultTradeXp; // Default XP awarded for a trade

        public VillagerTradeSettings() {}
    }

    /**
     * Gets the manual allocation limit for a given attribute.
     * @param attributeName The name of the attribute.
     * @return The maximum points a player can manually assign to that attribute.
     */
    public int getManualAttributeLimit(String attributeName) {
        return attributeSettings.manualAllocationLimit.getOrDefault(attributeName.toUpperCase(), 1);
    }

    // NEW: Getters for global attribute multipliers
    public float getConMultiplier() { return attributeSettings.conMultiplier; }
    public float getStrMultiplier() { return attributeSettings.strMultiplier; }
    public float getIntMultiplier() { return attributeSettings.intMultiplier; }
    public float getDexMultiplier() { return attributeSettings.dexMultiplier; }

    public float getRacialAffinityMultiplier() { return attributeSettings.racialAffinityMultiplier; }

    public float getInnateProtectionPerLevelIncrease() { return attributeSettings.innateProtectionPerLevelIncrease; }
    public int getBaseRegenPulseCooldownTicks() { return regenSettings.baseRegenPulseCooldownTicks; }
    public float getHealthRegenAmountPerConPoint() { return regenSettings.healthRegenAmountPerConPoint; }


    /**
     * Gets the generic stat configuration (Health, Mana, Vigor, or Protection) for a specific race.
     * MODIFIED: Now handles "PROTECTION" by returning ProtectionStatConfig,
     * extending StatConfigBase, and ensuring correct type casting.
     * @param raceName The name of the race.
     * @param statName The name of the stat (e.g., "HEALTH", "MANA", "VIGOR", "PROTECTION").
     * @return The appropriate StatConfigBase subclass for the specified stat and race, or a default.
     */
    public StatConfigBase getRaceStatConfig(String raceName, String statName) {
        RaceSettings raceSetting = raceSettings.get(raceName.toUpperCase());
        if (raceSetting == null) {
            BrokenPath.LOGGER.warn("Race configuration not found for: {}. Returning default config for {}.", raceName, statName);
            raceSetting = raceSettings.get("SPIRIT"); // Fallback to Spirit settings.
            if (raceSetting == null) {
                BrokenPath.LOGGER.error("SPIRIT race configuration is missing! Cannot provide fallback. Returning generic StatConfigBase.");
                return new StatConfigBase() {}; // Return a generic empty base if all else fails.
            }
        }

        // Return the specific stat config based on statName.
        switch (statName.toUpperCase()) {
            case "HEALTH": return Optional.ofNullable(raceSetting.health).orElseGet(HealthStatConfig::new);
            case "MANA": return Optional.ofNullable(raceSetting.mana).orElseGet(ManaStatConfig::new);
            case "VIGOR": return Optional.ofNullable(raceSetting.vigor).orElseGet(VigorStatConfig::new);
            case "PROTECTION": return Optional.ofNullable(raceSetting.protection).orElseGet(ProtectionStatConfig::new);
            default:
                BrokenPath.LOGGER.warn("Unknown stat name '{}' requested for race '{}'. Returning default StatConfigBase.", statName, raceName);
                return new StatConfigBase() {}; // Return a generic empty base.
        }
    }

    /**
     * Gets the Favor configuration for a specific race.
     * @param raceName The name of the race.
     * @return The {@link FavorConfig} for the specified race.
     */
    public FavorConfig getRaceFavorConfig(String raceName) {
        RaceSettings raceSetting = raceSettings.get(raceName.toUpperCase());
        if (raceSetting == null) {
            BrokenPath.LOGGER.warn("Race configuration not found for: {}. Returning default FavorConfig.", raceName);
            return new FavorConfig();
        }
        return Optional.ofNullable(raceSetting.favor).orElseGet(FavorConfig::new);
    }

    // NEW: Getter for class flat stat bonuses
    public float getClassStatBonus(String className, String statName) {
        return classStatBonuses.getOrDefault(className.toUpperCase(), Collections.emptyMap()).getOrDefault(statName.toUpperCase(), 0.0f);
    }

    // NEW: Getter for specialization flat stat bonuses
    public float getSpecializationStatBonus(String specializationName, String statName) {
        return specializationStatBonuses.getOrDefault(specializationName.toUpperCase(), Collections.emptyMap()).getOrDefault(statName.toUpperCase(), 0.0f);
    }

    // --- Regeneration Setting Getters ---
    public float getManaRegenOutOfCombatBase() { return regenSettings.manaRegenOutOfCombatBase; }
    public float getManaRegenInCombatBase() { return regenSettings.manaRegenInCombatBase; }
    public float getManaRegenBonusPerInt() { return regenSettings.manaRegenBonusPerInt; }
    public int getManaDelayAfterCombatTicks() { return regenSettings.manaDelayAfterCombatTicks; }

    public float getVigorRegenOutOfCombatBase() { return regenSettings.vigorRegenOutOfCombatBase; }
    public float getVigorRegenInCombatBase() { return regenSettings.vigorRegenInCombatBase; }
    public float getVigorRegenBonusPerDex() { return regenSettings.vigorRegenBonusPerDex; }
    public int getVigorDelayAfterCombatTicks() { return regenSettings.vigorDelayAfterCombatTicks; }

    public float getHealthAmountToHealPerPulse() { return regenSettings.healthAmountToHealPerPulse; }
    public float getHealthExhaustionCostPerHealPulse() { return regenSettings.healthExhaustionCostPerHealPulse; }
    public int getHealthMinFoodLevelForRegen() { return regenSettings.healthMinFoodLevelForRegen; }
    public int getHealthDelayAfterCombatTicks() { return regenSettings.healthDelayAfterCombatTicks; }
    public int getHealthMinEffectiveCooldownTicks() { return regenSettings.healthMinEffectiveCooldownTicks; }
    public float getHealthRegenBonusPerConTicks() { return regenSettings.healthRegenAmountPerConPoint; }

    public float getRegenEffectHealingBonusMultiplier() { return regenSettings.regenEffectHealingBonusMultiplier; }

    // Innate Protection Regeneration Getters
    public float getInnateProtectionAmountPerPulse() { return regenSettings.innateProtectionAmountPerPulse; }
    public int getInnateProtectionRegenCooldownTicks() { return regenSettings.innateProtectionRegenCooldownTicks; }
    public int getInnateProtectionDelayAfterCombatTicks() { return regenSettings.innateProtectionDelayAfterCombatTicks; }

    public int getProtectionRegenSlowCooldownTicks() { return regenSettings.protectionRegenSlowCooldownTicks; }
    public float getProtectionAmountPerSlowPulse() { return regenSettings.protectionAmountPerSlowPulse; }
    public float getProtectionRestoreAmountPerAbility() { return regenSettings.protectionRestoreAmountPerAbility; }

    public int getManaRegenCooldownTicksEffect() { return regenSettings.manaRegenCooldownTicksEffect; }
    public float getManaAmountPerEffectPulse() { return regenSettings.manaAmountPerEffectPulse; }

    public int getVigorRegenCooldownTicksEffect() { return regenSettings.vigorRegenCooldownTicksEffect; }
    public float getVigorAmountPerEffectPulse() { return regenSettings.vigorAmountPerEffectPulse; }

    // Hunger Penalties
    public float hungryModerateVigorRegenPenalty() { return regenSettings.hungryModerateVigorRegenPenalty; }
    public float hungryIntenseVigorRegenPenalty() { return regenSettings.hungryIntenseVigorRegenPenalty; }
    public float starvingVigorRegenPenalty() {return regenSettings.starvingVigorRegenPenalty;}
    public int getStarvingDamageIntervalTicks() { return regenSettings.starvingDamageIntervalTicks; }
    public float getStarvingDamageAmount() { return regenSettings.starvingDamageAmount; }

    // Passive Hunger Exhaustion
    public float hungryModeratePassiveExhaustionPerTick() { return regenSettings.hungryModeratePassiveExhaustionPerTick; }
    public float hungryIntensePassiveExhaustionPerTick() { return regenSettings.hungryIntensePassiveExhaustionPerTick; }
    public float starvingPassiveExhaustionPerTick() { return regenSettings.starvingPassiveExhaustionPerTick; }

    /**
     * Gets the achievement configuration for a specific achievement key.
     * @param achievementKey The key of the achievement.
     * @return The {@link AchievementConfig} for the specified achievement.
     */
    public AchievementConfig getAchievementConfig(String achievementKey) { return achievements.get(achievementKey.toUpperCase());}

    /**
     * Gets the maximum Favor bonus multiplier.
     */
    public float getFavorBonusMultiplier() { return maxFavorBonusMultiplier; }

    /**
     * Gets the damage penetration percentage for combat.
     */
    public float getDamagePenetrationPercentage() { return combatSettings.damagePenetrationPercentage; }

    /**
     * Gets the innate protection configuration (base and per-level scaling) for the specified race.
     * @param raceName The name of the race.
     * @return The {@link ProtectionInnateConfig} for the specified race.
     */
    public ModConfigs.ProtectionInnateConfig getRaceProtectionInnateConfig(String raceName) {
        RaceSettings raceSetting = raceSettings.get(raceName.toUpperCase());
        if (raceSetting == null) {
            BrokenPath.LOGGER.warn("Race configuration not found for: {}. Returning default ProtectionInnateConfig.", raceName);
            return new ProtectionInnateConfig();
        }
        return Optional.ofNullable(raceSetting.protectionInnate).orElseGet(ProtectionInnateConfig::new);
    }

    /**
     * Gets the villager trade settings.
     */
    public VillagerTradeSettings getVillagerTradeSettings() { return villagerTradeSettings; }
}