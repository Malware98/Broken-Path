package com.malware98.brokenpath.data;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;
import com.malware98.brokenpath.BrokenPath;
import net.minecraftforge.fml.loading.FMLPaths;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Path;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Main configuration class for the "BrokenPath" mod.
 * Manages all configurable variables related to player stats, races, classes,
 * XP progression, regeneration, penalties, and achievements.
 * Provides functionality to load and save these configurations from/to a JSON file.
 * This class implements the Singleton pattern to ensure a single, consistent
 * source of truth for all mod configurations.
 */
public class ModConfigs {

    // --- Configuration Constants ---
    // Singleton instance of ModConfigs, ensuring only one configuration object exists.
    private static ModConfigs INSTANCE;
    // Gson object configured for pretty-printed JSON serialization/deserialization,
    // making the config file human-readable.
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    // Name of the primary configuration file located in the Forge config directory.
    private static final String CONFIG_FILE_NAME = "brokenpath_configs.json";
    // Full path to the configuration file, resolved within Forge's standard config directory.
    private static final Path CONFIG_PATH = FMLPaths.CONFIGDIR.get().resolve(CONFIG_FILE_NAME);

    // Maximum player level attainable in the mod's progression system.
    public static final int MAX_LEVEL = 50;

    // Maximum multiplier for the Favor bonus system, capping how much Favor can amplify effects.
    public float maxFavorBonusMultiplier = 2.0f;

    // --- Configuration Variables Grouped by Category ---
    // Contains all settings related to health, mana, vigor, and protection regeneration mechanics.
    public RegenSettings regenSettings;
    // Holds configurations for combat-specific mechanics, such as damage penetration rules.
    public CombatSettings combatSettings;
    // Defines rules for experience point (XP) progression and rewards from smelting.
    public XpSettings xpSettings;
    // A map of achievement identifiers to their respective configurations,
    // including XP rewards and completion thresholds.
    public Map<String, AchievementConfig> achievements;

    // Core attribute system settings, including manual point allocation limits.
    public AttributeSettings attributeSettings;
    // Defines base stat configurations for each playable race, such as initial health or mana.
    public Map<String, RaceSettings> raceSettings;
    // Specifies class affinities: which stats a class gains a bonus for when combined with certain races.
    public Map<String, Map<String, List<String>>> classAffinities;
    // Flat numerical bonuses applied to specific stats based on the player's chosen class.
    public Map<String, Map<String, Float>> classStatBonuses;
    // Flat numerical bonuses applied to specific stats based on the player's chosen specialization.
    public Map<String, Map<String, Float>> specializationStatBonuses;
    // Defines how many attribute points a player receives when reaching levels within specific ranges.
    public Map<String, Integer> levelProgression;
    // Modifiers that adjust the player's "Favor" score based on specific in-game actions (e.g., taming, trading, killing).
    public Map<String, Float> favorActionModifiers;

    // Settings specifically for villager trading interactions, including cooldowns and XP.
    public VillagerTradeSettings villagerTradeSettings;


    // --- Constructor and Singleton Pattern ---
    /**
     * Private constructor to enforce the Singleton pattern.
     * Initializes all configuration values with their default settings. This ensures that
     * even if the JSON configuration file is missing, empty, or malformed, the mod
     * operates with a valid and functional set of default configurations.
     */
    private ModConfigs() {
        initializeDefaults();
    }

    /**
     * Provides the single instance of {@link ModConfigs}.
     * Implements the Singleton pattern to ensure a consistent and unique configuration
     * object is used throughout the mod's lifecycle. If no instance exists, a new one is created.
     * @return The singleton instance of ModConfigs.
     */
    public static ModConfigs getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new ModConfigs();
        }
        return INSTANCE;
    }

    // --- Default Initialization Logic ---
    /**
     * Initializes all configuration values with their default settings.
     * This method is called during the initial creation of the ModConfigs instance,
     * ensuring a robust baseline configuration even if no external file is loaded or is invalid.
     */
    private void initializeDefaults() {
        // Initialize maps and nested configuration objects to prevent NullPointerExceptions
        // if corresponding sections are missing or malformed in the JSON file.
        attributeSettings = new AttributeSettings();
        raceSettings = new HashMap<>();
        classAffinities = new HashMap<>();
        classStatBonuses = new HashMap<>();
        specializationStatBonuses = new HashMap<>();
        levelProgression = new HashMap<>();
        favorActionModifiers = new HashMap<>();
        achievements = new HashMap<>();

        regenSettings = new RegenSettings();
        combatSettings = new CombatSettings();
        xpSettings = new XpSettings();
        villagerTradeSettings = new VillagerTradeSettings();

        // --- Default Attribute Allocation Limits ---
        attributeSettings = new AttributeSettings(); // Re-initialize to ensure fresh defaults
        attributeSettings.manualAllocationLimit.put("CONSTITUTION", 70);
        attributeSettings.manualAllocationLimit.put("STRENGTH", 70);
        attributeSettings.manualAllocationLimit.put("DEXTERITY", 70);
        attributeSettings.manualAllocationLimit.put("INTELLIGENCE", 70);

        // Global multipliers for attribute points to stats, defining how much each point contributes.
        attributeSettings.conMultiplier = 2.0f; // 1 Health per CON point
        attributeSettings.strMultiplier = 2.0f; // 1 Protection per STR point (efficacy)
        attributeSettings.intMultiplier = 2.0f; // 1 Mana per INT point
        attributeSettings.dexMultiplier = 2.0f; // 1 Vigor per DEX point

        // Global racial affinity multiplier: a bonus applied if a race is affine to a class/stat.
        attributeSettings.racialAffinityMultiplier = 1.2f; // Example: 20% bonus if race is affine to class

        // Global Innate Protection per level increase, defining passive damage reduction scaling.
        attributeSettings.innateProtectionPerLevelIncrease = 0.2f; // 0.2 innate protection per player level (beyond level 1)

        // --- Default XP Progression Settings ---
        xpSettings.xpProgression.baseXp = 100.0f;
        xpSettings.xpProgression.linearXpCoefficient = 50.0f;
        xpSettings.xpProgression.polynomialXpCoefficient = 1.2f;
        xpSettings.xpProgression.polynomialXpExponent = 2.5f;
        xpSettings.xpProgression.minXpPerLevel = 100;

        // --- Initial Race Stat Configurations ---
        // Defines the base stats for each playable race. These are only initial values;
        // attributes and affinities will apply additional multipliers and bonuses later.

        RaceSettings spiritSettings = new RaceSettings();
        spiritSettings.health = createStatConfig(20.0f, HealthStatConfig.class);
        spiritSettings.protection = createStatConfig(0.0f, ProtectionStatConfig.class);
        spiritSettings.protectionInnate = createProtectionInnateConfig(0.0f);
        spiritSettings.mana = createStatConfig(0.0f, ManaStatConfig.class);
        spiritSettings.vigor = createStatConfig(0.0f, VigorStatConfig.class);
        spiritSettings.favor = new FavorConfig(50.0f, 200.0f, 0.0f);
        raceSettings.put("SPIRIT", spiritSettings);

        RaceSettings humanSettings = new RaceSettings();
        humanSettings.health = createStatConfig(20.0f, HealthStatConfig.class);
        humanSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        humanSettings.protectionInnate = createProtectionInnateConfig(0.0f);
        humanSettings.mana = createStatConfig(20.0f, ManaStatConfig.class);
        humanSettings.vigor = createStatConfig(20.0f, VigorStatConfig.class);
        humanSettings.favor = new FavorConfig(70.0f, 200.0f, 0.0f);
        raceSettings.put("HUMAN", humanSettings);

        RaceSettings elfSettings = new RaceSettings();
        elfSettings.health = createStatConfig(14.0f, HealthStatConfig.class);
        elfSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        elfSettings.protectionInnate = createProtectionInnateConfig(0.0f);
        elfSettings.mana = createStatConfig(40.0f, ManaStatConfig.class);
        elfSettings.vigor = createStatConfig(20.0f, VigorStatConfig.class);
        elfSettings.favor = new FavorConfig(0.0f, 200.0f, 0.0f);
        raceSettings.put("ELF", elfSettings);

        RaceSettings orcSettings = new RaceSettings();
        orcSettings.health = createStatConfig(30.0f, HealthStatConfig.class);
        orcSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        orcSettings.protectionInnate = createProtectionInnateConfig(0.0f);
        orcSettings.mana = createStatConfig(0.0f, ManaStatConfig.class);
        orcSettings.vigor = createStatConfig(40.0f, VigorStatConfig.class);
        orcSettings.favor = new FavorConfig(50.0f, 200.0f, 0.0f);
        raceSettings.put("ORC", orcSettings);

        RaceSettings draconidSettings = new RaceSettings();
        draconidSettings.health = createStatConfig(16.0f, HealthStatConfig.class);
        draconidSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        draconidSettings.protectionInnate = createProtectionInnateConfig(10.0f);
        draconidSettings.mana = createStatConfig(30.0f, ManaStatConfig.class);
        draconidSettings.vigor = createStatConfig(20.0f, VigorStatConfig.class);
        draconidSettings.favor = new FavorConfig(20.0f, 200.0f, 0.0f);
        raceSettings.put("DRACONID", draconidSettings);

        RaceSettings chimeraAgileSettings = new RaceSettings();
        chimeraAgileSettings.health = createStatConfig(16.0f, HealthStatConfig.class);
        chimeraAgileSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        chimeraAgileSettings.protectionInnate = createProtectionInnateConfig(10.0f);
        chimeraAgileSettings.mana = createStatConfig(20.0f, ManaStatConfig.class);
        chimeraAgileSettings.vigor = createStatConfig(20.0f, VigorStatConfig.class);
        chimeraAgileSettings.favor = new FavorConfig(50.0f, 200.0f, 0.0f);
        raceSettings.put("CHIMERA_AGILE", chimeraAgileSettings);

        RaceSettings chimeraDefensiveSettings = new RaceSettings();
        chimeraDefensiveSettings.health = createStatConfig(20.0f, HealthStatConfig.class);
        chimeraDefensiveSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        chimeraDefensiveSettings.protectionInnate = createProtectionInnateConfig(10.0f);
        chimeraDefensiveSettings.mana = createStatConfig(20.0f, ManaStatConfig.class);
        chimeraDefensiveSettings.vigor = createStatConfig(20.0f, VigorStatConfig.class);
        chimeraDefensiveSettings.favor = new FavorConfig(50.0f, 200.0f, 0.0f);
        raceSettings.put("CHIMERA_DEFENSIVE", chimeraDefensiveSettings);

        RaceSettings tritonSettings = new RaceSettings();
        tritonSettings.health = createStatConfig(18.0f, HealthStatConfig.class);
        tritonSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        tritonSettings.protectionInnate = createProtectionInnateConfig(10.0f);
        tritonSettings.mana = createStatConfig(20.0f, ManaStatConfig.class);
        tritonSettings.vigor = createStatConfig(20.0f, VigorStatConfig.class);
        tritonSettings.favor = new FavorConfig(80.0f, 200.0f, 0.0f);
        raceSettings.put("TRITON", tritonSettings);

        RaceSettings aasimarSettings = new RaceSettings();
        aasimarSettings.health = createStatConfig(16.0f, HealthStatConfig.class);
        aasimarSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        aasimarSettings.protectionInnate = createProtectionInnateConfig(10.0f);
        aasimarSettings.mana = createStatConfig(20.0f, ManaStatConfig.class);
        aasimarSettings.vigor = createStatConfig(20.0f, VigorStatConfig.class);
        aasimarSettings.favor = new FavorConfig(100.0f, 200.0f, 0.0f);
        raceSettings.put("AASIMAR", aasimarSettings);

        RaceSettings androidSettings = new RaceSettings();
        androidSettings.health = createStatConfig(10.0f, HealthStatConfig.class);
        androidSettings.protection = createStatConfig(10.0f, ProtectionStatConfig.class);
        androidSettings.protectionInnate = createProtectionInnateConfig(20.0f);
        androidSettings.mana = createStatConfig(0.0f, ManaStatConfig.class);
        androidSettings.vigor = createStatConfig(40.0f, VigorStatConfig.class);
        androidSettings.favor = new FavorConfig(80.0f, 200.0f, 0.0f);
        raceSettings.put("ANDROID", androidSettings);

        // --- Class Affinities ---
        // Defines which race-class combinations gain a racial affinity bonus for specific stats.
        classAffinities.put("CHAMPION", Map.of("HEALTH", List.of("HUMAN"), "PROTECTION", List.of("HUMAN")));
        classAffinities.put("SORCERER", Map.of("MANA", List.of("ELF"), "PROTECTION", List.of("ELF")));
        classAffinities.put("BERSERKER", Map.of("HEALTH", List.of("ORC"), "VIGOR", List.of("ORC")));
        classAffinities.put("SHAMAN", Map.of("MANA", List.of("DRACONID"), "VIGOR", List.of("DRACONID")));
        classAffinities.put("EXPLORER", Map.of("VIGOR", List.of("CHIMERA_AGILE"), "PROTECTION", List.of("CHIMERA_AGILE")));
        classAffinities.put("CHANNELER", Map.of("MANA", List.of("TRITON"), "HEALTH", List.of("TRITON")));
        classAffinities.put("VESTAL", Map.of("PROTECTION", List.of("AASIMAR"), "MANA", List.of("AASIMAR")));
        classAffinities.put("TECHNOMANCER", Map.of("PROTECTION", List.of("ANDROID"), "VIGOR", List.of("ANDROID")));
        classAffinities.put("NO_CLASS", Map.of(
                "HEALTH", Collections.emptyList(),
                "MANA", Collections.emptyList(),
                "VIGOR", Collections.emptyList(),
                "PROTECTION", Collections.emptyList()
        ));

        // --- Class Flat Stat Bonuses ---
        // Defines fixed numerical bonuses applied to stats based on the player's class.
        classStatBonuses.put("CHAMPION", Map.of("HEALTH", 5.0f));
        classStatBonuses.put("SORCERER", Map.of("MANA", 5.0f));
        classStatBonuses.put("BERSERKER", Map.of("VIGOR", 5.0f));
        classStatBonuses.put("SHAMAN", Map.of("MANA", 5.0f));
        classStatBonuses.put("EXPLORER", Map.of("VIGOR", 5.0f));
        classStatBonuses.put("CHANNELER", Map.of("HEALTH", 5.0f));
        classStatBonuses.put("VESTAL", Map.of("PROTECTION", 5.0f));
        classStatBonuses.put("TECHNOMANCER", Map.of("PROTECTION", 5.0f));
        classStatBonuses.put("NO_CLASS", Collections.emptyMap());

        // --- Specialization Flat Stat Bonuses ---
        // Defines fixed numerical bonuses applied to stats based on the player's specialization.
        specializationStatBonuses.put("NO_SPECIALIZATION", Collections.emptyMap()); // Placeholder for no specialization
        // Example for a specific specialization (you'll need to define yours)
        // specializationStatBonuses.put("SWORD_MASTER", Map.of("PROTECTION", 3.0f));


        // --- Attribute Point Allocation per Level Progression ---
        // Defines how many attribute points are granted at specific level ranges.
        levelProgression.put("1-1", 0);
        levelProgression.put("2-10", 1);
        levelProgression.put("11-20", 2);
        levelProgression.put("21-30", 3);
        levelProgression.put("31-40", 4);
        levelProgression.put("41-49", 5);
        levelProgression.put("50-50", 6);

        // --- Favor Action Modifiers ---
        // Defines how much player Favor changes based on various in-game actions.
        favorActionModifiers.put("TAME_WOLF", 1.5f);
        favorActionModifiers.put("TAME_CAT", 1.5f);
        favorActionModifiers.put("TAME_HORSE", 1.5f);
        favorActionModifiers.put("TAME_DONKEY", 1.5f);
        favorActionModifiers.put("TAME_MULE", 1.5f);
        favorActionModifiers.put("TAME_LLAMA", 1.5f);
        favorActionModifiers.put("FEED_CHICKEN", 1.0f);
        favorActionModifiers.put("FEED_COW", 1.0f);
        favorActionModifiers.put("FEED_PIG", 1.0f);
        favorActionModifiers.put("FEED_SHEEP", 1.0f);
        favorActionModifiers.put("FEED_PARROT", 1.0f);
        favorActionModifiers.put("FEED_PANDA", 1.0f);
        favorActionModifiers.put("FEED_FOX", 1.0f);

        favorActionModifiers.put("KILL_WOLF", -2.5f);
        favorActionModifiers.put("KILL_CAT", -2.5f);
        favorActionModifiers.put("KILL_HORSE", -2.5f);
        favorActionModifiers.put("KILL_DONKEY", -2.5f);
        favorActionModifiers.put("KILL_MULE", -2.5f);
        favorActionModifiers.put("KILL_LLAMA", -2.5f);
        favorActionModifiers.put("KILL_PARROT", -2.5f);
        favorActionModifiers.put("KILL_PANDA", -2.5f);
        favorActionModifiers.put("KILL_FOX", -2.5f);

        favorActionModifiers.put("TRADE_FARMER", 0.75f);
        favorActionModifiers.put("TRADE_FISHERMAN", 0.75f);
        favorActionModifiers.put("TRADE_SHEPHERD", 0.75f);
        favorActionModifiers.put("TRADE_LEATHERWORKER", 0.75f);
        favorActionModifiers.put("TRADE_MASON", 0.75f);

        favorActionModifiers.put("TRADE_CARTOGRAPHER", 1.0f);
        favorActionModifiers.put("TRADE_FLETCHER", 1.0f);
        favorActionModifiers.put("TRADE_BUTCHER", 1.0f);
        favorActionModifiers.put("TRADE_TOOLSMITH", 1.25f);
        favorActionModifiers.put("TRADE_WEAPONSMITH", 1.25f);

        favorActionModifiers.put("TRADE_LIBRARIAN", 1.75f);
        favorActionModifiers.put("TRADE_CLERIC", 1.75f);
        favorActionModifiers.put("TRADE_ARMORER", 1.75f);
        favorActionModifiers.put("DEFEND_RAID", 15.0f);

        favorActionModifiers.put("TRADE_VILLAGER", 0.5f);

        favorActionModifiers.put("ATTACK_VILLAGER", -1.5f);
        favorActionModifiers.put("ATTACK_FARMER", -2.0f);
        favorActionModifiers.put("ATTACK_FISHERMAN", -2.0f);
        favorActionModifiers.put("ATTACK_SHEPHERD", -2.0f);
        favorActionModifiers.put("ATTACK_LEATHERWORKER", -2.0f);
        favorActionModifiers.put("ATTACK_MASON", -2.0f);
        favorActionModifiers.put("ATTACK_CARTOGRAPHER", -2.5f);
        favorActionModifiers.put("ATTACK_FLETCHER", -2.5f);
        favorActionModifiers.put("ATTACK_BUTCHER", -2.5f);
        favorActionModifiers.put("ATTACK_TOOLSMITH", -3.0f);
        favorActionModifiers.put("ATTACK_WEAPONSMITH", -3.0f);
        favorActionModifiers.put("ATTACK_ARMORER", -3.0f);
        favorActionModifiers.put("ATTACK_LIBRARIAN", -3.5f);
        favorActionModifiers.put("ATTACK_CLERIC", -4.0f);
        favorActionModifiers.put("KILL_VILLAGER", -7.5f);
        favorActionModifiers.put("DESTROY_VILLAGE_BLOCK", -2.5f);

        favorActionModifiers.put("REPAIR_GOLEM", 0.5f);

        favorActionModifiers.put("DAMAGE_GOLEM", -1.0f);
        favorActionModifiers.put("SHEAR_SNOW_GOLEM_PUMPKIN", -2.5f);
        favorActionModifiers.put("KILL_GOLEM", -5.0f);

        // --- Smelting XP Rewards ---
        // Defines the experience points awarded for smelting specific items.
        xpSettings.smeltingXpRewards.put("minecraft:iron_ingot", 2);
        xpSettings.smeltingXpRewards.put("minecraft:gold_ingot", 3);
        xpSettings.smeltingXpRewards.put("minecraft:copper_ingot", 1);
        xpSettings.smeltingXpRewards.put("minecraft:cooked_beef", 1);
        xpSettings.smeltingXpRewards.put("minecraft:charcoal", 1);
        xpSettings.smeltingXpRewards.put("minecraft:lapis_lazuli", 2);
        xpSettings.smeltingXpRewards.put("minecraft:redstone", 2);
        xpSettings.smeltingXpRewards.put("minecraft:emerald", 2);
        xpSettings.smeltingXpRewards.put("minecraft:diamond", 4);
        xpSettings.smeltingXpRewards.put("minecraft:coal", 1);
        xpSettings.smeltingXpRewards.put("minecraft:quartz", 2);
        xpSettings.smeltingXpRewards.put("minecraft:netherite_scrap", 10);
        xpSettings.smeltingXpRewards.put("minecraft:cooked_porkchop", 1);
        xpSettings.smeltingXpRewards.put("minecraft:cooked_chicken", 1);
        xpSettings.smeltingXpRewards.put("minecraft:cooked_mutton", 1);
        xpSettings.smeltingXpRewards.put("minecraft:cooked_rabbit", 1);
        xpSettings.smeltingXpRewards.put("minecraft:cooked_fish", 1);
        xpSettings.smeltingXpRewards.put("minecraft:cooked_salmon", 1);
        xpSettings.smeltingXpRewards.put("minecraft:baked_potato", 1);
        xpSettings.smeltingXpRewards.put("minecraft:dried_kelp", 1);
        xpSettings.smeltingXpRewards.put("minecraft:stone", 1);
        xpSettings.smeltingXpRewards.put("minecraft:smooth_stone", 1);
        xpSettings.smeltingXpRewards.put("minecraft:brick", 1);
        xpSettings.smeltingXpRewards.put("minecraft:nether_brick", 1);
        xpSettings.smeltingXpRewards.put("minecraft:green_dye", 1);
        xpSettings.smeltingXpRewards.put("minecraft:sponge", 1);
        xpSettings.smeltingXpRewards.put("minecraft:glass", 1);

        // Percentage of XP lost upon player death.
        xpSettings.xpLossPercentageOnDeath = 0.10f;
        // Maximum percentage of XP debt a player can accumulate.
        xpSettings.xpMaxDebtPercentage = 0.15f;
        // Default XP awarded if a specific smelting recipe isn't listed.
        xpSettings.defaultSmeltingXp = 1;

        // --- Villager Trade Settings ---
        villagerTradeSettings.tradeFavorCooldownTicks = 20 * 60 * 5; // 5 minutes in ticks
        villagerTradeSettings.maxTradesBeforeCooldown = 10;
        villagerTradeSettings.defaultTradeXp = 5;

        // --- Achievement Configurations ---
        // Defines experience point rewards and completion thresholds for various achievements.
        achievements.put("EXPLORATION_ROOT", new AchievementConfig(20, 1));
        achievements.put("EXPLORER_NOVICE", new AchievementConfig(10, 5));
        achievements.put("LOCAL_ADVENTURER", new AchievementConfig(50, 10));
        achievements.put("ACCOMPLISHED_CARTOGRAPHER", new AchievementConfig(100, 15));
        achievements.put("UNKNOWN_PIONEER", new AchievementConfig(200, 1));

        achievements.put("FLEDGLING_ADVOCATE", new AchievementConfig(40, 10));
        achievements.put("CREATURE_HUNTER", new AchievementConfig(90, 50));
        achievements.put("THREATS_EXTERMINATOR", new AchievementConfig(300, 200));
        achievements.put("SHADOWS_TERROR", new AchievementConfig(600, 500));
        achievements.put("MASACRE_MASTER", new AchievementConfig(1000, 1000));

        achievements.put("ROCK_FINDER", new AchievementConfig(10, 64));
        achievements.put("AMATEUR_EXCAVATOR", new AchievementConfig(60, 100));
        achievements.put("SKILLED_MINERALOGIST", new AchievementConfig(180, 500));
        achievements.put("GEOLOGIST_EXPERT", new AchievementConfig(350, 1000));
        achievements.put("MINING_MASTER", new AchievementConfig(700, 2500));
        achievements.put("HIDDEN_TREASURE", new AchievementConfig(250, 50));
        achievements.put("MASTER_OBSIDIAN", new AchievementConfig(150, 20));

        achievements.put("NOVICE_SOWER", new AchievementConfig(30, 50));
        achievements.put("DEDICATED_FARMER", new AchievementConfig(80, 200));
        achievements.put("ACCOMPLISHED_AGRONOMIST", new AchievementConfig(180, 500));
        achievements.put("HARVEST_POWER", new AchievementConfig(350, 1000));
        achievements.put("BEAST_TAMER", new AchievementConfig(100, 3));
        achievements.put("TIRELESS_SHEPHERD", new AchievementConfig(200, 10));
        achievements.put("SUCCESSFUL_BREEDER", new AchievementConfig(150, 20));

        achievements.put("NOVICE_CRAFTER", new AchievementConfig(20, 25));
        achievements.put("CREATIVE_CRAFTER", new AchievementConfig(50, 50));
        achievements.put("ARTISAN_APPRENTICE", new AchievementConfig(100, 100));
        achievements.put("MASTER_CRAFTSMAN", new AchievementConfig(250, 150));
        achievements.put("ART_KITCHEN", new AchievementConfig(70, 50));
        achievements.put("TIRELESS_FURNACE", new AchievementConfig(160, 200));

        achievements.put("FIRST_STEPS", new AchievementConfig(10, 100));
        achievements.put("CONSTANT_WALKER", new AchievementConfig(100, 1000));
        achievements.put("TIRELESS_TRAVELER", new AchievementConfig(250, 5000));
        achievements.put("HUNGER_RESISTANT", new AchievementConfig(180, 1));
        achievements.put("A_WHOLE_DAY", new AchievementConfig(50, 1));
        achievements.put("ONE_WEEK_WORLD", new AchievementConfig(200, 7));
        achievements.put("IM_STILL_ALIVE", new AchievementConfig(800, 30));
        achievements.put("SURVIVAL_ROOT", new AchievementConfig(10, 1));

        regenSettings.baseHungerConsumptionPerHealthRegenPulse = 0.5f;
        regenSettings.hungerConsumptionPerConPointScaling = 0.05f;
        regenSettings.maxHungerConsumptionPerPulse = 3.0f;

    }

    // --- Helper Methods for Configuration Creation ---
    /**
     * Generic method to create an instance of {@link StatConfigBase} or its subclass.
     * This simplifies the creation of stat configuration objects in the default
     * initialization, ensuring consistency and readability.
     * @param baseInitialValue The base initial value for the statistic.
     * @param clazz The class type of the StatConfig to create (e.g., HealthStatConfig.class).
     * @param <T> The type of StatConfigBase being created.
     * @return A new instance of the specified StatConfig subclass with the base initial value set.
     */
    private <T extends StatConfigBase> T createStatConfig(float baseInitialValue, Class<T> clazz) {
        try {
            T config = clazz.getDeclaredConstructor().newInstance();
            config.baseInitialValue = baseInitialValue;
            return config;
        } catch (Exception e) {
            BrokenPath.LOGGER.error("Failed to create StatConfig of type {}. Error: {}", clazz.getName(), e.getMessage());
            // Fallback to a generic StatConfigBase to prevent null if instantiation fails.
            StatConfigBase fallback = new StatConfigBase() {};
            fallback.baseInitialValue = baseInitialValue;
            return (T) fallback; // This cast is safe if default constructor is always called as fallback
        }
    }

    /**
     * Configures the scaling for Innate Protection.
     * @param baseValue The base innate protection value.
     * @return A new {@link ProtectionInnateConfig} instance initialized with the base value.
     */
    private ProtectionInnateConfig createProtectionInnateConfig(float baseValue) {
        return new ProtectionInnateConfig(baseValue);
    }

    // --- Configuration Loading and Saving ---

    /**
     * Loads the mod's configuration from the JSON file located at {@link #CONFIG_PATH}.
     * If the file does not exist, is empty, or is malformed, it logs a warning/error,
     * initializes a new instance with default values, and saves this default configuration.
     * This robust approach ensures the mod always has a valid configuration to operate with.
     */
    public static void loadConfig() {
        File configFile = CONFIG_PATH.toFile();

        if (configFile.exists()) {
            try (FileReader reader = new FileReader(configFile)) {
                INSTANCE = GSON.fromJson(reader, ModConfigs.class);
                if (INSTANCE == null) {
                    BrokenPath.LOGGER.warn("Configuration file '{}' was empty or invalid JSON. Loading default configurations.", CONFIG_FILE_NAME);
                    INSTANCE = new ModConfigs(); // Fallback to defaults if JSON is empty/invalid.
                }
            } catch (JsonSyntaxException e) {
                BrokenPath.LOGGER.error("Error parsing configuration file '{}'. Please check JSON syntax. Loading default configurations. Error: {}", CONFIG_FILE_NAME, e.getMessage());
                INSTANCE = new ModConfigs(); // Fallback on JSON syntax errors.
            } catch (IOException e) {
                BrokenPath.LOGGER.error("Failed to read configuration file '{}'. Loading default configurations. Error: {}", CONFIG_FILE_NAME, e.getMessage());
                INSTANCE = new ModConfigs(); // Fallback on I/O errors.
            }
        } else {
            BrokenPath.LOGGER.info("Configuration file '{}' not found. Creating with default configurations.", CONFIG_FILE_NAME);
            INSTANCE = new ModConfigs(); // Create new instance with defaults.
            saveConfig(); // Save the newly generated default configuration.
        }

        // --- Post-Load Safety Net ---
        // This section ensures that all internal maps and objects are properly initialized
        // with default values if Gson couldn't load them (e.g., if a section was missing
        // in an older or incomplete config file). This is an additional layer of robustness
        // against incomplete or outdated configuration files, preventing NullPointerExceptions.
        INSTANCE.attributeSettings = Optional.ofNullable(INSTANCE.attributeSettings).orElseGet(AttributeSettings::new);
        INSTANCE.attributeSettings.manualAllocationLimit = Optional.ofNullable(INSTANCE.attributeSettings.manualAllocationLimit).orElseGet(HashMap::new);
        // Ensure global attribute multipliers and affinity multiplier are initialized to prevent zero values.
        if (INSTANCE.attributeSettings.conMultiplier == 0.0f) INSTANCE.attributeSettings.conMultiplier = 2.0f;
        if (INSTANCE.attributeSettings.strMultiplier == 0.0f) INSTANCE.attributeSettings.strMultiplier = 2.0f;
        if (INSTANCE.attributeSettings.intMultiplier == 0.0f) INSTANCE.attributeSettings.intMultiplier = 2.0f;
        if (INSTANCE.attributeSettings.dexMultiplier == 0.0f) INSTANCE.attributeSettings.dexMultiplier = 2.0f;
        if (INSTANCE.attributeSettings.racialAffinityMultiplier == 0.0f) INSTANCE.attributeSettings.racialAffinityMultiplier = 1.2f;
        // Ensure global innate protection per level increase is initialized.
        if (INSTANCE.attributeSettings.innateProtectionPerLevelIncrease == 0.0f) INSTANCE.attributeSettings.innateProtectionPerLevelIncrease = 0.2f;


        INSTANCE.raceSettings = Optional.ofNullable(INSTANCE.raceSettings).orElseGet(HashMap::new);
        // Iterate through existing race settings to ensure all nested stat configurations are present.
        for (Map.Entry<String, RaceSettings> entry : INSTANCE.raceSettings.entrySet()) {
            RaceSettings rs = entry.getValue();
            rs.health = Optional.ofNullable(rs.health).orElseGet(HealthStatConfig::new);
            rs.mana = Optional.ofNullable(rs.mana).orElseGet(ManaStatConfig::new);
            rs.vigor = Optional.ofNullable(rs.vigor).orElseGet(VigorStatConfig::new);
            rs.protection = Optional.ofNullable(rs.protection).orElseGet(ProtectionStatConfig::new);
            rs.protectionInnate = Optional.ofNullable(rs.protectionInnate).orElseGet(ProtectionInnateConfig::new);
            rs.favor = Optional.ofNullable(rs.favor).orElseGet(FavorConfig::new);
        }

        INSTANCE.classAffinities = Optional.ofNullable(INSTANCE.classAffinities).orElseGet(HashMap::new);
        INSTANCE.classStatBonuses = Optional.ofNullable(INSTANCE.classStatBonuses).orElseGet(HashMap::new);
        INSTANCE.specializationStatBonuses = Optional.ofNullable(INSTANCE.specializationStatBonuses).orElseGet(HashMap::new);
        INSTANCE.levelProgression = Optional.ofNullable(INSTANCE.levelProgression).orElseGet(HashMap::new);
        INSTANCE.favorActionModifiers = Optional.ofNullable(INSTANCE.favorActionModifiers).orElseGet(HashMap::new);
        INSTANCE.achievements = Optional.ofNullable(INSTANCE.achievements).orElseGet(HashMap::new);

        INSTANCE.regenSettings = Optional.ofNullable(INSTANCE.regenSettings).orElseGet(RegenSettings::new);
        INSTANCE.combatSettings = Optional.ofNullable(INSTANCE.combatSettings).orElseGet(CombatSettings::new);
        INSTANCE.xpSettings = Optional.ofNullable(INSTANCE.xpSettings).orElseGet(XpSettings::new);
        INSTANCE.xpSettings.xpProgression = Optional.ofNullable(INSTANCE.xpSettings.xpProgression).orElseGet(XpProgressionSettings::new);
        INSTANCE.xpSettings.smeltingXpRewards = Optional.ofNullable(INSTANCE.xpSettings.smeltingXpRewards).orElseGet(HashMap::new);

        INSTANCE.villagerTradeSettings = Optional.ofNullable(INSTANCE.villagerTradeSettings).orElseGet(VillagerTradeSettings::new);
    }

    /**
     * Saves the current mod configuration to the JSON file specified by {@link #CONFIG_PATH}.
     * This allows users to persist their custom settings and ensures any changes made
     * during runtime can be written back to the disk.
     */
    public static void saveConfig() {
        File configFile = CONFIG_PATH.toFile();
        try (FileWriter writer = new FileWriter(configFile)) {
            GSON.toJson(INSTANCE, writer);
        } catch (IOException e) {
            BrokenPath.LOGGER.error("Failed to save configuration file '{}'. Error: {}", CONFIG_FILE_NAME, e.getMessage());
        }
    }

    // --- Configuration Logic Methods ---

    /**
     * Calculates the amount of XP required for the next player level based on a configurable formula.
     * The formula incorporates a base XP, linear scaling, and a polynomial component to ensure a smooth
     * and escalating progression.
     * @param currentLevel The player's current level.
     * @return The XP needed to reach the next level. Returns 0 if the player is already at the maximum level ({@link #MAX_LEVEL}).
     */
    public int getXPForNextLevel(int currentLevel) {
        if (currentLevel >= MAX_LEVEL) {
            return 0; // No more XP needed at max level.
        }

        final float A = xpSettings.xpProgression.baseXp;
        final float B = xpSettings.xpProgression.linearXpCoefficient;
        final float C = xpSettings.xpProgression.polynomialXpCoefficient;
        final float EXP = xpSettings.xpProgression.polynomialXpExponent;

        // Formula: XP_Needed = A + (B * Level) + (C * Level^EXP)
        double xpNeededDouble = A + (B * currentLevel) + (C * Math.pow(currentLevel, EXP));

        int xpNeeded = (int) Math.round(xpNeededDouble);

        // Ensure a minimum XP per level, especially at lower levels where the formula might yield low values.
        if (xpNeeded < xpSettings.xpProgression.minXpPerLevel) {
            xpNeeded = xpSettings.xpProgression.minXpPerLevel;
        }
        return xpNeeded;
    }

    /**
     * Checks if a specific class has a racial affinity with a given stat for a particular race.
     * Class affinities provide a bonus multiplier for certain statistics, encouraging specific
     * race-class combinations.
     * @param raceName The name of the race (e.g., "HUMAN", "ELF").
     * @param className The name of the class (e.g., "CHAMPION", "SORCERER").
     * @param statName The name of the stat (e.g., "HEALTH", "MANA", "PROTECTION", "VIGOR").
     * @return True if the class is affine to the stat for that race, false otherwise.
     */
    public boolean isClassAffinToStat(String raceName, String className, String statName) {
        // Retrieve the map of affinities for the given class, case-insensitively.
        Map<String, List<String>> affinitiesForClass = classAffinities.get(className.toUpperCase());
        if (affinitiesForClass == null) return false; // No affinities defined for this class.

        // Get the list of affine races for the specific stat, case-insensitively.
        List<String> affineRaces = affinitiesForClass.get(statName.toUpperCase());
        // Check if the list exists and if the given race is included in it.
        return affineRaces != null && affineRaces.contains(raceName.toUpperCase());
    }

    /**
     * Retrieves the number of fundamental attribute points granted to the player
     * for reaching a specific level, based on configured level ranges.
     * @param level The player's current level.
     * @return The number of attribute points awarded for that level range. Returns 0 if the level
     * does not fall into any defined range or if there's a parsing error.
     */
    public int getAttributePointsForLevelRange(int level) {
        for (Map.Entry<String, Integer> entry : levelProgression.entrySet()) {
            String[] range = entry.getKey().split("-");
            try {
                int min = Integer.parseInt(range[0]);
                int max = Integer.parseInt(range[1]);
                if (level >= min && level <= max) {
                    return entry.getValue();
                }
            } catch (NumberFormatException e) {
                BrokenPath.LOGGER.error("Error parsing level range in configuration: {}. Error: {}", entry.getKey(), e.getMessage());
            }
        }
        return 0; // No attribute points awarded for this level or range not found.
    }

    // --- Nested Classes for JSON Mapping ---

    /**
     * Configuration for manual attribute allocation limits and global attribute multipliers.
     * These settings determine how many points players can manually assign to attributes
     * and how efficiently those points convert into actual stats.
     */
    public static class AttributeSettings {
        public Map<String, Integer> manualAllocationLimit = new HashMap<>();
        public float conMultiplier;
        public float strMultiplier;
        public float intMultiplier;
        public float dexMultiplier;
        public float racialAffinityMultiplier;
        public float innateProtectionPerLevelIncrease;
        public AttributeSettings() {}
    }

    /**
     * Contains base stat configurations for each race.
     * This includes initial values for health, mana, vigor, protection, and favor.
     */
    public static class RaceSettings {
        public HealthStatConfig health;
        public ManaStatConfig mana;
        public VigorStatConfig vigor;
        public ProtectionStatConfig protection;
        public ProtectionInnateConfig protectionInnate;
        public FavorConfig favor;

        public RaceSettings() {
            // Initialize with default empty configs to prevent NullPointerExceptions
            // if a specific stat config is missing in the JSON.
            health = new HealthStatConfig();
            mana = new ManaStatConfig();
            vigor = new VigorStatConfig();
            protection = new ProtectionStatConfig();
            protectionInnate = new ProtectionInnateConfig();
            favor = new FavorConfig();
        }
    }

    /**
     * Base class for all specific stat configurations.
     * It provides a common field for the base initial value of a statistic.
     */
    public static abstract class StatConfigBase {
        public float baseInitialValue;
        public StatConfigBase() {}
    }

    /**
     * Specific configuration for the Health stat.
     * Inherits from {@link StatConfigBase} for its base initial value.
     */
    public static class HealthStatConfig extends StatConfigBase {
        public HealthStatConfig() {}
    }

    /**
     * Specific configuration for the Mana stat.
     * Inherits from {@link StatConfigBase} for its base initial value.
     */
    public static class ManaStatConfig extends StatConfigBase {
        public ManaStatConfig() {}
    }

    /**
     * Specific configuration for the Vigor stat.
     * Inherits from {@link StatConfigBase} for its base initial value.
     */
    public static class VigorStatConfig extends StatConfigBase {
        public VigorStatConfig() {}
    }

    /**
     * Specific configuration for the Protection stat.
     * Inherits from {@link StatConfigBase} for its base initial value.
     */
    public static class ProtectionStatConfig extends StatConfigBase {
        public ProtectionStatConfig() {}
        public ProtectionStatConfig(float baseInitialValue) {
            this.baseInitialValue = baseInitialValue;
        }
    }

    /**
     * Detailed configuration for the Favor system.
     * Defines the base favor value, and the minimum and maximum limits for favor.
     */
    public static class FavorConfig {
        public float baseFavor;
        public float maxLimit;
        public float minLimit;

        public FavorConfig() {
            this.baseFavor = 70f;
            this.maxLimit = 200.0f;
            this.minLimit = 0.0f;
        }

        public FavorConfig(float baseFavor, float maxLimit, float minLimit) {
            this.baseFavor = baseFavor;
            this.maxLimit = maxLimit;
            this.minLimit = minLimit;
        }
    }

    /**
     * Configuration settings for XP progression.
     * Includes coefficients for linear and polynomial scaling of XP requirements per level,
     * along with a minimum XP threshold.
     */
    public static class XpProgressionSettings {
        public float baseXp;
        public float linearXpCoefficient;
        public float polynomialXpCoefficient;
        public float polynomialXpExponent;
        public int minXpPerLevel;
        public XpProgressionSettings() {}
    }

    /**
     * Configuration for Innate Protection, defining its base value.
     * Innate Protection is a passive damage reduction that can scale with level.
     */
    public static class ProtectionInnateConfig {
        public float baseValue;
        public ProtectionInnateConfig(float baseValue) {
            this.baseValue = baseValue;
        }
        public ProtectionInnateConfig() {}
    }

    /**
     * Groups all regeneration-related configurations for health, mana, vigor, and protection.
     * Also includes settings for hunger penalties on regeneration and passive exhaustion.
     */
    public static class RegenSettings {

        // Common cooldown for regeneration pulses across different stats.
        public int baseRegenPulseCooldownTicks = 20;

        // Health Regeneration specific settings.
        public float healthAmountToHealPerPulse = 0.03f;
        public int healthMinFoodLevelForRegen = 12;
        public int healthDelayAfterCombatTicks = 100;
        public float healthRegenAmountPerConPoint = 0.05f;

        // Multiplier for healing bonuses from regeneration effects.
        public float regenEffectHealingBonusMultiplier = 1.2f;

        // Innate Protection Regeneration specific settings.
        public float innateProtectionAmountPerPulse = 0.2f;
        public int innateProtectionDelayAfterCombatTicks = 100;

        // Mana Regeneration specific settings.
        public float manaRegenOutOfCombatBase = 0.03f;
        public float manaRegenInCombatBase = 0.015f;
        public float manaRegenBonusPerInt = 0.05f;
        public int manaDelayAfterCombatTicks = 100;

        // Vigor Regeneration specific settings.
        public float vigorRegenOutOfCombatBase = 0.03f;
        public float vigorRegenInCombatBase = 0.015f;
        public float vigorRegenBonusPerDex = 0.05f;
        public int vigorDelayAfterCombatTicks = 100;

        // Specific regeneration settings influenced by Mob Effects or Player Abilities.
        public int protectionRegenSlowCooldownTicks = 60;
        public float protectionAmountPerSlowPulse = 1.0f;
        public float protectionRestoreAmountPerAbility = 5.0f; // For abilities that instantly restore protection.

        public float manaAmountPerEffectPulse = 0.5f; // Mana regenerated per pulse from effects.
        public float vigorAmountPerEffectPulse = 0.75f; // Vigor regenerated per pulse from effects.

        // Hunger Penalties on Regeneration.
        public float hungryModerateVigorRegenPenalty = -0.15f; // Penalty when food level is moderately low.
        public float hungryIntenseVigorRegenPenalty = -0.40f; // Penalty when food level is intensely low.
        public float starvingVigorRegenPenalty = -0.40f; // Penalty when starving.
        public int starvingDamageIntervalTicks = 80; // How often starving damage is applied.
        public float starvingDamageAmount = 1.0f; // Amount of damage taken when starving.

        // Hunger scalation with CON
        public float baseHungerConsumptionPerHealthRegenPulse = 1.0f;
        public float hungerConsumptionPerConPointScaling = 0.15f;
        public float maxHungerConsumptionPerPulse = 6.0f;

        // Passive Hunger Exhaustion.
        public float hungryModeratePassiveExhaustionPerTick = 0.005f;
        public float hungryIntensePassiveExhaustionPerTick = 0.01f;
        public float starvingPassiveExhaustionPerTick = 0.02f;

        public RegenSettings() {}
    }

    /**
     * Groups all combat-related configurations.
     * Currently, includes settings for damage penetration, which allows a percentage
     * of damage to bypass protection.
     */
    public static class CombatSettings {
        public float damagePenetrationPercentage = 0.25f; // Percentage of damage that ignores protection.
        public CombatSettings() {}
    }

    /**
     * Groups all experience point (XP) related configurations.
     * Includes XP progression settings, rewards from smelting, and death penalties.
     */
    public static class XpSettings {
        public XpProgressionSettings xpProgression = new XpProgressionSettings();
        public Map<String, Integer> smeltingXpRewards = new HashMap<>();
        public float xpLossPercentageOnDeath = 0.10f; // Percentage of current XP lost upon death.
        public float xpMaxDebtPercentage = 0.15f; // Maximum XP debt that can be accumulated.
        public int defaultSmeltingXp = 0; // Default XP for smelting if not specifically listed.

        public XpSettings() {}
    }

    /**
     * Configuration for a single achievement.
     * Defines the experience point reward granted upon completion and the numerical
     * threshold required to achieve it.
     */
    public static class AchievementConfig {
        public int xpReward; // XP awarded when the achievement is completed.
        public int threshold; // The numerical value required to trigger the achievement.

        public AchievementConfig(int xpReward, int threshold) {
            this.xpReward = xpReward;
            this.threshold = threshold;
        }

        public AchievementConfig() {}
    }

    /**
     * Groups all villager trading related configurations.
     * This includes cooldowns for favor gain from trading and default XP rewards.
     */
    public static class VillagerTradeSettings {
        public int tradeFavorCooldownTicks; // Cooldown duration for favor gain from trading in ticks.
        public int maxTradesBeforeCooldown; // Maximum trades a player can do within the cooldown period before no favor is gained.
        public int defaultTradeXp; // Default XP awarded for a trade.

        public VillagerTradeSettings() {}
    }

    // --- Utility Getters for Configuration Access ---

    // Attribute Multipliers and Limits
    /**
     * Gets the manual allocation limit for a given attribute.
     * @param attributeName The name of the attribute (e.g., "CONSTITUTION").
     * @return The maximum points a player can manually assign to that attribute, or 1 if not defined.
     */
    public int getManualAttributeLimit(String attributeName) {
        return attributeSettings.manualAllocationLimit.getOrDefault(attributeName.toUpperCase(), 1);
    }

    /**
     * Retrieves the global multiplier for Constitution points affecting health.
     *  The health multiplier per Constitution point.
     *  The protection multiplier per Strength point.
     *  The mana multiplier per Intelligence point.
     *  The vigor multiplier per Dexterity point.
     */
    public float getConMultiplier() { return attributeSettings.conMultiplier; }
    public float getStrMultiplier() { return attributeSettings.strMultiplier; }
    public float getIntMultiplier() { return attributeSettings.intMultiplier; }
    public float getDexMultiplier() { return attributeSettings.dexMultiplier; }

    /**
     * Retrieves the global multiplier applied when a class has a racial affinity to a stat.
     * @return The racial affinity bonus multiplier.
     */
    public float getRacialAffinityMultiplier() { return attributeSettings.racialAffinityMultiplier; }

    /**
     * Retrieves the amount of innate protection gained per player level.
     * @return The innate protection increase per level.
     */
    public float getInnateProtectionPerLevelIncrease() { return attributeSettings.innateProtectionPerLevelIncrease; }
    /**
     * Retrieves the base cooldown duration in ticks for all regeneration pulses.
     * @return The base regeneration pulse cooldown in ticks.
     */
    public int getBaseRegenPulseCooldownTicks() { return regenSettings.baseRegenPulseCooldownTicks; }
    /**
     * Retrieves the amount of health regenerated per pulse per Constitution point.
     * @return The health regeneration amount per Constitution.
     */
    public float getHealthRegenAmountPerConPoint() { return regenSettings.healthRegenAmountPerConPoint; }


    // Race-Specific Configuration Getters
    /**
     * Gets the generic stat configuration (Health, Mana, Vigor, or Protection) for a specific race.
     * This method dynamically retrieves the correct {@link StatConfigBase} subclass
     * based on the provided stat name.
     * @param raceName The name of the race (e.g., "HUMAN", "ELF").
     * @param statName The name of the stat (e.g., "HEALTH", "MANA", "VIGOR", "PROTECTION").
     * @return The appropriate StatConfigBase subclass for the specified stat and race, or a default
     * empty {@link StatConfigBase} if the race or stat name is not found.
     */
    public StatConfigBase getRaceStatConfig(String raceName, String statName) {
        RaceSettings raceSetting = raceSettings.get(raceName.toUpperCase());
        if (raceSetting == null) {
            BrokenPath.LOGGER.warn("Race configuration not found for: {}. Returning default config for {}.", raceName, statName);
            raceSetting = raceSettings.get("SPIRIT"); // Fallback to Spirit settings.
            if (raceSetting == null) {
                BrokenPath.LOGGER.error("SPIRIT race configuration is missing! Cannot provide fallback. Returning generic StatConfigBase.");
                return new StatConfigBase() {}; // Return a generic empty base if all else fails.
            }
        }

        // Return the specific stat config based on statName using a switch for clarity.
        switch (statName.toUpperCase()) {
            case "HEALTH": return Optional.ofNullable(raceSetting.health).orElseGet(HealthStatConfig::new);
            case "MANA": return Optional.ofNullable(raceSetting.mana).orElseGet(ManaStatConfig::new);
            case "VIGOR": return Optional.ofNullable(raceSetting.vigor).orElseGet(VigorStatConfig::new);
            case "PROTECTION": return Optional.ofNullable(raceSetting.protection).orElseGet(ProtectionStatConfig::new);
            default:
                BrokenPath.LOGGER.warn("Unknown stat name '{}' requested for race '{}'. Returning default StatConfigBase.", statName, raceName);
                return new StatConfigBase() {}; // Return a generic empty base if stat name is invalid.
        }
    }

    /**
     * Gets the Favor configuration for a specific race.
     * This includes the base favor value and its maximum and minimum limits for the race.
     * @param raceName The name of the race.
     * @return The {@link FavorConfig} for the specified race, or a default one if the race is not found.
     */
    public FavorConfig getRaceFavorConfig(String raceName) {
        RaceSettings raceSetting = raceSettings.get(raceName.toUpperCase());
        if (raceSetting == null) {
            BrokenPath.LOGGER.warn("Race configuration not found for: {}. Returning default FavorConfig.", raceName);
            return new FavorConfig(); // Return a default FavorConfig if race is not found.
        }
        return Optional.ofNullable(raceSetting.favor).orElseGet(FavorConfig::new);
    }

    /**
     * Gets the innate protection configuration (base and per-level scaling) for the specified race.
     * @param raceName The name of the race.
     * @return The {@link ProtectionInnateConfig} for the specified race, or a default one if the race is not found.
     */
    public ModConfigs.ProtectionInnateConfig getRaceProtectionInnateConfig(String raceName) {
        RaceSettings raceSetting = raceSettings.get(raceName.toUpperCase());
        if (raceSetting == null) {
            BrokenPath.LOGGER.warn("Race configuration not found for: {}. Returning default ProtectionInnateConfig.", raceName);
            return new ProtectionInnateConfig(); // Return a default config if race not found.
        }
        return Optional.ofNullable(raceSetting.protectionInnate).orElseGet(ProtectionInnateConfig::new);
    }

    // Class and Specialization Stat Bonuses
    /**
     * Retrieves the flat stat bonus applied by a specific class to a given stat.
     * @param className The name of the class.
     * @param statName The name of the stat (e.g., "HEALTH", "MANA").
     * @return The flat bonus amount, or 0.0f if no bonus is defined for that class/stat combination.
     */
    public float getClassStatBonus(String className, String statName) {
        return classStatBonuses.getOrDefault(className.toUpperCase(), Collections.emptyMap()).getOrDefault(statName.toUpperCase(), 0.0f);
    }

    /**
     * Retrieves the flat stat bonus applied by a specific specialization to a given stat.
     * @param specializationName The name of the specialization.
     * @param statName The name of the stat (e.g., "HEALTH", "MANA").
     * @return The flat bonus amount, or 0.0f if no bonus is defined for that specialization/stat combination.
     */
    public float getSpecializationStatBonus(String specializationName, String statName) {
        return specializationStatBonuses.getOrDefault(specializationName.toUpperCase(), Collections.emptyMap()).getOrDefault(statName.toUpperCase(), 0.0f);
    }

    // Regeneration Setting Getters
    /**
     * Provides access to various mana regeneration configuration values.
     * Methods include:
     * - {@code getManaRegenOutOfCombatBase()}: Base mana regeneration rate when out of combat.
     * - {@code getManaRegenInCombatBase()}: Base mana regeneration rate when in combat.
     * - {@code getManaRegenBonusPerInt()}: Bonus mana regeneration per Intelligence point.
     * - {@code getManaDelayAfterCombatTicks()}: Delay in ticks after combat before mana regeneration fully resumes.
     */
    public float getManaRegenOutOfCombatBase() { return regenSettings.manaRegenOutOfCombatBase; }
    public float getManaRegenInCombatBase() { return regenSettings.manaRegenInCombatBase; }
    public float getManaRegenBonusPerInt() { return regenSettings.manaRegenBonusPerInt; }
    public int getManaDelayAfterCombatTicks() { return regenSettings.manaDelayAfterCombatTicks; }

    /**
     * Provides access to various vigor regeneration configuration values.
     * Methods include:
     * - {@code getVigorRegenOutOfCombatBase()}: Base vigor regeneration rate when out of combat.
     * - {@code getVigorRegenInCombatBase()}: Base vigor regeneration rate when in combat.
     * - {@code getVigorRegenBonusPerDex()}: Bonus vigor regeneration per Dexterity point.
     * - {@code getVigorDelayAfterCombatTicks()}: Delay in ticks after combat before vigor regeneration fully resumes.
     */
    public float getVigorRegenOutOfCombatBase() { return regenSettings.vigorRegenOutOfCombatBase; }
    public float getVigorRegenInCombatBase() { return regenSettings.vigorRegenInCombatBase; }
    public float getVigorRegenBonusPerDex() { return regenSettings.vigorRegenBonusPerDex; }
    public int getVigorDelayAfterCombatTicks() { return regenSettings.vigorDelayAfterCombatTicks; }

    /**
     * Provides access to various health regeneration configuration values.
     * Methods include:
     * - {@code getHealthAmountToHealPerPulse()}: Amount of health to heal per regeneration pulse.
     * - {@code getHealthMinFoodLevelForRegen()}: Minimum food level required for health regeneration.
     * - {@code getHealthDelayAfterCombatTicks()}: Delay in ticks after combat before health regeneration can begin.
     * - {@code getHealthRegenBonusPerConTicks()}: Bonus health regeneration amount per Constitution point.
     */
    public float getHealthAmountToHealPerPulse() { return regenSettings.healthAmountToHealPerPulse; }
    public int getHealthMinFoodLevelForRegen() { return regenSettings.healthMinFoodLevelForRegen; }
    public int getHealthDelayAfterCombatTicks() { return regenSettings.healthDelayAfterCombatTicks; }
    public float getHealthRegenBonusPerConTicks() { return regenSettings.healthRegenAmountPerConPoint; }

    /**
     * Retrieves the multiplier applied to healing bonuses from regeneration effects.
     * @return Regeneration effect healing bonus multiplier.
     */
    public float getRegenEffectHealingBonusMultiplier() { return regenSettings.regenEffectHealingBonusMultiplier; }

    /**
     * Provides access to innate protection regeneration configuration values.
     * Methods include:
     * - {@code getInnateProtectionAmountPerPulse()}: Amount of innate protection regenerated per pulse.
     * - {@code getInnateProtectionDelayAfterCombatTicks()}: Delay in ticks after combat before innate protection regeneration can begin.
     */
    public float getInnateProtectionAmountPerPulse() { return regenSettings.innateProtectionAmountPerPulse; }
    public int getInnateProtectionDelayAfterCombatTicks() { return regenSettings.innateProtectionDelayAfterCombatTicks; }

    /**
     * Provides access to specific protection regeneration settings influenced by effects.
     * Methods include:
     * - {@code getProtectionRegenSlowCooldownTicks()}: Cooldown duration for slow protection regeneration.
     * - {@code getProtectionAmountPerSlowPulse()}: Amount of protection restored per slow regeneration pulse.
     */
    public int getProtectionRegenSlowCooldownTicks() { return regenSettings.protectionRegenSlowCooldownTicks; }
    public float getProtectionAmountPerSlowPulse() { return regenSettings.protectionAmountPerSlowPulse; }

    /**
     * Gets the amount of mana regenerated per pulse from effects.
     * @return Mana amount per effect pulse.
     */
    public float getManaAmountPerEffectPulse() { return regenSettings.manaAmountPerEffectPulse; }

    /**
     * Gets the amount of vigor regenerated per pulse from effects.
     * @return Vigor amount per effect pulse.
     */
    public float getVigorAmountPerEffectPulse() { return regenSettings.vigorAmountPerEffectPulse; }

    // Hunger Penalties Getters
    /**
     * Provides access to configuration values related to vigor regeneration penalties and damage
     * based on the player's hunger level.
     * Methods include:
     * - {@code hungryModerateVigorRegenPenalty()}: Vigor regeneration penalty at moderate hunger.
     * - {@code hungryIntenseVigorRegenPenalty()}: Vigor regeneration penalty at intense hunger.
     * - {@code starvingVigorRegenPenalty()}: Vigor regeneration penalty when starving.
     * - {@code getStarvingDamageIntervalTicks()}: Interval in ticks at which starving damage is applied.
     * - {@code getStarvingDamageAmount()}: Amount of damage taken when starving.
     */
    public float hungryModerateVigorRegenPenalty() { return regenSettings.hungryModerateVigorRegenPenalty; }
    public float hungryIntenseVigorRegenPenalty() { return regenSettings.hungryIntenseVigorRegenPenalty; }
    public float starvingVigorRegenPenalty() {return regenSettings.starvingVigorRegenPenalty;}
    public int getStarvingDamageIntervalTicks() { return regenSettings.starvingDamageIntervalTicks; }
    public float getStarvingDamageAmount() { return regenSettings.starvingDamageAmount; }

    // Passive Hunger Exhaustion Getters
    /**
     * Provides access to configuration values for passive hunger exhaustion rates
     * based on different hunger levels.
     * Methods include:
     * - {@code hungryModeratePassiveExhaustionPerTick()}: Passive hunger exhaustion at moderate hunger.
     * - {@code hungryIntensePassiveExhaustionPerTick()}: Passive hunger exhaustion at intense hunger.
     * - {@code starvingPassiveExhaustionPerTick()}: Passive hunger exhaustion when starving.
     */
    public float hungryModeratePassiveExhaustionPerTick() { return regenSettings.hungryModeratePassiveExhaustionPerTick; }
    public float hungryIntensePassiveExhaustionPerTick() { return regenSettings.hungryIntensePassiveExhaustionPerTick; }
    public float starvingPassiveExhaustionPerTick() { return regenSettings.starvingPassiveExhaustionPerTick; }

    // Other Global Getters
    /**
     * Gets the achievement configuration for a specific achievement key.
     * This includes its XP reward and completion threshold.
     * @param achievementKey The key identifier of the achievement (e.g., "EXPLORATION_ROOT").
     * @return The {@link AchievementConfig} for the specified achievement, or null if not found.
     */
    public AchievementConfig getAchievementConfig(String achievementKey) { return achievements.get(achievementKey.toUpperCase());}

    /**
     * Gets the maximum favor bonus multiplier allowed in the mod.
     * This multiplier caps the effect of favor on various mechanics.
     * @return The maximum favor bonus multiplier.
     */
    public float getFavorBonusMultiplier() { return maxFavorBonusMultiplier; }

    /**
     * Gets the percentage of damage that can penetrate (bypass) armor/protection in combat.
     * @return The damage penetration percentage.
     */
    public float getDamagePenetrationPercentage() { return combatSettings.damagePenetrationPercentage; }

    /**
     * Gets the villager trade settings, including trade cooldowns and XP rewards.
     * @return The {@link VillagerTradeSettings} object.
     */
    public VillagerTradeSettings getVillagerTradeSettings() { return villagerTradeSettings; }

    /**
     * Gets the base hunger exhaustion cost per health regeneration pulse.
     * @return The base hunger exhaustion cost.
     */
    public float getBaseHungerConsumptionPerHealthRegenPulse() { return regenSettings.baseHungerConsumptionPerHealthRegenPulse; }

    /**
     * Gets the hunger consumption scaling per Constitution point for health regeneration.
     * @return The hunger consumption per CON point scaling.
     */
    public float getHungerConsumptionPerConPointScaling() { return regenSettings.hungerConsumptionPerConPointScaling; }

    /**
     * Gets the maximum hunger consumption per health regeneration pulse.
     * @return The maximum hunger consumption per pulse.
     */
    public float getMaxHungerConsumptionPerPulse() { return regenSettings.maxHungerConsumptionPerPulse; }
}