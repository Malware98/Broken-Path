package com.malware98.brokenpath.data.config;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.malware98.brokenpath.BrokenPath;
import net.minecraftforge.fml.loading.FMLPaths;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Manages direct mappings of racial affinities for each class based on predefined tiers.
 * This replaces the tag-counting system for determining affinity tiers.
 * Implements the Singleton pattern.
 */
public class AffinityMappingConfig {

    // --- Singleton Instance ---
    private static AffinityMappingConfig INSTANCE;

    // --- Logger ---
    private static final Logger LOGGER = LogManager.getLogger(BrokenPath.MOD_ID + "_AffinityMappingConfig");

    // --- Gson Instance ---
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    // --- Configuration File Path ---
    private static final String CONFIG_FILE_NAME = "brokenpath_affinity_mappings.json";
    private static final Path CONFIG_PATH = FMLPaths.CONFIGDIR.get().resolve(CONFIG_FILE_NAME);

    // --- Configuration Values ---
    public Map<String, ClassAffinityMap> classAffinities; // Key: Class Name

    // --- Constructor ---
    private AffinityMappingConfig() {
        initializeDefaults();
    }

    // --- Singleton Access Method ---
    public static AffinityMappingConfig getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new AffinityMappingConfig();
        }
        return INSTANCE;
    }

    // --- Default Initialization ---
    private void initializeDefaults() {
        classAffinities = new HashMap<>();

        // CHAMPION Affinities
        classAffinities.put("CHAMPION", new ClassAffinityMap(
                List.of("HUMAN"),
                List.of("DRACONID", "AASIMAR", "ANDROID"),
                List.of("ELF", "ORC", "CHIMERA"),
                List.of("TRITON")
        ));

        // SORCERER Affinities
        classAffinities.put("SORCERER", new ClassAffinityMap(
                List.of("ELF"),
                List.of("AASIMAR", "TRITON", "HUMAN"),
                List.of("DRACONID", "CHIMERA", "ANDROID"),
                List.of("ORC")
        ));

        // BERSERKER Affinities
        classAffinities.put("BERSERKER", new ClassAffinityMap(
                List.of("ORC"),
                List.of("DRACONID", "CHIMERA", "HUMAN"),
                List.of("ANDROID", "AASIMAR", "TRITON"),
                List.of("ELF")
        ));

        // SHAMAN Affinities
        classAffinities.put("SHAMAN", new ClassAffinityMap(
                List.of("DRACONID"),
                List.of("ORC", "CHIMERA", "TRITON"),
                List.of("HUMAN", "AASIMAR", "ANDROID"),
                List.of("ANDROID")
        ));

        // EXPLORER Affinities
        classAffinities.put("EXPLORER", new ClassAffinityMap(
                List.of("CHIMERA"),
                List.of("HUMAN", "TRITON", "ANDROID"),
                List.of("ELF", "DRACONID", "AASIMAR"),
                List.of("DRACONID")
        ));

        // CHANNELER Affinities
        classAffinities.put("CHANNELER", new ClassAffinityMap(
                List.of("TRITON"),
                List.of("ELF", "AASIMAR", "HUMAN"),
                List.of("DRACONID", "ANDROID", "CHIMERA"),
                List.of("CHIMERA")
        ));

        // VESTAL Affinities
        classAffinities.put("VESTAL", new ClassAffinityMap(
                List.of("AASIMAR"),
                List.of("ELF", "TRITON", "HUMAN"),
                List.of("DRACONID", "ANDROID", "CHIMERA"),
                List.of("ORC")
        ));

        // TECHNOMANCER Affinities
        classAffinities.put("TECHNOMANCER", new ClassAffinityMap(
                List.of("ANDROID"),
                List.of("HUMAN", "DRACONID", "CHIMERA"),
                List.of("ORC", "AASIMAR", "TRITON"),
                List.of("HUMAN")
        ));
    }

    // --- Configuration Loading/Saving ---
    /**
     * Loads affinity mappings from 'brokenpath_affinity_mappings.json'.
     */
    public void loadConfig() {
        File configFile = CONFIG_PATH.toFile();

        if (configFile.exists()) {
            try (FileReader reader = new FileReader(configFile)) {
                AffinityMappingConfig loadedConfig = GSON.fromJson(reader, AffinityMappingConfig.class);
                if (loadedConfig != null && loadedConfig.classAffinities != null) {
                    this.classAffinities = loadedConfig.classAffinities;
                    this.classAffinities.values().forEach(cam -> {
                        cam.idealRaces = Optional.ofNullable(cam.idealRaces).orElseGet(ArrayList::new);
                        cam.efficientRaces = Optional.ofNullable(cam.efficientRaces).orElseGet(ArrayList::new);
                        cam.acceptableRaces = Optional.ofNullable(cam.acceptableRaces).orElseGet(ArrayList::new);
                        cam.deficientRaces = Optional.ofNullable(cam.deficientRaces).orElseGet(ArrayList::new);
                    });
                } else {
                    LOGGER.warn("Configuration file '{}' was empty or invalid JSON. Loading default affinity mappings.", CONFIG_FILE_NAME);
                    initializeDefaults();
                }
            } catch (Exception e) {
                LOGGER.error("Error parsing or reading affinity mapping file '{}'. Loading default configurations. Error: {}", CONFIG_FILE_NAME, e.getMessage());
                initializeDefaults();
            }
        } else {
            LOGGER.info("Affinity mapping file '{}' not found. Creating with default configurations.", CONFIG_FILE_NAME);
            saveConfig();
        }
    }

    /**
     * Saves the current affinity mappings to 'brokenpath_affinity_mappings.json'.
     */
    public void saveConfig() {
        File configFile = CONFIG_PATH.toFile();
        try (FileWriter writer = new FileWriter(configFile)) {
            GSON.toJson(this, writer);
        } catch (IOException e) {
            LOGGER.error("Failed to save affinity mapping file '{}'. Error: {}", CONFIG_FILE_NAME, e.getMessage());
        }
    }

    // --- Getters for Configuration Values ---
    /**
     * Retrieves the affinity map for a specific class.
     * @param className The name of the class.
     * @return The ClassAffinityMap for the specified class, or an empty map if not found.
     */
    public ClassAffinityMap getClassAffinityMap(String className) {
        return classAffinities.getOrDefault(className.toUpperCase(), new ClassAffinityMap(
                new ArrayList<>(), new ArrayList<>(), new ArrayList<>(), new ArrayList<>()
        ));
    }

    /**
     * Determines the affinity tier for a given race and class combination.
     * @param raceName The name of the race.
     * @param className The name of the class.
     * @return The determined affinity tier (e.g., "IDEAL", "EFFICIENT").
     */
    public String getAffinityTier(String raceName, String className) {
        ClassAffinityMap affinityMap = getClassAffinityMap(className);
        String normalizedRaceName = raceName.toUpperCase();

        if (affinityMap.idealRaces.contains(normalizedRaceName)) return "IDEAL";
        if (affinityMap.efficientRaces.contains(normalizedRaceName)) return "EFFICIENT";
        if (affinityMap.acceptableRaces.contains(normalizedRaceName)) return "ACCEPTABLE";
        if (affinityMap.deficientRaces.contains(normalizedRaceName)) return "DEFICIENT";

        return "DEFICIENT";
    }

    // --- Nested Class for Class Affinity Map ---
    /**
     * Represents the direct affinity mappings for a single class.
     */
    public static class ClassAffinityMap {
        public List<String> idealRaces;
        public List<String> efficientRaces;
        public List<String> acceptableRaces;
        public List<String> deficientRaces;

        public ClassAffinityMap() {
            this.idealRaces = new ArrayList<>();
            this.efficientRaces = new ArrayList<>();
            this.acceptableRaces = new ArrayList<>();
            this.deficientRaces = new ArrayList<>();
        }

        public ClassAffinityMap(List<String> ideal, List<String> efficient, List<String> acceptable, List<String> deficient) {
            this.idealRaces = ideal;
            this.efficientRaces = efficient;
            this.acceptableRaces = acceptable;
            this.deficientRaces = deficient;
        }

        public List<String> getIdealRaces() { return idealRaces; }
        public List<String> getEfficientRaces() { return efficientRaces; }
        public List<String> getAcceptableRaces() { return acceptableRaces; }
        public List<String> getDeficientRaces() { return deficientRaces; }
    }
}