package com.malware98.brokenpath.data.config;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.malware98.brokenpath.BrokenPath;
import net.minecraftforge.fml.loading.FMLPaths;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * Manages configurable values related to player core attributes.
 * Includes multipliers, manual allocation limits, and level-based point progression.
 * Implements the Singleton pattern.
 */
public class AttributeConfig {

    // --- Singleton Instance ---
    private static AttributeConfig INSTANCE;

    // --- Logger ---
    private static final Logger LOGGER = LogManager.getLogger(BrokenPath.MOD_ID + "_AttributeConfig");

    // --- Gson Instance ---
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    // --- Configuration File Path ---
    private static final String CONFIG_FILE_NAME = "brokenpath_player_stats_attributes.json";
    private static final Path CONFIG_PATH = FMLPaths.CONFIGDIR.get().resolve(CONFIG_FILE_NAME);

    // --- Configuration Values ---
    public Map<String, Integer> manualAllocationLimit;
    public float conMultiplier;
    public float intMultiplier;
    public float dexMultiplier;
    public float innateProtectionPerLevelIncrease;
    public Map<String, Integer> levelProgression;

    // --- Constructor ---
    private AttributeConfig() {
        initializeDefaults();
    }

    // --- Singleton Access Method ---
    public static AttributeConfig getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new AttributeConfig();
        }
        return INSTANCE;
    }

    // --- Default Initialization ---
    private void initializeDefaults() {
        manualAllocationLimit = new HashMap<>();
        levelProgression = new HashMap<>();

        // Default Attribute Allocation Limits
        manualAllocationLimit.put("CONSTITUTION", 50);
        manualAllocationLimit.put("STRENGTH", 50);
        manualAllocationLimit.put("DEXTERITY", 50);
        manualAllocationLimit.put("INTELLIGENCE", 50);

        // Global multipliers for attribute points to stats
        conMultiplier = 2.0f;
        intMultiplier = 2.0f;
        dexMultiplier = 2.0f;

        // Global Innate Protection per level increase
        innateProtectionPerLevelIncrease = 0.2f;

        // Attribute Point Allocation per Level Progression (Total 150 points at level 50)
        levelProgression.put("1-1", 0);
        levelProgression.put("2-10", 1);
        levelProgression.put("11-20", 2);
        levelProgression.put("21-30", 3);
        levelProgression.put("31-40", 4);
        levelProgression.put("41-49", 5);
        levelProgression.put("50-50", 6);
    }

    // --- Configuration Loading/Saving ---
    /**
     * Loads attribute configurations from 'brokenpath_player_stats_attributes.json'.
     */
    public void loadConfig() {
        File configFile = CONFIG_PATH.toFile();

        if (configFile.exists()) {
            try (FileReader reader = new FileReader(configFile)) {
                AttributeConfig loadedConfig = GSON.fromJson(reader, AttributeConfig.class);
                if (loadedConfig != null) {
                    this.manualAllocationLimit = Optional.ofNullable(loadedConfig.manualAllocationLimit).orElseGet(HashMap::new);
                    this.conMultiplier = loadedConfig.conMultiplier;
                    this.intMultiplier = loadedConfig.intMultiplier;
                    this.dexMultiplier = loadedConfig.dexMultiplier;
                    this.innateProtectionPerLevelIncrease = loadedConfig.innateProtectionPerLevelIncrease;
                    this.levelProgression = Optional.ofNullable(loadedConfig.levelProgression).orElseGet(HashMap::new);
                } else {
                    LOGGER.warn("Configuration file '{}' was empty or invalid JSON. Loading default attribute configurations.", CONFIG_FILE_NAME);
                    initializeDefaults();
                }
            } catch (Exception e) {
                LOGGER.error("Error parsing or reading attribute configuration file '{}'. Loading default configurations. Error: {}", CONFIG_FILE_NAME, e.getMessage());
                initializeDefaults();
            }
        } else {
            LOGGER.info("Attribute configuration file '{}' not found. Creating with default configurations.", CONFIG_FILE_NAME);
            saveConfig();
        }

        if (this.conMultiplier == 0.0f) this.conMultiplier = 2.0f;
        if (this.intMultiplier == 0.0f) this.intMultiplier = 2.0f;
        if (this.dexMultiplier == 0.0f) this.dexMultiplier = 2.0f;
        if (this.innateProtectionPerLevelIncrease == 0.0f) this.innateProtectionPerLevelIncrease = 0.2f;
    }

    /**
     * Saves the current attribute configuration to 'brokenpath_player_stats_attributes.json'.
     */
    public void saveConfig() {
        File configFile = CONFIG_PATH.toFile();
        try (FileWriter writer = new FileWriter(configFile)) {
            GSON.toJson(this, writer);
        } catch (IOException e) {
            LOGGER.error("Failed to save attribute configuration file '{}'. Error: {}", CONFIG_FILE_NAME, e.getMessage());
        }
    }

    // --- Getters for Configuration Values ---
    public int getManualAllocationLimit(String attributeName) {
        return manualAllocationLimit.getOrDefault(attributeName.toUpperCase(), 1);
    }
    public float getConMultiplier() { return conMultiplier; }
    public float getIntMultiplier() { return intMultiplier; }
    public float getDexMultiplier() { return dexMultiplier; }
    public float getInnateProtectionPerLevelIncrease() { return innateProtectionPerLevelIncrease; }
    public Map<String, Integer> getLevelProgression() { return levelProgression; }

    /**
     * Retrieves the number of attribute points granted for reaching a specific level.
     * @param level The player's current level.
     * @return The number of attribute points awarded, or 0 if not defined.
     */
    public int getAttributePointsForLevelRange(int level) {
        for (Map.Entry<String, Integer> entry : levelProgression.entrySet()) {
            String[] range = entry.getKey().split("-");
            try {
                int min = Integer.parseInt(range[0]);
                int max = Integer.parseInt(range[1]);
                if (level >= min && level <= max) {
                    return entry.getValue();
                }
            } catch (NumberFormatException e) {
                LOGGER.error("Error parsing level range in attribute configuration: {}. Error: {}", entry.getKey(), e.getMessage());
            }
        }
        return 0;
    }
}