package com.malware98.brokenpath.mobeffects;

import com.malware98.brokenpath.capabilities.IPlayerStats;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;
import com.malware98.brokenpath.data.ModConfigs;
import net.minecraft.world.effect.MobEffect;
import net.minecraft.world.effect.MobEffectCategory;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.entity.player.Player;
import net.minecraftforge.common.util.LazyOptional;
import org.jetbrains.annotations.NotNull;

// Clase para el efecto de regeneración de Protección.
public class ProtectionRegenMobEffect extends MobEffect {

    public ProtectionRegenMobEffect(MobEffectCategory pCategory, int pColor) {
        super(pCategory, pColor);
    }

    //Se llama en cada tick mientras el efecto está activo en una entidad.
    @Override
    public void applyEffectTick(@NotNull LivingEntity pLivingEntity, int pAmplifier) {
        if (pLivingEntity instanceof Player player) {
            if (!player.level().isClientSide()) {
                LazyOptional<IPlayerStats> playerStatsOptional = player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY);

                playerStatsOptional.ifPresent(playerStats -> {
                    ModConfigs configs = ModConfigs.getInstance();
                    int regenCooldown = configs.getProtectionRegenSlowCooldownTicks(); // Obtenemos el cooldown del ModConfigs

                    // Solo regenera si el tick actual es un múltiplo del cooldown
                    if (player.tickCount % regenCooldown == 0) {
                        // La cantidad base por pulso se multiplica por (amplificador + 1).
                        // pAmplifier = 0 (nivel I) -> multiplicador 1
                        // pAmplifier = 1 (nivel II) -> multiplicador 2
                        // pAmplifier = 2 (nivel III) -> multiplicador 3, y así sucesivamente.
                        float baseAmount = configs.getProtectionAmountPerSlowPulse();
                        float amountToHeal = baseAmount * (pAmplifier + 1);

                        playerStats.setCurrentProtection(playerStats.getCurrentProtection() + amountToHeal);
                        // El procedimiento setCurrentProtection en PlayerStats ya maneja el ajuste al máximo y la sincronización.
                    }
                });
            }
        }
    }

     //Determina si el efecto debe aplicar su lógica en este tick.
     //Siempre retorna true para que applyEffectTick se llame en cada tick y maneje su propio cooldown.
    @Override
    public boolean isDurationEffectTick(int pDuration, int pAmplifier) {
        return true;
    }
}