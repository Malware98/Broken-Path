// ProtectionRegenMobEffect.java
package com.malware98.brokenpath.mobeffects;

import com.malware98.brokenpath.capabilities.IPlayerStats;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;
import com.malware98.brokenpath.data.config.RegenDataConfig; // NEW: Import RegenDataConfig
import net.minecraft.world.effect.MobEffect;
import net.minecraft.world.effect.MobEffectCategory;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.entity.player.Player;
import net.minecraftforge.common.util.LazyOptional;
import org.jetbrains.annotations.NotNull;

/**
 * // Mob effect that provides Protection regeneration to a player.
 * // Grants protection points at defined intervals.
 */
public class ProtectionRegenMobEffect extends MobEffect {

    // // --- Constructor ---
    /**
     * // Constructor for the Protection Regeneration mob effect.
     * @param pCategory The category of the mob effect (e.g., BENEFICIAL, HARMFUL).
     * @param pColor The color of the effect particles.
     */
    public ProtectionRegenMobEffect(MobEffectCategory pCategory, int pColor) {
        super(pCategory, pColor);
    }

    // // --- Effect Application ---
    /**
     * // Applies the effect logic per tick to the living entity.
     * // Calculates and applies Protection regeneration based on configured cooldown and amplifier.
     * @param pLivingEntity The entity the effect is applied to.
     * @param pAmplifier The amplifier level of the effect (0 for level I, 1 for level II, etc.).
     */
    @Override
    public void applyEffectTick(@NotNull LivingEntity pLivingEntity, int pAmplifier) {
        // Ensure the entity is a player and on the server-side to apply stats changes.
        if (pLivingEntity instanceof Player player) {
            if (!player.level().isClientSide()) {
                // Attempt to get the player's custom stats' capability.
                LazyOptional<IPlayerStats> playerStatsOptional = player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY);

                // If the capability is present, apply protection regeneration.
                playerStatsOptional.ifPresent(playerStats -> {
                    RegenDataConfig regenConfigs = RegenDataConfig.getInstance(); // Use RegenDataConfig
                    // Retrieve protection regeneration cooldown from RegenDataConfig.
                    int regenCooldown = regenConfigs.getProtectionRegenSlowCooldownTicks();

                    // Regenerate Protection only if the current tick is a multiple of the cooldown.
                    // This ensures regeneration happens in pulses rather than continuously.
                    if (player.tickCount % regenCooldown == 0) {
                        // Base amount per pulse is multiplied by (amplifier + 1).
                        // pAmplifier = 0 (Level I) means multiplier 1
                        // pAmplifier = 1 (Level II) means multiplier 2, and so on.
                        float baseAmount = regenConfigs.getProtectionAmountPerSlowPulse(); // Use RegenDataConfig
                        float amountToHeal = baseAmount * (pAmplifier + 1);

                        // Increase the player's current Protection.
                        // The `setCurrentProtection` method handles capping at max Protection and synchronization.
                        playerStats.setCurrentProtection(playerStats.getCurrentProtection() + amountToHeal);
                    }
                });
            }
        }
    }

    // // --- Tick Duration Check ---
    /**
     * // Determines whether the effect should apply its logic on this specific tick.
     * // Always returns true because `applyEffectTick` manages its own internal cooldown.
     * @param pDuration The remaining duration of the effect.
     * @param pAmplifier The amplifier level of the effect.
     * @return True, indicating the effect applies every tick.
     */
    @Override
    public boolean isDurationEffectTick(int pDuration, int pAmplifier) {
        return true; // Applied every tick of duration.
    }
}
