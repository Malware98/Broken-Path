package com.malware98.brokenpath.client.gui;

import com.malware98.brokenpath.BrokenPath;
import com.malware98.brokenpath.client.PlayerStatsClient;
import com.mojang.blaze3d.systems.RenderSystem;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.renderer.GameRenderer;
import net.minecraft.resources.ResourceLocation;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.client.event.RegisterGuiOverlaysEvent;
import net.minecraftforge.client.gui.overlay.IGuiOverlay;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

// --- Event Subscriber Registration ---
/**
 * Registers and renders the custom HUD overlay for player statistics.
 * This class is subscribed to the Mod event bus on the client side to handle GUI overlay registration.
 */
@Mod.EventBusSubscriber(modid = BrokenPath.MOD_ID, bus = Mod.EventBusSubscriber.Bus.MOD, value = Dist.CLIENT)
public class BrokenPathHudOverlay {

    // --- Texture and Dimension Constants ---
    // Location of the HUD texture atlas, containing all custom HUD elements.
    private static final ResourceLocation HUD_TEXTURE = new ResourceLocation(BrokenPath.MOD_ID, "textures/gui/hud/player_stats_hud.png");

    // Standard dimensions for the main stat bars (Health, Protection, Mana, Vigor) on screen.
    private static final int MAIN_BAR_W = 104; // Width of main bars
    private static final int MAIN_BAR_H = 10;  // Height of main bars

    // Dimensions for the innate protection bar on screen.
    private static final int INNATE_BAR_W = 16;
    private static final int INNATE_BAR_H = 10;

    // General spacing between HUD elements.
    private static final int GAP = 4;
    // Horizontal margin specifically between main bars and the innate protection bar.
    private static final int MAIN_INNATE_H_MARGIN = 2;

    // --- UV Coordinates and Dimensions from the PNG Texture Atlas ---

    // UVs and dimensions for the "Character Icon and Luck Title" block.
    // This block displays the player's icon and the "Favor" (Luck) title.
    private static final int UV_PLAYER_BLOCK_X = 0;
    private static final int UV_PLAYER_BLOCK_Y = 0;
    private static final int PLAYER_BLOCK_W = 48;
    private static final int PLAYER_BLOCK_H = 48; // Adjusted height from 64 to 48.

    // UVs and dimensions for secondary elements below the character block.
    // Separator: A small graphical element to divide sections.
    private static final int UV_SEPARATOR_X = 0;
    private static final int UV_SEPARATOR_Y = 52; // Adjusted Y based on new PLAYER_BLOCK_H + GAP.
    private static final int SEPARATOR_WIDTH = 8;
    private static final int SEPARATOR_HEIGHT = 10;

    // Limit Strip: A small vertical indicator drawn at the end of filled bars.
    private static final int UV_LIMIT_STRIP_X = SEPARATOR_WIDTH + GAP;
    private static final int UV_LIMIT_STRIP_Y = 52; // Aligned with Separator.
    private static final int LIMIT_STRIP_WIDTH = 2;
    private static final int LIMIT_STRIP_HEIGHT = 10;

    // UVs and dimensions for the Innate Protection bar elements.
    // Background of the innate protection bar.
    private static final int UV_IN_PROTECTION_BG_X = 0;
    private static final int UV_IN_PROTECTION_BG_Y = 66; // Adjusted Y based on UV_SEPARATOR_Y + SEPARATOR_HEIGHT + GAP.
    private static final int IN_PROTECTION_BAR_SHEET_W = 16;
    private static final int IN_PROTECTION_BAR_SHEET_H = 10;

    // Overlay layer for innate protection bar (decorative element).
    private static final int UV_IN_PROTECTION_OVERLAY_X = UV_IN_PROTECTION_BG_X + IN_PROTECTION_BAR_SHEET_W; // No GAP in between for tight packing.
    private static final int UV_IN_PROTECTION_OVERLAY_Y = UV_IN_PROTECTION_BG_Y;

    // Fill layer for innate protection bar (represents current value).
    private static final int UV_IN_PROTECTION_FILL_X = UV_IN_PROTECTION_OVERLAY_X + IN_PROTECTION_BAR_SHEET_W; // No GAP in between.
    private static final int UV_IN_PROTECTION_FILL_Y = UV_IN_PROTECTION_BG_Y;

    // UVs and dimensions for the main stat bars (Health, Protection, Mana, Vigor).
    // Background of the main stat bars.
    private static final int UV_MAIN_BAR_BACKGROUND_X = PLAYER_BLOCK_W + GAP; // Positioned right of character block.
    private static final int UV_MAIN_BAR_BACKGROUND_Y = 0;
    private static final int MAIN_STAT_BAR_W = 104;
    private static final int MAIN_STAT_BAR_H = 10;

    // Overlay layer for main stat bars (decorative element).
    private static final int UV_MAIN_BAR_OVERLAY_X = UV_MAIN_BAR_BACKGROUND_X;
    private static final int UV_MAIN_BAR_OVERLAY_Y = MAIN_STAT_BAR_H + GAP;

    // Fill layers for individual main stat bars (stacked vertically in PNG).
    // These UVs determine which part of the texture is used for the filled portion of the bar.
    private static final int UV_HEALTH_FILL_X = UV_MAIN_BAR_BACKGROUND_X;
    private static final int UV_HEALTH_FILL_Y = UV_MAIN_BAR_OVERLAY_Y + MAIN_STAT_BAR_H + GAP;

    private static final int UV_PROTECTION_FILL_Y = UV_HEALTH_FILL_Y + MAIN_STAT_BAR_H;
    private static final int UV_MANA_FILL_Y = UV_PROTECTION_FILL_Y + MAIN_STAT_BAR_H;
    private static final int UV_VIGOR_FILL_Y = UV_MANA_FILL_Y + MAIN_STAT_BAR_H;

    // UV for the "no statistic" static bar fill. Used for placeholder bars.
    private static final int UV_STATIC_FILL_Y = UV_VIGOR_FILL_Y + MAIN_STAT_BAR_H;

    // --- UV Coordinates and Dimensions for Favor Icons ---
    // Dimensions of each individual favor icon.
    private static final int FAVOR_ICON_WIDTH = 9;
    private static final int FAVOR_ICON_HEIGHT = 9;

    // Base X coordinate for the start of all favor icons in the texture sheet.
    private static final int UV_FAVOR_BASE_X = 160;

    // Row 1 UVs (Y = 0) - Contains full color favor icons and empty/max icons.
    private static final int UV_FAVOR_ROW1_Y = 0;
    // Full color favor icons, ordered from Very Bad to Very Good.
    private static final int UV_FAVOR_VERY_BAD_FULL_X = UV_FAVOR_BASE_X;
    private static final int UV_FAVOR_BAD_FULL_X = UV_FAVOR_BASE_X + (FAVOR_ICON_WIDTH);
    private static final int UV_FAVOR_NEUTRAL_FULL_X = UV_FAVOR_BASE_X + (2 * FAVOR_ICON_WIDTH);
    private static final int UV_FAVOR_GOOD_FULL_X = UV_FAVOR_BASE_X + (3 * FAVOR_ICON_WIDTH);
    private static final int UV_FAVOR_VERY_GOOD_FULL_X = UV_FAVOR_BASE_X + (4 * FAVOR_ICON_WIDTH);
    // Empty default icon for segments not yet filled.
    private static final int UV_FAVOR_EMPTY_DEFAULT_X = UV_FAVOR_BASE_X + (5 * FAVOR_ICON_WIDTH);

    // Specific icons for zero and max favor states.
    private static final int UV_FAVOR_ICON_EMPTY_ZERO_FAVOR_X = UV_FAVOR_BASE_X + (6 * FAVOR_ICON_WIDTH);
    private static final int UV_FAVOR_MAX_X = UV_FAVOR_BASE_X + (7 * FAVOR_ICON_WIDTH);

    // Row 2 UVs (Y = 9) - Contains overlay effects for favor icons.
    private static final int UV_FAVOR_ROW2_Y = UV_FAVOR_ROW1_Y + FAVOR_ICON_HEIGHT;
    // Effect overlays for favor: cannot gain, positive multiplier, negative multiplier.
    private static final int UV_EFFECT_CANNOT_GAIN_FAVOR_X = UV_FAVOR_BASE_X;
    private static final int UV_EFFECT_MULTIPLIER_POSITIVE_X = UV_FAVOR_BASE_X + (FAVOR_ICON_WIDTH);
    private static final int UV_EFFECT_MULTIPLIER_NEGATIVE_X = UV_FAVOR_BASE_X + (2 * FAVOR_ICON_WIDTH);


    // --- HUD Overlay Definition ---
    /**
     * Defines the actual rendering logic for the custom HUD.
     * This lambda is executed by Forge's GUI rendering system.
     */
    public static final IGuiOverlay HUD_OVERLAY = (mc, guiGraphics, screenWidth, screenHeight, partialTick) -> {
        Minecraft minecraft = Minecraft.getInstance();

        // --- Pre-rendering Checks ---
        // Prevents HUD from rendering if the player is not loaded or the game is paused.
        if (minecraft.player == null || minecraft.isPaused()) {
            return;
        }

        // --- HUD Positioning on Screen ---
        // Defines the top-left corner where the HUD will start drawing.
        int hudStartX = 10;
        int hudStartY = 10;

        // --- Render System Setup ---
        // Prepare OpenGL for drawing textures. Sets the shader program and ensures full color rendering.
        RenderSystem.setShader(GameRenderer::getPositionTexShader);
        RenderSystem.setShaderColor(1.0F, 1.0F, 1.0F, 1.0F);

        // --- Draw Character Icon Block ---
        // Renders the fixed background element which includes the player icon area.
        guiGraphics.blit(
                HUD_TEXTURE,          // The texture atlas to draw from.
                hudStartX, hudStartY, // Screen coordinates (X, Y) to draw the element.
                UV_PLAYER_BLOCK_X, UV_PLAYER_BLOCK_Y, // UV coordinates (X, Y) on the texture atlas.
                PLAYER_BLOCK_W, PLAYER_BLOCK_H,       // Width and height of the portion to draw from the texture.
                256, 256              // Total dimensions of the texture atlas (width, height).
        );

        // Define fixed X positions for the separator and the main bar column.
        final int separadorX = hudStartX + PLAYER_BLOCK_W;     // Separator is positioned right of the character block.
        final int mainBarX = separadorX + SEPARATOR_WIDTH;     // Main bars are positioned right of the separator.

        // A mutable variable to track the current Y position for drawing each bar.
        // This allows bars to be stacked dynamically based on visibility.
        int currentDrawY = hudStartY + 4; // Start with a 4px margin from the top of the HUD block.

        // Counter to keep track of how many dynamic (stat-based) bars have been drawn.
        int dynamicBarsDrawnCount = 0;

        // --- Draw Dynamic Stat Bars (in a predefined order: Health, Protection, Mana, Vigor) ---
        // Stats are retrieved from PlayerStatsClient for client-side synchronization.

        // 1. Health Bar: Always drawn first if a player has health.
        if (PlayerStatsClient.getClientMaxHealth() > 0) {
            float currentHealth = PlayerStatsClient.getClientCurrentHealth();
            float maxHealth = PlayerStatsClient.getClientMaxHealth();
            drawMainStatBar(guiGraphics, currentDrawY, separadorX, mainBarX, UV_HEALTH_FILL_Y, currentHealth, maxHealth);

            // Draw Innate Protection Bar, horizontally aligned with Health, if applicable for the player's race.
            if (PlayerStatsClient.getClientMaxInnateProtection() > 0) {
                float currentInnateProtection = PlayerStatsClient.getClientCurrentInnateProtection();
                float maxInnateProtection = PlayerStatsClient.getClientMaxInnateProtection();
                // Calculate percentage, safely handling division by zero for maxInnateProtection.
                float innateProtectionPercentage = currentInnateProtection / maxInnateProtection;
                int innateBarX = mainBarX + MAIN_BAR_W + MAIN_INNATE_H_MARGIN; // Positioned right of the main health bar.
                drawInnateProtectionBar(guiGraphics, innateBarX, currentDrawY, innateProtectionPercentage); // Vertically aligned.
            }
            currentDrawY += MAIN_BAR_H; // Advance Y position for the next bar slot.
            dynamicBarsDrawnCount++;
        }

        // 2. Regular Protection Bar: Drawn only if the player has equipped armor (indicated by vanilla armor value).
        if (minecraft.player.getArmorValue() > 0) {
            float currentProtection = PlayerStatsClient.getClientCurrentProtection();
            float maxProtection = PlayerStatsClient.getClientMaxProtection();
            drawMainStatBar(guiGraphics, currentDrawY, separadorX, mainBarX, UV_PROTECTION_FILL_Y, currentProtection, maxProtection);
            currentDrawY += MAIN_BAR_H;
            dynamicBarsDrawnCount++;
        }

        // 3. Mana Bar: Drawn only if the player has a maximum Mana capacity greater than zero.
        if (PlayerStatsClient.getClientMaxMana() > 0) {
            float currentMana = PlayerStatsClient.getClientCurrentMana();
            float maxMana = PlayerStatsClient.getClientMaxMana();
            drawMainStatBar(guiGraphics, currentDrawY, separadorX, mainBarX, UV_MANA_FILL_Y, currentMana, maxMana);
            currentDrawY += MAIN_BAR_H;
            dynamicBarsDrawnCount++;
        }

        // 4. Vigor Bar: Drawn only if the player has a maximum Vigor capacity greater than zero.
        if (PlayerStatsClient.getClientMaxVigor() > 0) {
            float currentVigor = PlayerStatsClient.getClientCurrentVigor();
            float maxVigor = PlayerStatsClient.getClientMaxVigor();
            drawMainStatBar(guiGraphics, currentDrawY, separadorX, mainBarX, UV_VIGOR_FILL_Y, currentVigor, maxVigor);
            currentDrawY += MAIN_BAR_H;
            dynamicBarsDrawnCount++;
        }

        // --- Fill Remaining Slots with "No Statistic" Bars ---
        // Ensures a consistent total of 4 main bar slots are always displayed,
        // filling any empty slots with static placeholder bars.
        int numStaticBarsToDraw = 4 - dynamicBarsDrawnCount;
        for (int i = 0; i < numStaticBarsToDraw; i++) {
            drawNoStatisticBar(guiGraphics, currentDrawY, separadorX, mainBarX);
            currentDrawY += MAIN_BAR_H; // Advance Y for the next bar slot.
        }

        // --- Draw Favor (Luck) Bar ---
        // Position the Favor bar at the bottom center of the screen.
        int favorBarX = (minecraft.getWindow().getGuiScaledWidth() / 2) - 91;
        int favorBarY = minecraft.getWindow().getGuiScaledHeight() - 39;
        float currentFavor = PlayerStatsClient.getClientFavor(); // Retrieve current favor value.

        final float FAVOR_PER_ICON = 20.0f; // Each icon represents 20 favor points (200 total favor / 10 icons).
        final float MAX_TOTAL_FAVOR = FAVOR_PER_ICON * 10; // Maximum theoretical favor for display purposes (200.0f).

        // Determine special display states: exactly zero favor or maximum favor.
        boolean renderAsZeroFavor = (currentFavor == 0);
        boolean renderAsMaxFavor = (currentFavor >= MAX_TOTAL_FAVOR); // Use >= for float safety.

        // Determine the base UV (X-coordinate) for the current color of the filled favor icon.
        // This changes based on favor ranges, giving a visual progression.
        int currentFavorFillUVX = UV_FAVOR_VERY_BAD_FULL_X; // Default to Very Bad.
        // All full-color icons are in Row 1.

        if (!renderAsZeroFavor && !renderAsMaxFavor) { // Apply color logic only if not in special zero/max states.
            if (currentFavor >= 160) { // Very Good range (80% to 100%) - Corresponds to icons 9-10.
                currentFavorFillUVX = UV_FAVOR_VERY_GOOD_FULL_X;
            } else if (currentFavor >= 120) { // Good range (60% to 80%) - Corresponds to icons 7-8.
                currentFavorFillUVX = UV_FAVOR_GOOD_FULL_X;
            } else if (currentFavor >= 80) { // Neutral range (40% to 60%) - Corresponds to icons 5-6.
                currentFavorFillUVX = UV_FAVOR_NEUTRAL_FULL_X;
            } else if (currentFavor >= 40) { // Bad range (20% to 40%) - Corresponds to icons 3-4.
                currentFavorFillUVX = UV_FAVOR_BAD_FULL_X;
            }
        }

        // Loop to draw all 10 favor icons.
        for (int i = 0; i < 10; i++) {
            int drawX = favorBarX + (i * FAVOR_ICON_WIDTH); // Calculate X position for current icon.
            // Y position is constant for the row.

            // 1. Draw the base icon (background/empty state).
            int baseIconUVX;

            if (renderAsZeroFavor) {
                baseIconUVX = UV_FAVOR_ICON_EMPTY_ZERO_FAVOR_X; // Special icon for exactly zero favor.
            } else if (renderAsMaxFavor) {
                baseIconUVX = UV_FAVOR_MAX_X; // Special icon for maximum favor.
            } else {
                baseIconUVX = UV_FAVOR_EMPTY_DEFAULT_X; // Default empty state for partial fill.
            }

            guiGraphics.blit(
                    HUD_TEXTURE,          // Texture atlas.
                    drawX, favorBarY,         // Screen coordinates.
                    baseIconUVX, UV_FAVOR_ROW1_Y, // UV coordinates of the base icon.
                    FAVOR_ICON_WIDTH, FAVOR_ICON_HEIGHT, // Dimensions of the icon.
                    256, 256              // Texture sheet dimensions.
            );

            // 2. Draw the filled portion of the icon (only if not in special zero/max states).
            if (!renderAsZeroFavor && !renderAsMaxFavor) {
                float favorSegmentStart = i * FAVOR_PER_ICON; // The favor value at the start of this icon's segment.

                // If current favor is less than or equal to the start of this segment, there's no fill.
                if (currentFavor <= favorSegmentStart) {
                    continue; // Skip to the next icon.
                }

                // Calculate how much favor falls into this specific icon's segment (0 to FAVOR_PER_ICON).
                float favorInThisSegment = currentFavor - favorSegmentStart;
                if (favorInThisSegment > FAVOR_PER_ICON) {
                    favorInThisSegment = FAVOR_PER_ICON; // Cap at max value for a single segment.
                }

                // Calculate the filled height of the icon (from bottom to top).
                int filledHeight = (int)((favorInThisSegment / FAVOR_PER_ICON) * FAVOR_ICON_HEIGHT);

                // Calculate the screen Y position for drawing the filled portion (from bottom up).
                int fillDrawY = favorBarY + FAVOR_ICON_HEIGHT - filledHeight;

                // Calculate the UV_Y source position in the texture for the filled portion (also from bottom up).
                int uvYOrigin = UV_FAVOR_ROW1_Y + FAVOR_ICON_HEIGHT - filledHeight;

                guiGraphics.blit(
                        HUD_TEXTURE,          // Texture atlas.
                        drawX, fillDrawY,     // Screen coordinates for the filled part.
                        currentFavorFillUVX, uvYOrigin, // UV coordinates for the filled part's texture.
                        FAVOR_ICON_WIDTH, filledHeight, // Dimensions of the filled part.
                        256, 256              // Texture sheet dimensions.
                );
            }
        }

        // --- Draw Favor Bonus Multiplier Overlay ---
        // This indicates if there are active effects influencing favor gain/loss.
        float favorBonusMultiplier = PlayerStatsClient.getClientFavorBonusMultiplier();
        if (favorBonusMultiplier > 1.0f) { // Draw positive multiplier overlay if bonus is active.
            for (int i = 0; i < 10; i++) {
                int overlayDrawX = favorBarX + (i * FAVOR_ICON_WIDTH);
                guiGraphics.blit(
                        HUD_TEXTURE,
                        overlayDrawX, favorBarY,
                        UV_EFFECT_MULTIPLIER_POSITIVE_X, UV_FAVOR_ROW2_Y, // Overlays are in Row 2.
                        FAVOR_ICON_WIDTH, FAVOR_ICON_HEIGHT,
                        256, 256
                );
            }
        } else if (favorBonusMultiplier < 1.0f) { // Draw negative multiplier overlay if penalty is active.
            for (int i = 0; i < 10; i++) {
                int overlayDrawX = favorBarX + (i * FAVOR_ICON_WIDTH);
                guiGraphics.blit(
                        HUD_TEXTURE,
                        overlayDrawX, favorBarY,
                        UV_EFFECT_MULTIPLIER_NEGATIVE_X, UV_FAVOR_ROW2_Y, // Overlays are in Row 2.
                        FAVOR_ICON_WIDTH, FAVOR_ICON_HEIGHT,
                        256, 256
                );
            }
        }
    };

    // --- Helper Methods for Drawing Bars ---

    /**
     * Draws a single main stat bar (Health, Protection, Mana, Vigor).
     * This method abstracts away the repetitive drawing logic for the main bars,
     * including background, fill, limit strip, and overlay.
     *
     * @param guiGraphics  The GuiGraphics instance for drawing.
     * @param currentY     The current Y position on screen for this bar.
     * @param separadorX   The X position on screen for the separator element.
     * @param mainBarX     The X position on screen for the main bar elements.
     * @param uvFillY      The Y-coordinate on the texture atlas for the stat's fill texture.
     * @param currentValue The current value of the stat to display.
     * @param maxValue     The maximum value of the stat, used to calculate fill percentage.
     */
    private static void drawMainStatBar(GuiGraphics guiGraphics, int currentY,
                                        int separadorX, int mainBarX, int uvFillY, float currentValue, float maxValue) {
        // Calculate the fill percentage for the bar, safely handling division by zero.
        float percentage = maxValue > 0 ? currentValue / maxValue : 0.0f;
        int fillWidth = (int)(MAIN_BAR_W * percentage); // Determine the width of the filled portion.

        // Draw the Separator element to the left of the bar.
        guiGraphics.blit(HUD_TEXTURE, separadorX, currentY, UV_SEPARATOR_X, UV_SEPARATOR_Y, SEPARATOR_WIDTH, SEPARATOR_HEIGHT, 256, 256);

        // Draw the Background of the main stat bar.
        guiGraphics.blit(HUD_TEXTURE, mainBarX, currentY, UV_MAIN_BAR_BACKGROUND_X, UV_MAIN_BAR_BACKGROUND_Y, MAIN_STAT_BAR_W, MAIN_STAT_BAR_H, 256, 256);

        // Draw the Fill portion of the bar, representing the current value.
        // UV_HEALTH_FILL_X is used as the base X for all main bar fills, while uvFillY selects the specific stat's texture.
        guiGraphics.blit(HUD_TEXTURE, mainBarX, currentY, UV_HEALTH_FILL_X, uvFillY, fillWidth, MAIN_BAR_H, 256, 256);

        // Draw the Limit Strip if the bar has any fill, to visually indicate the current value's end.
        if (fillWidth > 0) {
            int limitStripX = mainBarX + fillWidth - LIMIT_STRIP_WIDTH; // Position it at the end of the fill.
            guiGraphics.blit(HUD_TEXTURE, limitStripX, currentY, UV_LIMIT_STRIP_X, UV_LIMIT_STRIP_Y, LIMIT_STRIP_WIDTH, LIMIT_STRIP_HEIGHT, 256, 256);
        }

        // Draw the Overlay layer for the main stat bar, always on top for decorative purposes.
        guiGraphics.blit(HUD_TEXTURE, mainBarX, currentY, UV_MAIN_BAR_OVERLAY_X, UV_MAIN_BAR_OVERLAY_Y, MAIN_STAT_BAR_W, MAIN_STAT_BAR_H, 256, 256);
    }

    /**
     * Draws the dedicated Innate Protection bar.
     * This method handles the drawing of its background, fill, limit strip, and overlay.
     *
     * @param guiGraphics The GuiGraphics instance for drawing.
     * @param x           The X position on screen for the bar.
     * @param y           The Y position on screen for the bar.
     * @param percentage  The fill percentage of the bar, representing current innate protection.
     */
    private static void drawInnateProtectionBar(GuiGraphics guiGraphics, int x, int y, float percentage) {
        // Draw the Background for the Innate Protection bar.
        guiGraphics.blit(HUD_TEXTURE, x, y, UV_IN_PROTECTION_BG_X, UV_IN_PROTECTION_BG_Y, INNATE_BAR_W, INNATE_BAR_H, 256, 256);

        // Draw the Fill for the Innate Protection bar.
        guiGraphics.blit(HUD_TEXTURE, x, y, UV_IN_PROTECTION_FILL_X, UV_IN_PROTECTION_FILL_Y, (int)(INNATE_BAR_W * percentage), INNATE_BAR_H, 256, 256);

        // Draw the Limit Strip for the Innate Protection bar if it has any fill.
        if ((int)(INNATE_BAR_W * percentage) > 0) {
            int limitStripX = x + (int)(INNATE_BAR_W * percentage) - LIMIT_STRIP_WIDTH;
            guiGraphics.blit(HUD_TEXTURE, limitStripX, y, UV_LIMIT_STRIP_X, UV_LIMIT_STRIP_Y, LIMIT_STRIP_WIDTH, LIMIT_STRIP_HEIGHT, 256, 256);
        }

        // Draw the Overlay for the Innate Protection bar.
        guiGraphics.blit(HUD_TEXTURE, x, y, UV_IN_PROTECTION_OVERLAY_X, UV_IN_PROTECTION_OVERLAY_Y, INNATE_BAR_W, INNATE_BAR_H, 256, 256);
    }

    /**
     * Helper method to draw a "no statistic" (static) bar.
     * This bar acts as a placeholder for dynamic bars that are currently hidden (e.g., if a player has no Mana).
     * It's always drawn as a full bar using a dedicated static texture.
     *
     * @param guiGraphics The GuiGraphics instance for drawing.
     * @param currentY    The current Y position for this bar.
     * @param separadorX  The X position for the separator.
     * @param mainBarX    The X position for the main bar elements.
     */
    private static void drawNoStatisticBar(GuiGraphics guiGraphics, int currentY, int separadorX, int mainBarX) {
        // Draw the Separator element, maintaining consistent visual alignment.
        guiGraphics.blit(
                HUD_TEXTURE,
                separadorX, currentY,
                UV_SEPARATOR_X, UV_SEPARATOR_Y,
                SEPARATOR_WIDTH, SEPARATOR_HEIGHT,
                256, 256
        );

        // Draw the static placeholder bar. Its texture is taken from UV_STATIC_FILL_Y,
        // which represents a permanently full bar.
        guiGraphics.blit(
                HUD_TEXTURE,
                mainBarX, currentY,
                UV_HEALTH_FILL_X, UV_STATIC_FILL_Y, // Use UV_HEALTH_FILL_X for consistent X positioning.
                MAIN_BAR_W, MAIN_BAR_H,
                256, 256
        );
    }

    // --- GUI Overlay Registration Event ---
    /**
     * Registers the custom HUD overlay with Forge's GUI system.
     * This ensures the HUD_OVERLAY lambda is correctly integrated and called by the rendering system
     * whenever GUI overlays are drawn. The "aboveAll" parameter ensures it's rendered on top.
     *
     * @param event The event for registering GUI overlays.
     */
    @SubscribeEvent
    public static void registerGuiOverlays(RegisterGuiOverlaysEvent event) {
        // Register the custom HUD overlay to be rendered above all other vanilla overlays.
        event.registerAboveAll("stats_bar", HUD_OVERLAY);
    }
}