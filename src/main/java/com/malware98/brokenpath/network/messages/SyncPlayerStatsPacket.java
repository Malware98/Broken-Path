package com.malware98.brokenpath.network.messages;

import com.malware98.brokenpath.client.PlayerStatsClient; // Necesario para actualizar los datos en el cliente
import net.minecraft.network.FriendlyByteBuf;
import net.minecraftforge.network.NetworkEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Supplier;

//Un paquete que se env√≠a del servidor al cliente para sincronizar todos los datos de PlayerStats.
public class SyncPlayerStatsPacket {
    private final int attributePoints;
    private final int constitution;
    private final int strength;
    private final int dexterity;
    private final int intelligence;
    private final float currentHealth;
    private final float maxHealth;
    private final float currentProtection;
    private final float maxProtection;
    private final float currentMana;
    private final float maxMana;
    private final float currentVigor;
    private final float maxVigor;
    private final float luck;
    private final String race;
    private final String playerClass;
    private final String specialization;
    private final int skillPoints;
    private final Map<String, Integer> professions;


    // Constructor: Usado por el servidor para crear el paquete con los datos actuales del jugador.
    public SyncPlayerStatsPacket(int attributePoints,
                                 int constitution, int strength, int dexterity, int intelligence,
                                 float currentHealth, float maxHealth,
                                 float currentProtection, float maxProtection,
                                 float currentMana, float maxMana,
                                 float currentVigor, float maxVigor,
                                 float luck,
                                 String race, String playerClass, String specialization, int skillPoints,
                                 Map<String, Integer> professions){
        this.attributePoints = attributePoints;
        this.constitution = constitution;
        this.strength = strength;
        this.dexterity = dexterity;
        this.intelligence = intelligence;
        this.currentHealth = currentHealth;
        this.maxHealth = maxHealth;
        this.currentProtection = currentProtection;
        this.maxProtection = maxProtection;
        this.currentMana = currentMana;
        this.maxMana = maxMana;
        this.currentVigor = currentVigor;
        this.maxVigor = maxVigor;
        this.luck = luck;
        this.race = race;
        this.playerClass = playerClass;
        this.specialization = specialization;
        this.skillPoints = skillPoints;
        this.professions = new HashMap<>(professions);
    }

    // Decoder: Usado por el cliente para leer los datos del paquete de la red.
    public SyncPlayerStatsPacket(FriendlyByteBuf buf) {
        this.attributePoints = buf.readInt();
        this.constitution = buf.readInt();
        this.strength = buf.readInt();
        this.dexterity = buf.readInt();
        this.intelligence = buf.readInt();
        this.currentHealth = buf.readFloat();
        this.maxHealth = buf.readFloat();
        this.currentProtection = buf.readFloat();
        this.maxProtection = buf.readFloat();
        this.currentMana = buf.readFloat();
        this.maxMana = buf.readFloat();
        this.currentVigor = buf.readFloat();
        this.maxVigor = buf.readFloat();
        this.luck = buf.readFloat();
        this.race = buf.readUtf();
        this.playerClass = buf.readUtf();
        this.specialization = buf.readUtf();
        this.skillPoints = buf.readInt();

        // Leer el mapa de profesiones
        this.professions = new HashMap<>();
        int professionCount = buf.readInt();
        for (int i = 0; i < professionCount; i++) {
            String name = buf.readUtf();
            int level = buf.readInt();
            this.professions.put(name, level);
        }

    }

    // Encoder: Usado por el servidor para escribir los datos del paquete para enviarlos por la red.
    public void toBytes(FriendlyByteBuf buf) {
        buf.writeInt(this.attributePoints);
        buf.writeInt(this.constitution);
        buf.writeInt(this.strength);
        buf.writeInt(this.dexterity);
        buf.writeInt(this.intelligence);
        buf.writeFloat(this.currentHealth);
        buf.writeFloat(this.maxHealth);
        buf.writeFloat(this.currentProtection);
        buf.writeFloat(this.maxProtection);
        buf.writeFloat(this.currentMana);
        buf.writeFloat(this.maxMana);
        buf.writeFloat(this.currentVigor);
        buf.writeFloat(this.maxVigor);
        buf.writeFloat(this.luck);
        buf.writeUtf(this.race);
        buf.writeUtf(this.playerClass);
        buf.writeUtf(this.specialization);
        buf.writeInt(this.skillPoints);

        // Escribir el mapa de profesiones
        buf.writeInt(this.professions.size());
        for (Map.Entry<String, Integer> entry : this.professions.entrySet()) {
            buf.writeUtf(entry.getKey());
            buf.writeInt(entry.getValue());
        }
    }

    // Handler: Usado por el cliente para procesar el paquete una vez que ha sido recibido y decodificado.
    public void handle(Supplier<NetworkEvent.Context> ctx) {
        ctx.get().enqueueWork(() -> {
            PlayerStatsClient.setAllStats(
                    this.attributePoints,
                    this.constitution, this.strength, this.dexterity, this.intelligence,
                    this.currentHealth, this.maxHealth,
                    this.currentProtection, this.maxProtection,
                    this.currentMana, this.maxMana,
                    this.currentVigor, this.maxVigor,
                    this.luck,
                    this.race,
                    this.playerClass,
                    this.specialization,
                    this.skillPoints,
                    this.professions
            );
        });
        ctx.get().setPacketHandled(true);
    }
}