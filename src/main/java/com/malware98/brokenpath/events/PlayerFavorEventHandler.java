// PlayerFavorEventHandler.java
package com.malware98.brokenpath.events;

import com.malware98.brokenpath.BrokenPath;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;
import com.malware98.brokenpath.data.config.FavorActionDataConfig; // NEW: Import FavorActionDataConfig
import com.malware98.brokenpath.data.config.VillagerTradeDataConfig;
import net.minecraft.core.BlockPos;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.effect.MobEffects;
import net.minecraft.world.entity.Entity;
import net.minecraft.world.entity.ai.village.poi.PoiManager;
import net.minecraft.world.entity.ai.village.poi.PoiTypes;
import net.minecraft.world.entity.animal.*;
import net.minecraft.world.entity.npc.Villager;
import net.minecraft.world.entity.npc.VillagerProfession;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.Items;
import net.minecraft.world.level.block.BedBlock;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.Blocks;
import net.minecraft.world.level.block.DoorBlock;
import net.minecraftforge.event.entity.living.AnimalTameEvent;
import net.minecraftforge.event.entity.living.LivingDamageEvent;
import net.minecraftforge.event.entity.living.LivingDeathEvent;
import net.minecraftforge.event.entity.living.MobEffectEvent;
import net.minecraftforge.event.entity.player.PlayerInteractEvent;
import net.minecraftforge.event.entity.player.TradeWithVillagerEvent;
import net.minecraftforge.event.level.BlockEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.registries.ForgeRegistries;

import java.util.Objects;

/**
 * // Handles events related to the player's Favor (Luck) system.
 * // This class listens for various Forge events to determine when the player
 * // should gain or lose Favor based on their interactions with entities and blocks.
 */
@Mod.EventBusSubscriber(modid = BrokenPath.MOD_ID, bus = Mod.EventBusSubscriber.Bus.FORGE)
public class PlayerFavorEventHandler {

    // // --- Favor Gain Methods ---

    /**
     * // Awards Favor to the player upon successfully taming an animal.
     * // Maps specific animal types to configurable favor modifiers.
     */
    @SubscribeEvent
    public static void onAnimalTamed(AnimalTameEvent event) {
        Player player = event.getTamer();
        // Only process on the server side and if a player is involved.
        if (player != null && !player.level().isClientSide()) {
            player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                ResourceLocation entityId = ForgeRegistries.ENTITY_TYPES.getKey(event.getAnimal().getType());
                if (entityId != null) {
                    String actionKey = "TAME_" + entityId.getPath().toUpperCase();
                    // Apply favor modification based on the configured action key.
                    float favorModifier = FavorActionDataConfig.getInstance().getFavorModifier(actionKey); // Use correct getter
                    if (favorModifier != 0.0f) { // Only apply if there's a non-zero modifier
                        playerStats.applyFavorModifier(actionKey);
                    }
                }
            });
        }
    }

    /**
     * // Awards Favor to the player for successfully feeding an animal.
     * // Checks if the fed animal and item match a predefined set of feedable animals.
     */
    @SubscribeEvent
    public static void onPlayerFeedAnimal(PlayerInteractEvent.EntityInteract event) {
        // Only process on the server side, with main hand interaction, and if the target is an animal.
        if (event.getTarget() instanceof Animal animal && event.getHand() == InteractionHand.MAIN_HAND && !event.getLevel().isClientSide()) {
            Player player = event.getEntity();
            ItemStack heldItem = player.getItemInHand(event.getHand());

            // Check if the animal was successfully fed with the correct item.
            if (isFedSuccessfully(animal, heldItem)) {
                player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                    ResourceLocation entityId = ForgeRegistries.ENTITY_TYPES.getKey(animal.getType());
                    if (entityId != null) {
                        String actionKey = "FEED_" + entityId.getPath().toUpperCase();
                        float favorModifier = FavorActionDataConfig.getInstance().getFavorModifier(actionKey); // Use correct getter
                        if (favorModifier != 0.0f) {
                            playerStats.applyFavorModifier(actionKey);
                        }
                    }
                });
            }
        }
    }


    /**
     * // Awards Favor to the player for trading with villagers and redirects XP gain to the mod's system.
     * // Favor gain varies by villager profession.
     */
    @SubscribeEvent
    public static void onVillagerTrade(TradeWithVillagerEvent event) {
        Entity traderEntity = event.getEntity();
        // Only process if the trader is a player and on the server side.
        if (traderEntity instanceof Player player && !player.level().isClientSide()) {
            if (event.getAbstractVillager() instanceof Villager villager) {
                player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                    VillagerTradeDataConfig tradeSettings = VillagerTradeDataConfig.getInstance(); // Use new config class

                    long currentTick = player.level().getGameTime();

                    // Check if player has exceeded max trades or is within cooldown period
                    boolean canGainFavor = false;
                    if (playerStats.getVillagerTradesSinceLastFavor() < tradeSettings.getMaxTradesBeforeCooldown()) { // Use new config
                        // If below max trades, allow favor gain
                        canGainFavor = true;
                    } else {
                        // If max trades reached, check if cooldown time has passed
                        long timeSinceLastFavorGain = currentTick - playerStats.getLastVillagerFavorGainTick();
                        if (timeSinceLastFavorGain >= tradeSettings.getTradeFavorCooldownTicks()) { // Use new config
                            // Cooldown passed, reset counter and allow favor gain
                            playerStats.setVillagerTradesSinceLastFavor(0);
                            canGainFavor = true;
                        }
                    }

                    if (canGainFavor) {
                        String actionKey;
                        VillagerProfession profession = villager.getVillagerData().getProfession();

                        // Determine the action key based on the villager's profession.
                        if (profession != VillagerProfession.NONE && profession != VillagerProfession.NITWIT) {
                            String professionName = Objects.requireNonNull(ForgeRegistries.VILLAGER_PROFESSIONS.getKey(profession)).getPath().toUpperCase();
                            actionKey = "TRADE_" + professionName;
                            // Fallback to a generic "TRADE_VILLAGER" if a specific profession key isn't configured.
                            if (FavorActionDataConfig.getInstance().getFavorModifier(actionKey) == 0.0f) { // Check if specific modifier exists
                                actionKey = "TRADE_VILLAGER";
                            }
                        } else {
                            actionKey = "TRADE_VILLAGER"; // For jobless or nitwit villagers.
                        }

                        // Apply favor modification if the action key exists and is non-zero.
                        float favorModifier = FavorActionDataConfig.getInstance().getFavorModifier(actionKey);
                        if (favorModifier != 0.0f) {
                            playerStats.applyFavorModifier(actionKey);
                            playerStats.setVillagerTradesSinceLastFavor(playerStats.getVillagerTradesSinceLastFavor() + 1); // Increment trade counter
                            playerStats.setLastVillagerFavorGainTick(currentTick); // Update last favor gain tick
                        }
                    } else {
                        // Optional: Send a message to the player indicating they are on cooldown
                        // player.sendSystemMessage(Component.translatable("message.brokenpath.favor_cooldown_villager_trade"));
                    }

                    // Award XP through the mod's custom XP system regardless of favor cooldown.
                    int experienceAmount = tradeSettings.getDefaultTradeXp(); // Use new config
                    player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(playerXP -> {
                        playerXP.addExperience(experienceAmount);
                    });
                });
            }
        }
    }

    /**
     * // Awards Favor to the player for repairing an Iron Golem.
     */
    @SubscribeEvent
    public static void onPlayerRepairGolem(PlayerInteractEvent.EntityInteract event) {
        // Only process on the server side with main hand interaction.
        if (event.getHand() == InteractionHand.MAIN_HAND && !event.getLevel().isClientSide()) {
            if (event.getTarget() instanceof IronGolem golem) {
                Player player = event.getEntity();
                ItemStack heldItem = player.getItemInHand(event.getHand());

                // Check if the player is using an iron ingot to repair a damaged golem.
                if (heldItem.getItem() == Items.IRON_INGOT) {
                    if (golem.getHealth() < golem.getMaxHealth()) {
                        player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                            String actionKey = "REPAIR_GOLEM";
                            float favorModifier = FavorActionDataConfig.getInstance().getFavorModifier(actionKey);
                            if (favorModifier != 0.0f) {
                                playerStats.applyFavorModifier(actionKey);
                            }
                        });
                    }
                }
            }
        }
    }

    /**
     * // Awards Favor when a player receives the "Hero of the Village" effect,
     * // indicating they defended a raid.
     */
    @SubscribeEvent
    public static void onHeroOfTheVillageApplied(MobEffectEvent.Added event) {
        // Ensure the effect is applied to a player and only on the server side.
        if (event.getEntity() instanceof Player player && !event.getEntity().level().isClientSide()) {
            // Check if the added effect is "Hero of the Village".
            if (event.getEffectInstance().getEffect() == MobEffects.HERO_OF_THE_VILLAGE) {
                player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                    String actionKey = "DEFEND_RAID";
                    float favorModifier = FavorActionDataConfig.getInstance().getFavorModifier(actionKey);
                    if (favorModifier != 0.0f) {
                        playerStats.applyFavorModifier(actionKey);
                        BrokenPath.LOGGER.debug("FavorEvent: Player {} received Hero of the Village effect. Applied favor modifier for '{}'.", player.getName().getString(), actionKey);
                    } else {
                        BrokenPath.LOGGER.debug("FavorEvent: Action key '{}' not found in FavorActionDataConfig or is zero. Skipping favor modifier for defending raid (Hero of the Village).", actionKey);
                    }
                });
            }
        }
    }

    // // --- Favor Loss Methods ---

    /**
     * // Causes Favor loss when a player kills certain entities (villagers, golems, or specific animals).
     */
    @SubscribeEvent
    public static void onLivingKilled(LivingDeathEvent event) {
        // Ensure the killer is a player and on the server side.
        if (event.getSource().getEntity() instanceof Player player && !event.getEntity().level().isClientSide()) {

            // Case 1: Killing a Villager.
            if (event.getEntity() instanceof Villager) {
                player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                    String actionKey = "KILL_VILLAGER";
                    float favorModifier = FavorActionDataConfig.getInstance().getFavorModifier(actionKey);
                    if (favorModifier != 0.0f) {
                        playerStats.applyFavorModifier(actionKey);
                    }
                });
            }
            // Case 2: Killing an Iron Golem or Snow Golem.
            else if (event.getEntity() instanceof IronGolem || event.getEntity() instanceof SnowGolem) {
                player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                    String actionKey = "KILL_GOLEM";
                    float favorModifier = FavorActionDataConfig.getInstance().getFavorModifier(actionKey);
                    if (favorModifier != 0.0f) {
                        playerStats.applyFavorModifier(actionKey);
                    }
                });
            }
            // Case 3: Killing animals that do not provide food upon death.
            else if (event.getEntity() instanceof Animal animal) {
                ResourceLocation entityId = ForgeRegistries.ENTITY_TYPES.getKey(animal.getType());
                if (entityId != null) {
                    String entityTypeName = entityId.getPath();
                    // Check if the animal is one that typically doesn't provide food (e.g., wolf, cat, horse).
                    boolean givesFood = animal instanceof Chicken || animal instanceof Cow ||
                            animal instanceof Pig || animal instanceof Sheep;

                    if (!givesFood) {
                        player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                            String actionKey = "KILL_" + entityTypeName.toUpperCase();
                            float favorModifier = FavorActionDataConfig.getInstance().getFavorModifier(actionKey);
                            if (favorModifier != 0.0f) {
                                playerStats.applyFavorModifier(actionKey);
                            }
                        });
                    }
                }
            }
        }
    }

    /**
     * // Causes Favor loss when a player damages a villager.
     * // Favor loss varies by villager profession.
     */
    @SubscribeEvent
    public static void onVillagerDamaged(LivingDamageEvent event) {
        // Ensure the attacker is a player and on the server side.
        if (event.getSource().getEntity() instanceof Player player && !event.getEntity().level().isClientSide()) {
            // Check if the damaged target is a Villager.
            if (event.getEntity() instanceof Villager villager) {
                player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                    String actionKey;
                    VillagerProfession profession = villager.getVillagerData().getProfession();

                    // Determine the action key based on the villager's profession.
                    if (profession != VillagerProfession.NONE && profession != VillagerProfession.NITWIT) {
                        String professionName = Objects.requireNonNull(ForgeRegistries.VILLAGER_PROFESSIONS.getKey(profession)).getPath().toUpperCase();
                        actionKey = "ATTACK_" + professionName;
                        // Fallback to a generic "ATTACK_VILLAGER" if a specific profession key isn't configured.
                        if (FavorActionDataConfig.getInstance().getFavorModifier(actionKey) == 0.0f) { // Check if specific modifier exists
                            actionKey = "ATTACK_VILLAGER";
                        }
                    } else {
                        actionKey = "ATTACK_VILLAGER";
                    }

                    // Apply favor modification if the action key exists and is non-zero.
                    float favorModifier = FavorActionDataConfig.getInstance().getFavorModifier(actionKey);
                    if (favorModifier != 0.0f) {
                        playerStats.applyFavorModifier(actionKey);
                    }
                });
            }
        }
    }

    /**
     * // Causes Favor loss when a player damages an Iron Golem or Snow Golem.
     */
    @SubscribeEvent
    public static void onGolemDamaged(LivingDamageEvent event) {
        // Ensure the attacker is a player and the target is a Golem (Iron or Snow).
        if (event.getSource().getEntity() instanceof Player player && !event.getEntity().level().isClientSide()) {
            if (event.getEntity() instanceof IronGolem || event.getEntity() instanceof SnowGolem) {
                player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                    String actionKey = "DAMAGE_GOLEM";
                    float favorModifier = FavorActionDataConfig.getInstance().getFavorModifier(actionKey);
                    if (favorModifier != 0.0f) {
                        playerStats.applyFavorModifier(actionKey);
                    }
                });
            }
        }
    }

    /**
     * // Causes Favor loss when a player shears a pumpkin off a Snow Golem.
     */
    @SubscribeEvent
    public static void onPlayerShearSnowGolemPumpkin(PlayerInteractEvent.EntityInteract event) {
        // Only process on the server side with main hand interaction.
        if (event.getHand() == InteractionHand.MAIN_HAND && !event.getLevel().isClientSide()) {
            if (event.getTarget() instanceof SnowGolem snowGolem) {
                Player player = event.getEntity();
                ItemStack heldItem = player.getItemInHand(event.getHand());

                // Check if the player is using shears and the snow golem has a pumpkin.
                if (heldItem.getItem() == Items.SHEARS && snowGolem.hasPumpkin()) {
                    player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                        String actionKey = "SHEAR_SNOW_GOLEM_PUMPKIN";
                        float favorModifier = FavorActionDataConfig.getInstance().getFavorModifier(actionKey);
                        if (favorModifier != 0.0f) {
                            playerStats.applyFavorModifier(actionKey);
                        }
                    });
                }
            }
        }
    }

    /**
     * // Causes Favor loss when a player breaks important village blocks within a village's proximity.
     */
    @SubscribeEvent
    public static void onBlockBrokenInVillage(BlockEvent.BreakEvent event) {
        Player player = event.getPlayer();
        // Only process if a player is involved and on the server side.
        if (player != null && !event.getLevel().isClientSide()) {
            ServerLevel serverLevel = (ServerLevel) event.getLevel();
            BlockPos brokenPos = event.getPos();
            Block brokenBlock = event.getState().getBlock();

            // Check if the broken block is near a Point of Interest (POI) of a village.
            // This is "why" we check for POIs within a radius, to identify village-related blocks.
            PoiManager poiManager = serverLevel.getPoiManager();
            boolean isNearVillagePoi = poiManager.getInRange(poiType ->
                                    // Check if the POI is a home or a villager profession block.
                                    poiType.is(PoiTypes.HOME) || poiType.is(PoiTypes.ARMORER) ||
                                            poiType.is(PoiTypes.BUTCHER) || poiType.is(PoiTypes.CARTOGRAPHER) ||
                                            poiType.is(PoiTypes.CLERIC) || poiType.is(PoiTypes.FARMER) ||
                                            poiType.is(PoiTypes.FISHERMAN) || poiType.is(PoiTypes.FLETCHER) ||
                                            poiType.is(PoiTypes.LEATHERWORKER) || poiType.is(PoiTypes.LIBRARIAN) ||
                                            poiType.is(PoiTypes.MASON) || poiType.is(PoiTypes.SHEPHERD) ||
                                            poiType.is(PoiTypes.TOOLSMITH) || poiType.is(PoiTypes.WEAPONSMITH),
                            brokenPos, 32, PoiManager.Occupancy.ANY)
                    .findAny()
                    .isPresent();

            if (isNearVillagePoi) {
                // Define important blocks that cause favor loss if broken in a village.
                boolean isImportantBlock =
                        brokenBlock instanceof BedBlock || brokenBlock instanceof DoorBlock ||
                                Objects.equals(brokenBlock, Blocks.COMPOSTER) || Objects.equals(brokenBlock, Blocks.BARREL) ||
                                Objects.equals(brokenBlock, Blocks.SMOKER) || Objects.equals(brokenBlock, Blocks.BLAST_FURNACE) ||
                                Objects.equals(brokenBlock, Blocks.LECTERN) || Objects.equals(brokenBlock, Blocks.CAULDRON) ||
                                Objects.equals(brokenBlock, Blocks.GRINDSTONE) || Objects.equals(brokenBlock, Blocks.LOOM) ||
                                Objects.equals(brokenBlock, Blocks.SMITHING_TABLE) || Objects.equals(brokenBlock, Blocks.CARTOGRAPHY_TABLE) ||
                                Objects.equals(brokenBlock, Blocks.FLETCHING_TABLE) || Objects.equals(brokenBlock, Blocks.BELL) ||
                                Objects.equals(brokenBlock, Blocks.DARK_OAK_DOOR) || Objects.equals(brokenBlock, Blocks.ACACIA_DOOR) ||
                                Objects.equals(brokenBlock, Blocks.BIRCH_DOOR) || Objects.equals(brokenBlock, Blocks.OAK_DOOR) ||
                                Objects.equals(brokenBlock, Blocks.SPRUCE_DOOR) || Objects.equals(brokenBlock, Blocks.JUNGLE_DOOR) ||
                                Objects.equals(brokenBlock, Blocks.BOOKSHELF) || Objects.equals(brokenBlock, Blocks.STONECUTTER);

                if (isImportantBlock) {
                    player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                        String actionKey = "DESTROY_VILLAGE_BLOCK";
                        float favorModifier = FavorActionDataConfig.getInstance().getFavorModifier(actionKey);
                        if (favorModifier != 0.0f) {
                            playerStats.applyFavorModifier(actionKey);
                        }
                    });
                }
            }
        }
    }

    // // --- Helper Methods ---

    /**
     * // Checks if an animal was successfully fed with its specific correct item.
     *
     * @param animal   The animal entity.
     * @param heldItem The item held by the player.
     * @return True if the animal was fed with the correct item, false otherwise.
     */
    private static boolean isFedSuccessfully(Animal animal, ItemStack heldItem) {
        return animal.isFood(heldItem) && !animal.isInLove() && animal.getAge() == 0;
    }
}