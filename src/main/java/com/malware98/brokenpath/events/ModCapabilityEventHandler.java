// ModCapabilityEventHandler.java
package com.malware98.brokenpath.events;

import com.malware98.brokenpath.BrokenPath;
import com.malware98.brokenpath.capabilities.PlayerCapabilityProvider;
import com.malware98.brokenpath.capabilities.PlayerXPCapabilityProvider;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;
import com.malware98.brokenpath.data.config.MainModConfigManager;
import com.malware98.brokenpath.data.config.XpDataConfig;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.entity.Entity;
import net.minecraft.world.entity.player.Player;
import net.minecraftforge.event.AttachCapabilitiesEvent;
import net.minecraftforge.event.entity.player.PlayerEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

import java.util.Optional;

/**
 * // Handles events related to custom player capabilities in "BrokenPath".
 * // This class is responsible for attaching player capabilities (PlayerStats and PlayerXP)
 * // to player entities and managing data transfer upon death or dimension changes.
 */
@Mod.EventBusSubscriber(modid = BrokenPath.MOD_ID, bus = Mod.EventBusSubscriber.Bus.FORGE)
public class ModCapabilityEventHandler {

    /**
     * // Attaches custom capabilities to player entities.
     * // This ensures that every player has the necessary data storage for mod features.
     * @param event The AttachCapabilitiesEvent for an Entity.
     */
    @SubscribeEvent
    public static void onAttachCapabilitiesEntity(AttachCapabilitiesEvent<Entity> event) {
        // Only attach capabilities to Player entities.
        if (event.getObject() instanceof Player player) {
            // Attach PlayerStats capability if not already present.
            if (!player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).isPresent()) {
                event.addCapability(new ResourceLocation(BrokenPath.MOD_ID, "player_stats"), new PlayerCapabilityProvider(player));
            }
            // Attach PlayerXP capability if not already present.
            // Use ModCapabilities.PLAYER_XP_CAPABILITY directly
            if (!player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).isPresent()) {
                event.addCapability(new ResourceLocation(BrokenPath.MOD_ID, "player_xp"), new PlayerXPCapabilityProvider(player));
            }
        }
    }

    /**
     * // Handles player cloning events, such as respawning after death or changing dimensions.
     * // This is crucial for persisting player data across these events.
     * @param event The PlayerEvent.Clone event.
     */
    @SubscribeEvent
    public static void onPlayerClone(PlayerEvent.Clone event) {
        // Ensure this logic only runs on the logical server side.
        if (!event.getEntity().level().isClientSide()) {
            Player newPlayer = event.getEntity(); // The player being created/respawned.
            Player originalPlayer = event.getOriginal(); // The player before death/dimension change.

            // // --- Handle Player Death (data transfer with penalties) ---
            if (event.isWasDeath()) {
                // Revive capabilities of the original player to read their data.
                // This is necessary because capabilities are typically invalidated on death.
                originalPlayer.reviveCaps();

                // Transfer PlayerXP data:
                originalPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(oldXP -> {
                    newPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(newXP -> {
                        // Serialize and deserialize NBT to ensure a deep copy of data.
                        CompoundTag xpNBT = oldXP.serializeNBT();
                        newXP.deserializeNBT(xpNBT); // deserializeNBT handles internal syncing.

                        // Apply death penalty for XP if the player is not at max level.
                        if (newXP.getLevel() < MainModConfigManager.getInstance().maxLevel) {
                            XpDataConfig xpConfigs = XpDataConfig.getInstance();
                            float penaltyPercentage = xpConfigs.getXpLossPercentageOnDeath();
                            float maxDebtPercentage = xpConfigs.getXpMaxDebtPercentage();

                            // Calculate potential XP to determine penalty scale.
                            int xpPotencial = xpConfigs.getXpNeededForNextLevel(newXP.getLevel());
                            // Fallback for level 1 or if XP for next level is 0.
                            if (xpPotencial == 0 && newXP.getLevel() < MainModConfigManager.getInstance().maxLevel) {
                                xpPotencial = 1000; // Default fallback XP.
                            }

                            int basePenalty = (int) (xpPotencial * penaltyPercentage);
                            int maxAllowedDebt = (int) (xpPotencial * maxDebtPercentage);

                            // Only apply penalty if current debt is below the max allowed debt.
                            if (newXP.getXPDebt() < maxAllowedDebt) {
                                newXP.setXPDebt(newXP.getXPDebt() + basePenalty); // Add to debt from the penalty.
                                // Clamp XP debt to the maximum allowed.
                                if (newXP.getXPDebt() > maxAllowedDebt) {
                                    newXP.setXPDebt(maxAllowedDebt);
                                }
                            }
                        }
                    });
                });

                // Transfer PlayerStats data:
                originalPlayer.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(oldStats -> {
                    newPlayer.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(newStats -> {
                        // Serialize and deserialize NBT for a deep copy.
                        CompoundTag statsNBT = oldStats.serializeNBT();
                        newStats.deserializeNBT(statsNBT);
                        // Recalculate and apply stats immediately after deserialization on death.
                        // This ensures the new player's vanilla health and attributes reflect the mod's stats quickly.
                        PlayerStatEventHandler.recalculateAndApplyStats(newPlayer);
                    });
                });

                // Invalidate capabilities of the original player after copying to release resources.
                originalPlayer.invalidateCaps();

            } else { // // --- Handle Dimension Change (direct data copy) ---
                // For dimension changes, capabilities are directly copied without penalties.
                originalPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(oldXP -> {
                    newPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(newXP -> {
                        newXP.copyFrom(oldXP);
                    });
                });

                originalPlayer.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(oldStats -> {
                    newPlayer.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(newStats -> {
                        newStats.copyFrom(oldStats);
                    });
                });
            }
        }
    }
}
