package com.malware98.brokenpath.events;

import com.malware98.brokenpath.BrokenPath;
import com.malware98.brokenpath.calculation.StatCalculator;
import com.malware98.brokenpath.capabilities.IPlayerXP;
import com.malware98.brokenpath.capabilities.PlayerStats;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;
import com.malware98.brokenpath.data.config.AttributeConfig;
import com.malware98.brokenpath.data.config.CombatDataConfig;
import com.malware98.brokenpath.data.config.MainModConfigManager;
import com.malware98.brokenpath.data.config.RegenDataConfig;
import com.malware98.brokenpath.data.ModDamageTypeTags;
import com.malware98.brokenpath.util.CapabilityUtils;
import com.malware98.brokenpath.util.ModArmorStats;
import net.minecraft.network.chat.Component;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.damagesource.DamageSource;
import net.minecraft.world.effect.MobEffects;
import net.minecraft.world.entity.EquipmentSlot;
import net.minecraft.world.entity.ai.attributes.AttributeInstance;
import net.minecraft.world.entity.ai.attributes.AttributeModifier;
import net.minecraft.world.entity.ai.attributes.Attributes;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.food.FoodData;
import net.minecraft.world.item.ArmorItem;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.GameRules;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.api.distmarker.OnlyIn;
import net.minecraftforge.event.ItemAttributeModifierEvent;
import net.minecraftforge.event.TickEvent;
import net.minecraftforge.event.entity.living.*;
import net.minecraftforge.event.entity.player.ItemTooltipEvent;
import net.minecraftforge.event.entity.player.PlayerEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.UUID;
import java.util.ArrayList;

/**
 * Handles player statistics, including health, mana, vigor, protection, and hunger.
 * Manages custom damage mitigation, armor attributes, and tooltips.
 */
@Mod.EventBusSubscriber(modid = BrokenPath.MOD_ID, bus = Mod.EventBusSubscriber.Bus.FORGE)
public class PlayerStatEventHandler {

    // --- UUIDs for Attribute Modifiers ---
    // UUID for nullifying vanilla armor attributes.
    private static final UUID VANILLA_ARMOR_NULLIFIER_UUID = UUID.fromString("f8b7a6c5-4d3e-2b1a-9c8d-7e6f5a4b3c2d");
    // UUID for nullifying vanilla armor toughness attributes.
    private static final UUID VANILLA_TOUGHNESS_NULLIFIER_UUID = UUID.fromString("e9f8d7c6-b5a4-1c2d-3e4f-5f6a7b8c9d0e");
    // UUID for Max Health modifiers.
    private static final UUID CUSTOM_MAX_HEALTH_MODIFIER_UUID = UUID.fromString("1a2b3c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d");

    // Map to track the last game tick when starvation damage was applied.
    private static final Map<UUID, Long> lastStarveDamageTick = new java.util.HashMap<>();

    // --- Player Event Listeners ---
    @SubscribeEvent // Subscribes to PlayerLoggedInEvent
    public static void onPlayerLoggedIn(PlayerEvent.PlayerLoggedInEvent event) {
        if (!event.getEntity().level().isClientSide()) {
            ServerPlayer serverPlayer = (ServerPlayer) event.getEntity();

            CapabilityUtils.ifPlayerStatsPresent(serverPlayer, stats -> {
                if (stats.getRace().isEmpty() || stats.getRace().equals("SPIRIT")) {
                    stats.setRace("SPIRIT");
                }
            });

            serverPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(IPlayerXP::sync);
            recalculateAndApplyStats(serverPlayer);
            serverPlayer.server.getGameRules().getRule(GameRules.RULE_NATURAL_REGENERATION).set(false, serverPlayer.server);
            lastStarveDamageTick.remove(serverPlayer.getUUID());
        }
    }

    @SubscribeEvent // Subscribes to PlayerLoggedOutEvent
    public static void onPlayerLoggedOut(PlayerEvent.PlayerLoggedOutEvent event) {
        if (!event.getEntity().level().isClientSide()) {
            UUID playerUUID = event.getEntity().getUUID();
            PlayerStats.removePlayerConsumptionState(playerUUID);
            lastStarveDamageTick.remove(playerUUID);
        }
    }

    @SubscribeEvent // Subscribes to PlayerEvent.Clone
    public static void onPlayerClone(PlayerEvent.Clone event) {
        if (!event.getEntity().level().isClientSide()) {
            event.getOriginal().getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(oldStats -> {
                event.getEntity().getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(newStats -> {
                    newStats.copyFrom(oldStats);
                });
            });

            event.getOriginal().getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(oldXP -> {
                event.getEntity().getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(newXP -> {
                    newXP.copyFrom(oldXP);
                });
            });
        }
    }

    @SubscribeEvent // Subscribes to PlayerRespawnEvent
    public static void onPlayerRespawn(PlayerEvent.PlayerRespawnEvent event) {
        if (!event.getEntity().level().isClientSide()) {
            ServerPlayer serverPlayer = (ServerPlayer) event.getEntity();

            CapabilityUtils.ifPlayerStatsPresent(serverPlayer, stats -> {
                stats.setCurrentHealth(stats.getMaxHealth());
                stats.setCurrentMana(stats.getMaxMana());
                stats.setCurrentVigor(stats.getMaxVigor());
                stats.setHungerStage(0);
                serverPlayer.setHealth(stats.getMaxHealth());
            });

            serverPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(IPlayerXP::sync);
            recalculateAndApplyStats(serverPlayer);
            lastStarveDamageTick.remove(serverPlayer.getUUID());
        }
    }

    @SubscribeEvent // Subscribes to LivingAttackEvent
    public static void onLivingAttack(LivingAttackEvent event) {
        if (event.getEntity() instanceof Player player && !player.level().isClientSide()) {
            CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
                stats.enterCombat(player.level().getGameTime());
            });
        }
        if (event.getSource().getEntity() instanceof Player player && !player.level().isClientSide()) {
            CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
                stats.enterCombat(player.level().getGameTime());
            });
        }
    }

    @SubscribeEvent // Subscribes to LivingEvent.LivingTickEvent
    public static void onLivingTick(LivingEvent.LivingTickEvent event) {
        if (event.getEntity() instanceof Player player && !player.level().isClientSide()) {
            long currentTick = player.level().getGameTime();
            FoodData foodStats = player.getFoodData();
            int foodLevel = foodStats.getFoodLevel();

            // Nullify Vanilla Armor and Armor_Toughness.
            AttributeInstance armorAttribute = player.getAttribute(Attributes.ARMOR);
            if (armorAttribute != null && armorAttribute.getValue() != 0.0) {
                armorAttribute.removeModifier(VANILLA_ARMOR_NULLIFIER_UUID);
                armorAttribute.addPermanentModifier(new AttributeModifier(
                        VANILLA_ARMOR_NULLIFIER_UUID, "BrokenPath Armor Reset",
                        -armorAttribute.getValue(), AttributeModifier.Operation.ADDITION));
            }
            AttributeInstance armorToughnessAttribute = player.getAttribute(Attributes.ARMOR_TOUGHNESS);
            if (armorToughnessAttribute != null && armorToughnessAttribute.getValue() != 0.0) {
                armorToughnessAttribute.removeModifier(VANILLA_TOUGHNESS_NULLIFIER_UUID);
                armorToughnessAttribute.addPermanentModifier(new AttributeModifier(
                        VANILLA_TOUGHNESS_NULLIFIER_UUID, "BrokenPath Toughness Reset",
                        -armorToughnessAttribute.getValue(), AttributeModifier.Operation.ADDITION));
            }

            CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
                // Synchronize Vanilla Health with Mod's Health.
                AttributeInstance maxHealthAttribute = player.getAttribute(Attributes.MAX_HEALTH);
                if (maxHealthAttribute != null && maxHealthAttribute.getBaseValue() != playerStats.getMaxHealth()) {
                    maxHealthAttribute.removeModifier(CUSTOM_MAX_HEALTH_MODIFIER_UUID);
                    maxHealthAttribute.setBaseValue(playerStats.getMaxHealth());
                    player.setHealth(Math.min(player.getHealth(), playerStats.getMaxHealth()));
                }
                if (playerStats.getCurrentHealth() != player.getHealth()) {
                    playerStats.setCurrentHealth(player.getHealth(), true);
                }

                // Handle Chimera Chaotic Transformation State.
                if ("CHIMERA".equalsIgnoreCase(playerStats.getRace())) {
                    playerStats.handleChaoticTransformationTick(currentTick);
                }

                player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(playerXP -> {
                    int intelligence = playerStats.getIntelligence();
                    int dexterity = playerStats.getDexterity();
                    int constitution = playerStats.getConstitution();

                    boolean inCombat = playerStats.isInCombat(currentTick);
                    long lastCombatExitTick = playerStats.getLastCombatExitTick();

                    // Hunger Drain and Penalty Logic.
                    int newHungerStage = 0;
                    if (foodLevel <= 0) newHungerStage = 3;
                    else if (foodLevel >= 2 && foodLevel <= 5) newHungerStage = 2;
                    else if (foodLevel >= 6 && foodLevel <= 15) newHungerStage = 1;
                    playerStats.setHungerStage(newHungerStage);

                    // Starvation damage logic.
                    float starvingDamageAmount = RegenDataConfig.getInstance().getStarvingDamageAmount();
                    int starvingDamageIntervalTicks = RegenDataConfig.getInstance().getStarvingDamageIntervalTicks();
                    if (newHungerStage == 3) {
                        Long lastDamage = lastStarveDamageTick.get(player.getUUID());
                        if (lastDamage == null || (currentTick - lastDamage >= starvingDamageIntervalTicks)) {
                            player.hurt(player.damageSources().starve(), starvingDamageAmount);
                            lastStarveDamageTick.put(player.getUUID(), currentTick);
                        }
                    }

                    // Apply passive hunger exhaustion penalty.
                    float passiveExhaustionToAdd = 0.0f;
                    switch (newHungerStage) {
                        case 1: passiveExhaustionToAdd = RegenDataConfig.getInstance().getHungryModeratePassiveExhaustionPerTick(); break;
                        case 2: passiveExhaustionToAdd = RegenDataConfig.getInstance().getHungryIntensePassiveExhaustionPerTick(); break;
                        case 3: passiveExhaustionToAdd = RegenDataConfig.getInstance().getStarvingPassiveExhaustionPerTick(); break;
                    }
                    if (passiveExhaustionToAdd > 0) foodStats.addExhaustion(passiveExhaustionToAdd);

                    // Mana Regeneration Logic.
                    float currentMana = playerStats.getCurrentMana();
                    float maxMana = playerStats.getMaxMana();
                    float manaRegenRatePerTick = StatCalculator.calculateManaRegenPerTick(intelligence, inCombat);
                    float hungerManaRegenPenalty = (newHungerStage == 2) ? 0.85f : (newHungerStage == 3) ? 0.0f : 1.0f;
                    float actualManaRegenRatePerTick = manaRegenRatePerTick * hungerManaRegenPenalty;
                    boolean isConsumingMana = playerStats.isManaBeingConsumed();
                    int baseRegenPulseCooldownTicks = RegenDataConfig.getInstance().getBaseRegenPulseCooldownTicks();
                    int manaDelayAfterCombatTicks = RegenDataConfig.getInstance().getManaDelayAfterCombatTicks();
                    boolean canRegenMana = !isConsumingMana && currentMana < maxMana &&
                            (!inCombat || (currentTick - lastCombatExitTick >= manaDelayAfterCombatTicks));

                    if (baseRegenPulseCooldownTicks > 0 && player.tickCount % baseRegenPulseCooldownTicks == 0) {
                        if (canRegenMana && actualManaRegenRatePerTick > 0) {
                            float amountToHeal = actualManaRegenRatePerTick * baseRegenPulseCooldownTicks;
                            playerStats.setCurrentMana(currentMana + amountToHeal);
                        }
                    }

                    // Vigor Regeneration Logic.
                    float currentVigor = playerStats.getCurrentVigor();
                    float maxVigor = playerStats.getMaxVigor();
                    float vigorRegenRatePerTick = StatCalculator.calculateVigorRegenPerTick(dexterity, inCombat);
                    float hungerVigorRegenPenalty = 1.0f;
                    if (newHungerStage == 1) hungerVigorRegenPenalty = 1.0f + RegenDataConfig.getInstance().getHungryModerateVigorRegenPenalty();
                    else if (newHungerStage == 2) hungerVigorRegenPenalty = 1.0f + RegenDataConfig.getInstance().getHungryIntenseVigorRegenPenalty();
                    else if (newHungerStage == 3) hungerVigorRegenPenalty = 1.0f + RegenDataConfig.getInstance().getStarvingVigorRegenPenalty();
                    hungerVigorRegenPenalty = Math.max(0.0f, hungerVigorRegenPenalty);
                    float actualVigorRegenRatePerTick = vigorRegenRatePerTick * hungerVigorRegenPenalty;
                    boolean isConsumingVigor = playerStats.isVigorBeingConsumed();
                    int vigorDelayAfterCombatTicks = RegenDataConfig.getInstance().getVigorDelayAfterCombatTicks();
                    boolean canRegenVigor = !isConsumingVigor && currentVigor < maxVigor &&
                            (!inCombat || (currentTick - lastCombatExitTick >= vigorDelayAfterCombatTicks));

                    if (baseRegenPulseCooldownTicks > 0 && player.tickCount % baseRegenPulseCooldownTicks == 0) {
                        if (canRegenVigor && actualVigorRegenRatePerTick > 0) {
                            float amountToHeal = actualVigorRegenRatePerTick * baseRegenPulseCooldownTicks;
                            playerStats.setCurrentVigor(currentVigor + amountToHeal);
                        }
                    }

                    // Slow Health Regeneration Logic (Mod Controlled).
                    int healthMinFoodLevelForRegen = RegenDataConfig.getInstance().getHealthMinFoodLevelForRegen();
                    int healthDelayAfterCombatTicks = RegenDataConfig.getInstance().getHealthDelayAfterCombatTicks();
                    int effectiveHealthCooldown = StatCalculator.calculateHealthRegenCooldown(
                            constitution, playerStats.getRegenSpeedBonusTicks(), inCombat, lastCombatExitTick, currentTick);
                    boolean canRegenHealth = newHungerStage != 3 && foodStats.getFoodLevel() >= healthMinFoodLevelForRegen &&
                            playerStats.getCurrentHealth() < playerStats.getMaxHealth() && !inCombat &&
                            (currentTick - lastCombatExitTick >= healthDelayAfterCombatTicks);

                    if (player.tickCount % effectiveHealthCooldown == 0 && canRegenHealth) {
                        float healthRegenAmountPerConPoint = RegenDataConfig.getInstance().getHealthRegenAmountPerConPoint();
                        float healthAmountToHealPerPulse = RegenDataConfig.getInstance().getHealthAmountToHealPerPulse();
                        float healthRegenRatePerTick = healthAmountToHealPerPulse + ((constitution * healthRegenAmountPerConPoint) / baseRegenPulseCooldownTicks);

                        float totalAmountToHeal = healthRegenRatePerTick * effectiveHealthCooldown;

                        playerStats.setCurrentHealth(playerStats.getCurrentHealth() + totalAmountToHeal);

                        // Hunger Consumption scaling with CON.
                        float baseHungerCost = RegenDataConfig.getInstance().getBaseHungerConsumptionPerHealthRegenPulse();
                        float hungerConsumptionPerConPointScaling = RegenDataConfig.getInstance().getHungerConsumptionPerConPointScaling();
                        float maxHungerConsumptionPerPulse = RegenDataConfig.getInstance().getMaxHungerConsumptionPerPulse();
                        float conScaledHungerCost = baseHungerCost + (constitution * hungerConsumptionPerConPointScaling);
                        float finalHungerCost = Math.min(conScaledHungerCost, maxHungerConsumptionPerPulse);
                        foodStats.addExhaustion(finalHungerCost);
                    }

                    // Innate Protection Regeneration Logic.
                    float currentInnateProtection = playerStats.getCurrentInnateProtection();
                    float maxInnateProtection = playerStats.getMaxInnateProtection();
                    float innateProtectionAmountPerPulse = RegenDataConfig.getInstance().getInnateProtectionAmountPerPulse();
                    int innateProtectionDelayAfterCombatTicks = RegenDataConfig.getInstance().getInnateProtectionDelayAfterCombatTicks();
                    boolean canRegenInnateProtection = currentInnateProtection < maxInnateProtection &&
                            playerStats.getCurrentHealth() == playerStats.getMaxHealth() && newHungerStage != 3 &&
                            (!inCombat || (currentTick - lastCombatExitTick >= innateProtectionDelayAfterCombatTicks));

                    if (baseRegenPulseCooldownTicks > 0 && player.tickCount % baseRegenPulseCooldownTicks == 0 && canRegenInnateProtection) {
                        playerStats.restoreInnateProtection(innateProtectionAmountPerPulse);
                    }
                });
            });
        }
    }

    @SubscribeEvent // Subscribes to TickEvent.PlayerTickEvent
    public static void onPlayerTick(TickEvent.PlayerTickEvent event) {
        if (event.phase == TickEvent.Phase.END && !event.player.level().isClientSide()) {
            Player player = event.player;
            // Force vanilla player experience to zero.
            player.experienceLevel = 0;
            player.experienceProgress = 0.0f;
            player.totalExperience = 0;
        }
    }

    @SubscribeEvent // Subscribes to LivingDamageEvent
    public static void onLivingDamage(LivingDamageEvent event) {
        if (event.getEntity() instanceof Player player && !player.level().isClientSide()) {
            CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
                DamageSource source = event.getSource();
                float incomingDamage = event.getAmount();
                float currentProtectionSTRBased = stats.getCurrentProtection();
                float currentInnateProtection = stats.getCurrentInnateProtection();
                float damageToApplyToHealth = 0.0f;

                if (source.is(ModDamageTypeTags.IGNORES_PROTECTION)) {
                    damageToApplyToHealth = incomingDamage;
                } else {
                    float penetratingDamage = 0.0f;
                    float nonPenetratingDamage = incomingDamage;
                    float damagePenetrationPercentage = CombatDataConfig.getInstance().getDamagePenetrationPercentage();
                    if (source.is(ModDamageTypeTags.IS_PENETRATING)) {
                        penetratingDamage = incomingDamage * damagePenetrationPercentage;
                        nonPenetratingDamage = incomingDamage - penetratingDamage;
                        damageToApplyToHealth += penetratingDamage;
                    }

                    float damageAfterSTRProtection = nonPenetratingDamage;
                    if (currentProtectionSTRBased > 0) {
                        float absorbedBySTRProtection = Math.min(nonPenetratingDamage, currentProtectionSTRBased);
                        stats.setCurrentProtection(currentProtectionSTRBased - absorbedBySTRProtection);
                        damageAfterSTRProtection = nonPenetratingDamage - absorbedBySTRProtection;
                    }

                    float damageAfterInnateProtection = damageAfterSTRProtection;
                    if (damageAfterInnateProtection > 0 && currentInnateProtection > 0) {
                        float absorbedByInnateProtection = Math.min(damageAfterInnateProtection, currentInnateProtection);
                        stats.setCurrentInnateProtection(currentInnateProtection - absorbedByInnateProtection);
                        damageAfterInnateProtection = damageAfterInnateProtection - absorbedByInnateProtection;
                    }
                    damageToApplyToHealth += damageAfterInnateProtection;
                }
                event.setAmount(damageToApplyToHealth);
            });
        }
    }

    @SubscribeEvent // Subscribes to ItemAttributeModifierEvent
    public static void onItemAttributeModification(ItemAttributeModifierEvent event) {
        // Handled in onLivingTick for consistent suppression.
    }

    @SubscribeEvent // Subscribes to LivingEquipmentChangeEvent
    public static void onLivingEquipmentChange(LivingEquipmentChangeEvent event) {
        if (event.getEntity() instanceof Player player) {
            player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                float totalProtectionFromEquippedArmor = calculateEquippedArmorProtection(player);
                float finalCurrentProtection = Math.min(totalProtectionFromEquippedArmor, playerStats.getMaxProtection());
                playerStats.setCurrentProtection(finalCurrentProtection);
            });
        }
    }

    @OnlyIn(Dist.CLIENT)
    @SubscribeEvent // Subscribes to ItemTooltipEvent
    public static void onTooltip(ItemTooltipEvent event) {
        ItemStack stack = event.getItemStack();
        List<Component> tooltip = event.getToolTip();

        if (stack.getItem() instanceof ArmorItem armorItem) {
            List<Component> newTooltip = new ArrayList<>();
            int insertionIndex = -1;

            for (int i = 0; i < tooltip.size(); i++) {
                Component component = tooltip.get(i);
                String text = component.getString().trim().toLowerCase(Locale.ROOT);
                if (text.startsWith("when in ") || text.startsWith("when on ") ||
                        text.contains("armor") || text.contains("armadura") ||
                        text.contains("toughness") || text.contains("dureza")) {
                    continue;
                }
                if (insertionIndex == -1) {
                    if (text.contains("combat") || text.contains("combate")) insertionIndex = i + 1;
                    else if (text.contains("durability") || text.contains("durabilidad") ||
                            text.contains("unbreakable") || text.contains("inrompible")) insertionIndex = i;
                }
                newTooltip.add(component);
            }

            if (insertionIndex == -1) insertionIndex = newTooltip.size();

            float itemProtectionValue = ModArmorStats.getProtectionValue(armorItem);

            newTooltip.add(insertionIndex, Component.empty());
            newTooltip.add(insertionIndex + 1, Component.literal("ยง9BrokenPath Protection: " + (int)itemProtectionValue));

            tooltip.clear();
            tooltip.addAll(newTooltip);
        }
    }

    @SubscribeEvent // Subscribes to LivingHealEvent
    public static void onLivingHeal(LivingHealEvent event) {
        if (event.getEntity() instanceof Player player) {
            if (player.hasEffect(MobEffects.REGENERATION)) {
                float regenEffectHealingBonusMultiplier = RegenDataConfig.getInstance().getRegenEffectHealingBonusMultiplier();
                event.setAmount(event.getAmount() * regenEffectHealingBonusMultiplier);
            }
        }
    }

    // --- Core Stat Recalculation ---
    /**
     * Recalculates and applies all primary player statistics to the vanilla player attributes.
     */
    public static void recalculateAndApplyStats(Player player) {
        CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
            stats.recalculateStats();

            AttributeInstance maxHealthAttribute = player.getAttribute(Attributes.MAX_HEALTH);
            if (maxHealthAttribute != null) {
                maxHealthAttribute.removeModifier(CUSTOM_MAX_HEALTH_MODIFIER_UUID);
                maxHealthAttribute.setBaseValue(stats.getMaxHealth());
            }

            player.setHealth(stats.getCurrentHealth());
            stats.setCurrentHealth(player.getHealth(), false);
        });
    }

    // --- Helper Routines ---
    /**
     * Calculates the total Protection value provided by all equipped armor pieces.
     */
    private static float calculateEquippedArmorProtection(Player player) {
        float equippedProtection = 0;
        for (EquipmentSlot slot : EquipmentSlot.values()) {
            if (slot.getType() == EquipmentSlot.Type.ARMOR) {
                ItemStack equippedStack = player.getItemBySlot(slot);
                if (!equippedStack.isEmpty() && equippedStack.getItem() instanceof ArmorItem armorItem) {
                    equippedProtection += ModArmorStats.getProtectionValue(armorItem);
                }
            }
        }
        return equippedProtection;
    }
}