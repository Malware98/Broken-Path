package com.malware98.brokenpath.events;

import com.malware98.brokenpath.BrokenPath;
import com.malware98.brokenpath.calculation.StatCalculator;
import com.malware98.brokenpath.capabilities.IPlayerXP;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;
import com.malware98.brokenpath.data.ModConfigs;
import com.malware98.brokenpath.data.ModDamageTypeTags;
import com.malware98.brokenpath.network.PacketHandler;
import com.malware98.brokenpath.network.messages.SyncPlayerStatsPacket;
import com.malware98.brokenpath.util.CapabilityUtils;
import com.malware98.brokenpath.util.ModArmorStats;
import net.minecraft.network.chat.Component;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.damagesource.DamageSource;
import net.minecraft.world.effect.MobEffects;
import net.minecraft.world.entity.EquipmentSlot;
import net.minecraft.world.entity.ai.attributes.AttributeInstance;
import net.minecraft.world.entity.ai.attributes.AttributeModifier;
import net.minecraft.world.entity.ai.attributes.Attributes;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.food.FoodData;
import net.minecraft.world.item.ArmorItem;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.GameRules;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.api.distmarker.OnlyIn;
import net.minecraftforge.event.ItemAttributeModifierEvent;
import net.minecraftforge.event.entity.living.*;
import net.minecraftforge.event.entity.player.ItemTooltipEvent;
import net.minecraftforge.event.entity.player.PlayerEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Mod.EventBusSubscriber(modid = BrokenPath.MOD_ID, bus = Mod.EventBusSubscriber.Bus.FORGE)
public class PlayerStatEventHandler {

    // UUID para los modificadores que anulan los atributos vanilla
    private static final UUID VANILLA_ARMOR_NULLIFIER_UUID = UUID.fromString("f8b7a6c5-4d3e-2b1a-9c8d-7e6f5a4b3c2d");
    private static final UUID VANILLA_TOUGHNESS_NULLIFIER_UUID = UUID.fromString("e9f8d7c6-b5a4-1c2d-3e4f-5f6a7b8c9d0e");

    // UUID para modificadores de penalización de hambre
    private static final UUID HUNGER_MOVEMENT_MODIFIER_UUID = UUID.fromString("2d5e6a7b-8c9d-1e0f-2a3b-4c5d6e7f8a9b");
    private static final UUID HUNGER_VIGOR_REGEN_MODIFIER_UUID = UUID.fromString("3c4d5e6f-7a8b-9c0d-1e2f-3a4b5c6d7e8f");

    private static final java.util.Map<UUID, Long> lastVigorExhaustionTick = new java.util.HashMap<>();
    private static final java.util.Map<UUID, Long> lastStarveDamageTick = new java.util.HashMap<>();

    // Sincroniza las estadísticas del jugador al iniciar sesión y ajusta las reglas de juego para la regeneración.
    @SubscribeEvent
    public static void onPlayerLoggedIn(PlayerEvent.PlayerLoggedInEvent event) {
        if (!event.getEntity().level().isClientSide()) {
            CapabilityUtils.ifPlayerStatsPresent(event.getEntity(), data -> {
                recalculateAndApplyStats(event.getEntity());
                data.sync();
            });

            if (event.getEntity() instanceof ServerPlayer serverPlayer) {
                serverPlayer.server.getGameRules().getRule(GameRules.RULE_NATURAL_REGENERATION).set(false, serverPlayer.server);
            }
            lastVigorExhaustionTick.remove(event.getEntity().getUUID());
            lastStarveDamageTick.remove(event.getEntity().getUUID());
        }
    }

    // Restaura las estadísticas del jugador al reaparecer y recalcula la protección.
    @SubscribeEvent
    public static void onPlayerRespawn(PlayerEvent.PlayerRespawnEvent event) {
        if (!event.getEntity().level().isClientSide()) {
            event.getEntity().setHealth(event.getEntity().getMaxHealth());

            recalculateAndApplyStats(event.getEntity());

            CapabilityUtils.ifPlayerStatsPresent(event.getEntity(), stats -> {
                stats.setCurrentHealth(stats.getMaxHealth());
                stats.setCurrentMana(stats.getMaxMana());
                stats.setCurrentVigor(stats.getMaxVigor());
                stats.setHungerStage(0);

                int level = getPlayerLevel(event.getEntity());

                float protectionFromEquippedArmor = calculateEquippedArmorProtection(event.getEntity());
                float maxSTRProtection = StatCalculator.calculateProtectionFromSTR(stats.getRace(), stats.getPlayerClass(), stats.getStrength());
                stats.setCurrentProtection(Math.min(protectionFromEquippedArmor, maxSTRProtection));

                stats.sync();
            });

            lastVigorExhaustionTick.remove(event.getEntity().getUUID());
            lastStarveDamageTick.remove(event.getEntity().getUUID());
        }
    }

    // Marca a los jugadores que infligen o reciben daño como "en combate".
    @SubscribeEvent
    public static void onLivingAttack(LivingAttackEvent event) {
        if (event.getEntity() instanceof Player player && !player.level().isClientSide()) {
            CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
                stats.enterCombat(player.level().getGameTime()); // Marca al jugador como en combate
            });
        }

        if (event.getSource().getEntity() instanceof Player player && !player.level().isClientSide()) {
            CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
                stats.enterCombat(player.level().getGameTime());
            });
        }
    }

    // Recalcula y actualiza las estadísticas principales del jugador basándose en su raza, clase, atributos y nivel.
    @SubscribeEvent
    public static void onLivingTick(LivingEvent.LivingTickEvent event) {
        if (event.getEntity() instanceof Player player && !player.level().isClientSide()) {

            long currentTick = player.level().getGameTime();
            ModConfigs configs = ModConfigs.getInstance();
            FoodData foodStats = player.getFoodData();
            int foodLevel = foodStats.getFoodLevel();

            CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
                player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(playerXP -> {
                    int intelligence = playerStats.getIntelligence();
                    int dexterity = playerStats.getDexterity();
                    int constitution = playerStats.getConstitution();

                    boolean inCombat = playerStats.isInCombat(currentTick);
                    long lastCombatExitTick = playerStats.getLastCombatExitTick();

                    // --- LÓGICA DE DRENAJE Y PENALIZACIONES DE HAMBRE (SIN MOB_EFFECTS) ---
                    int oldHungerStage = playerStats.getHungerStage();
                    int newHungerStage = 0; // 0 = Normal/Saturado

                    if (foodLevel <= 0) {
                        newHungerStage = 3; // Famélico (0 muslos)
                    } else if (foodLevel >= 1 && foodLevel <= 2) {
                        newHungerStage = 2; // Hambre Intensa (1-2 muslos)
                    } else if (foodLevel >= 3 && foodLevel <= 7) {
                        newHungerStage = 1; // Hambre Moderada (3-7 muslos)
                    }

                    // --- APLICACIÓN DE PENALIZACIONES DE HAMBRE ---
                    AttributeInstance movementSpeed = player.getAttribute(Attributes.MOVEMENT_SPEED);
                    AttributeInstance vigorRegen = player.getAttribute(Attributes.JUMP_STRENGTH); // Usamos Jump_Strength como marcador para la regeneración de vigor, puedes cambiarlo si tienes un atributo personalizado para ello.

                    // Remover modificadores de hambre existentes antes de aplicar los nuevos
                    if (movementSpeed != null) {
                        movementSpeed.removeModifier(HUNGER_MOVEMENT_MODIFIER_UUID);
                    }
                    if (vigorRegen != null) {
                        vigorRegen.removeModifier(HUNGER_VIGOR_REGEN_MODIFIER_UUID);
                    }


                    if (newHungerStage == 1) { // Hambre Moderada
                        if (movementSpeed != null) {
                            movementSpeed.addTransientModifier(new AttributeModifier(
                                    HUNGER_MOVEMENT_MODIFIER_UUID,
                                    "Hunger Movement Penalty (Moderate)",
                                    configs.getHungryModerateMovementSpeedPenalty(), // Configura este valor en ModConfigs
                                    AttributeModifier.Operation.MULTIPLY_TOTAL // Multiplicar el valor total (reducción porcentual)
                            ));
                        }
                        if (vigorRegen != null) {
                            vigorRegen.addTransientModifier(new AttributeModifier(
                                    HUNGER_VIGOR_REGEN_MODIFIER_UUID,
                                    "Hunger Vigor Regen Penalty (Moderate)",
                                    configs.getHungryModerateVigorRegenPenalty(), // Configura este valor en ModConfigs
                                    AttributeModifier.Operation.MULTIPLY_TOTAL
                            ));
                        }
                    } else if (newHungerStage == 2) { // Hambre Intensa
                        if (movementSpeed != null) {
                            movementSpeed.addTransientModifier(new AttributeModifier(
                                    HUNGER_MOVEMENT_MODIFIER_UUID,
                                    "Hunger Movement Penalty (Intense)",
                                    configs.getHungryIntenseMovementSpeedPenalty(), // Configura este valor en ModConfigs
                                    AttributeModifier.Operation.MULTIPLY_TOTAL
                            ));
                        }
                        if (vigorRegen != null) {
                            vigorRegen.addTransientModifier(new AttributeModifier(
                                    HUNGER_VIGOR_REGEN_MODIFIER_UUID,
                                    "Hunger Vigor Regen Penalty (Intense)",
                                    configs.getHungryIntenseVigorRegenPenalty(), // Configura este valor en ModConfigs
                                    AttributeModifier.Operation.MULTIPLY_TOTAL
                            ));
                        }
                    } else if (newHungerStage == 3) { // Famélico
                        if (movementSpeed != null) {
                            movementSpeed.addTransientModifier(new AttributeModifier(
                                    HUNGER_MOVEMENT_MODIFIER_UUID,
                                    "Hunger Movement Penalty (Starving)",
                                    configs.getStarvingMovementSpeedPenalty(), // Configura este valor en ModConfigs
                                    AttributeModifier.Operation.MULTIPLY_TOTAL
                            ));
                        }
                        if (vigorRegen != null) {
                            vigorRegen.addTransientModifier(new AttributeModifier(
                                    HUNGER_VIGOR_REGEN_MODIFIER_UUID,
                                    "Hunger Vigor Regen Penalty (Starving)",
                                    configs.getStarvingVigorRegenPenalty(), // Configura este valor en ModConfigs
                                    AttributeModifier.Operation.MULTIPLY_TOTAL
                            ));
                        }

                        //LÓGICA DE DAÑO POR INANICIÓN
                        Long lastDamage = lastStarveDamageTick.get(player.getUUID());
                        int starveDamageInterval = configs.getStarvingDamageIntervalTicks(); // Configura esto en ModConfigs

                        if (lastDamage == null || (currentTick - lastDamage >= starveDamageInterval)) {
                            player.hurt(player.damageSources().starve(), configs.getStarvingDamageAmount()); // Configura esto en ModConfigs
                            lastStarveDamageTick.put(player.getUUID(), currentTick);
                        }
                    }

                    // Regeneración de Maná
                    float currentMana = playerStats.getCurrentMana();
                    float maxMana = playerStats.getMaxMana();
                    float manaRegenRate = StatCalculator.calculateManaRegenPerTick(intelligence, inCombat);

                    if (currentMana < maxMana) {
                        float newMana = Math.min(currentMana + manaRegenRate, maxMana);
                        if (newMana != currentMana) {
                            playerStats.setCurrentMana(newMana);
                        }
                    }

                    // Regeneración de Vigor
                    float currentVigor = playerStats.getCurrentVigor();
                    float maxVigor = playerStats.getMaxVigor();
                    float vigorRegenRate = StatCalculator.calculateVigorRegenPerTick(dexterity, inCombat);

                    // Lógica de agotamiento de Vigor (cooldown si llegó a 0)
                    Long lastExhaustion = lastVigorExhaustionTick.get(player.getUUID());
                    boolean isInExhaustionCooldown = false;

                    if (currentVigor <= 0.001f) {
                        if (lastExhaustion == null) {
                            lastVigorExhaustionTick.put(player.getUUID(), currentTick);
                            isInExhaustionCooldown = true;
                        } else if (currentTick - lastExhaustion < configs.getVigorExhaustionCooldownTicks()) {
                            isInExhaustionCooldown = true;
                        } else {
                            lastVigorExhaustionTick.remove(player.getUUID());
                        }
                    } else {
                        if (lastExhaustion != null) {
                            lastVigorExhaustionTick.remove(player.getUUID());
                        }
                    }

                    if (isInExhaustionCooldown) {
                        // No regenerar si está en cooldown de agotamiento
                    } else if (currentVigor < maxVigor) {
                        float newVigor = Math.min(currentVigor + vigorRegenRate, maxVigor);
                        if (newVigor != currentVigor) {
                            playerStats.setCurrentVigor(newVigor);
                        }
                    }

                    // Regeneración Lenta de Salud
                    int effectiveHealthCooldown = StatCalculator.calculateHealthRegenCooldown(
                            constitution,
                            playerStats.getRegenSpeedBonusTicks(),
                            inCombat,
                            lastCombatExitTick,
                            currentTick
                    );

                    // Condición de regeneración de salud base:
                    // La lógica para la detención por estar famélico se agregará al integrar hungerStage.
                    boolean canRegenHealth = newHungerStage != 3 && // No famélico
                            foodStats.getFoodLevel() >= configs.getHealthMinFoodLevelForRegen() &&
                            player.getHealth() < player.getMaxHealth() &&
                            !inCombat &&
                            (currentTick - lastCombatExitTick >= configs.getHealthDelayAfterCombatTicks());

                    if (player.tickCount % effectiveHealthCooldown == 0 && canRegenHealth) {
                        player.heal(configs.getHealthAmountToHealPerPulse());
                        foodStats.addExhaustion(configs.getHealthExhaustionCostPerHealPulse());
                    }
                });

                playerStats.sync(); // Sincroniza las estadísticas del jugador
            });
        }
    }


    //Procedimiento de utilidad para obtener el nivel del jugador desde IPlayerXP
    public static int getPlayerLevel(Player player) {
        return player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY)
                .map(IPlayerXP::getLevel)
                .orElse(1); // Default a 1 si la capacidad no está presente
    }


    //Recalcula y aplica las estadísticas al jugador
    public static void recalculateAndApplyStats(Player player) {
        CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
            int level = getPlayerLevel(player);

            String race = stats.getRace();
            String className = stats.getPlayerClass();
            int con = stats.getConstitution();
            int str = stats.getStrength();
            int dex = stats.getDexterity();
            int intel = stats.getIntelligence();

            float newMaxHealth = StatCalculator.calculateHealth(race, className, con);
            float newMaxMana = StatCalculator.calculateMana(race, className, intel);
            float newMaxVigor = StatCalculator.calculateVigor(race, className, dex);
            float newMaxProtection = StatCalculator.calculateProtectionFromSTR(race, className, str);

            stats.setMaxHealth(newMaxHealth);
            stats.setMaxMana(newMaxMana);
            stats.setMaxVigor(newMaxVigor);
            stats.setMaxProtection(newMaxProtection);

            player.setHealth(Math.min(player.getHealth(), newMaxHealth));
        });
    }

    // Este evento se dispara justo ANTES de que el daño se aplique a la entidad.
    @SubscribeEvent
    public static void onLivingDamage(LivingDamageEvent event) {
        if (event.getEntity() instanceof Player player && !player.level().isClientSide()) {
            CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
                DamageSource source = event.getSource();
                float incomingDamage = event.getAmount();
                float currentProtectionSTRBased = stats.getCurrentProtection();

                int level = getPlayerLevel(player);

                float innateProtection = StatCalculator.calculateInnateProtection(stats.getRace(), level);

                float damageToApplyToHealth = 0.0f;

                if (source.is(ModDamageTypeTags.IGNORES_PROTECTION)) {
                    damageToApplyToHealth = incomingDamage;
                } else {
                    float penetratingDamage = 0.0f;
                    float nonPenetratingDamage = incomingDamage;

                    if (source.is(ModDamageTypeTags.IS_PENETRATING)) {
                        float penetrationPercentage = 0.25f;
                        penetratingDamage = incomingDamage * penetrationPercentage;
                        nonPenetratingDamage = incomingDamage - penetratingDamage;
                        damageToApplyToHealth += penetratingDamage;
                    }

                    float damageAfterSTRProtection = nonPenetratingDamage;
                    if (currentProtectionSTRBased > 0) {
                        float absorbedBySTRProtection = Math.min(nonPenetratingDamage, currentProtectionSTRBased);
                        stats.setCurrentProtection(currentProtectionSTRBased - absorbedBySTRProtection);
                        damageAfterSTRProtection = nonPenetratingDamage - absorbedBySTRProtection;
                    }

                    float damageAfterInnateProtection = damageAfterSTRProtection;
                    if (innateProtection > 0) {
                        float absorbedByInnateProtection = Math.min(damageAfterSTRProtection, innateProtection);
                        damageAfterInnateProtection = damageAfterSTRProtection - absorbedByInnateProtection;
                    }

                    damageToApplyToHealth += damageAfterInnateProtection;
                }

                event.setAmount(damageToApplyToHealth);
                stats.sync();
            });
        }
    }

    //Procedimiento para manejar los atributos de la armadura
    @SubscribeEvent
    public static void onItemAttributeModification(ItemAttributeModifierEvent event) {
        if (event.getItemStack().getItem() instanceof ArmorItem armorItem) {
            EquipmentSlot armorSlot = armorItem.getType().getSlot();

            if (event.getSlotType() == armorSlot) {
                float vanillaDefenseValue = armorItem.getDefense();
                float vanillaToughnessValue = armorItem.getToughness();

                event.addModifier(Attributes.ARMOR, new AttributeModifier(
                        VANILLA_ARMOR_NULLIFIER_UUID,
                        "BrokenPath Vanilla Armor Nullifier",
                        -vanillaDefenseValue,
                        AttributeModifier.Operation.ADDITION
                ));

                event.addModifier(Attributes.ARMOR_TOUGHNESS, new AttributeModifier(
                        VANILLA_TOUGHNESS_NULLIFIER_UUID,
                        "BrokenPath Vanilla Armor Toughness Nullifier",
                        -vanillaToughnessValue,
                        AttributeModifier.Operation.ADDITION
                ));
            }
        }
    }

    //Procedimiento para controlar el uso y desuso de armadura
    @SubscribeEvent
    public static void onLivingEquipmentChange(LivingEquipmentChangeEvent event) {
        if (event.getEntity() instanceof Player player) {
            player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                String raceName = playerStats.getRace();
                String className = playerStats.getPlayerClass();
                int str = playerStats.getStrength();

                int level = getPlayerLevel(player);

                float maxProtectionSTRBased = StatCalculator.calculateProtectionFromSTR(raceName, className, str);

                float totalProtectionFromEquippedArmor = calculateEquippedArmorProtection(player);

                float finalCurrentProtection = Math.min(totalProtectionFromEquippedArmor, maxProtectionSTRBased);

                playerStats.setCurrentProtection(finalCurrentProtection);
                playerStats.setMaxProtection(maxProtectionSTRBased);

                if (!player.level().isClientSide && player instanceof ServerPlayer serverPlayer) {
                    PacketHandler.sendToPlayer(new SyncPlayerStatsPacket(
                            playerStats.getAttributePoints(),
                            playerStats.getConstitution(), playerStats.getStrength(), playerStats.getDexterity(), playerStats.getIntelligence(),
                            playerStats.getCurrentHealth(), playerStats.getMaxHealth(),
                            playerStats.getCurrentProtection(), playerStats.getMaxProtection(),
                            playerStats.getCurrentMana(), playerStats.getMaxMana(),
                            playerStats.getCurrentVigor(), playerStats.getMaxVigor(),
                            playerStats.getLuck(),
                            playerStats.getRace(), playerStats.getPlayerClass(), playerStats.getSpecialization(), playerStats.getSkillPoints(),
                            playerStats.getProfessions(),
                            playerStats.getHungerStage()
                    ), serverPlayer);
                }
            });
        }
    }

    //Configuración personalizada para el Tooltip de armaduras
    @OnlyIn(Dist.CLIENT)
    @SubscribeEvent
    public static void onTooltip(ItemTooltipEvent event) {
        ItemStack stack = event.getItemStack();
        List<Component> tooltip = event.getToolTip();

        if (stack.getItem() instanceof ArmorItem armorItem) {
            List<Component> newTooltip = new ArrayList<>();
            int insertionIndex = -1;

            for (int i = 0; i < tooltip.size(); i++) {
                Component component = tooltip.get(i);
                String text = component.getString().trim().toLowerCase();

                if (text.startsWith("when in ") || text.startsWith("when on ")) {
                    continue;
                }

                if (text.contains("armor") || text.contains("armadura") ||
                        text.contains("toughness") || text.contains("dureza")) {
                    continue;
                }

                if (insertionIndex == -1) {
                    if (text.contains("combat") || text.contains("combate")) {
                        insertionIndex = i + 1;
                    } else if (text.contains("durability") || text.contains("durabilidad") ||
                            text.contains("unbreakable") || text.contains("inrompible")) {
                        insertionIndex = i;
                    }
                }

                newTooltip.add(component);
            }

            if (insertionIndex == -1) {
                insertionIndex = newTooltip.size();
            }

            float itemProtectionValue = ModArmorStats.getProtectionValue(armorItem);

            newTooltip.add(insertionIndex, Component.empty());
            newTooltip.add(insertionIndex + 1, Component.literal("§9Protección BrokenPath: " + (int)itemProtectionValue));

            tooltip.clear();
            tooltip.addAll(newTooltip);
        }
    }


    // Este procedimiento normalmente se llamaría desde tu UI personalizada o desde un comando que gestione
    public static void onPlayerSpendAttributePoints(Player player, String attributeName, int amount) {
        CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
            boolean success = stats.spendAttributePoints(attributeName, amount);
            if (success) {
                recalculateAndApplyStats(player);
            }
        });
    }

    // Calcula la protección total proporcionada por la armadura actualmente equipada por el jugador.
    private static float calculateEquippedArmorProtection(Player player) {
        float equippedProtection = 0;
        for (EquipmentSlot slot : EquipmentSlot.values()) {
            if (slot.getType() == EquipmentSlot.Type.ARMOR) {
                ItemStack equippedStack = player.getItemBySlot(slot);
                if (!equippedStack.isEmpty() && equippedStack.getItem() instanceof ArmorItem armorItem) {
                    equippedProtection += ModArmorStats.getProtectionValue(armorItem);
                }
            }
        }
        return equippedProtection;
    }

    //Este procedimiento asume que el sistema de XP lo llama cuando un jugador sube de nivel.
    public static void onPlayerGainedLevel(Player player, int newLevel) {
        CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
            int attributePointsGained = ModConfigs.getInstance().getAttributePointsForLevelRange(newLevel);
            if (attributePointsGained > 0) {
                stats.addAttributePoints(attributePointsGained); // Add points to player's available pool
                }
            recalculateAndApplyStats(player);
        });
    }

    //Procedimiento que maneja la regeneración de vida
    @SubscribeEvent
    public static void onLivingHeal(LivingHealEvent event) {
        if (event.getEntity() instanceof Player player) {

            // Comprueba si el jugador tiene actualmente el efecto de poción de Regeneración
            if (player.hasEffect(MobEffects.REGENERATION)) {
                float regenEffectReductionMultiplier = 0.8F; // Ajusta este valor según el balance que desees

                // Aplica el multiplicador a la cantidad de curación
                event.setAmount(event.getAmount() * regenEffectReductionMultiplier);
            }
        }
    }
}


