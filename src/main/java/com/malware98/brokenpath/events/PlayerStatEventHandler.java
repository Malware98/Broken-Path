package com.malware98.brokenpath.events;

import com.malware98.brokenpath.BrokenPath;
import com.malware98.brokenpath.calculation.StatCalculator;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;
import com.malware98.brokenpath.data.ModConfigs;
import com.malware98.brokenpath.data.ModDamageTypeTags;
import com.malware98.brokenpath.util.CapabilityUtils;
import com.malware98.brokenpath.util.ModArmorStats;
import net.minecraft.network.chat.Component;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.damagesource.DamageSource;
import net.minecraft.world.effect.MobEffects;
import net.minecraft.world.entity.EquipmentSlot;
import net.minecraft.world.entity.ai.attributes.AttributeInstance;
import net.minecraft.world.entity.ai.attributes.AttributeModifier;
import net.minecraft.world.entity.ai.attributes.Attributes;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.food.FoodData;
import net.minecraft.world.item.ArmorItem;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.GameRules;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.api.distmarker.OnlyIn;
import net.minecraftforge.event.ItemAttributeModifierEvent;
import net.minecraftforge.event.TickEvent;
import net.minecraftforge.event.entity.living.*;
import net.minecraftforge.event.entity.player.ItemTooltipEvent;
import net.minecraftforge.event.entity.player.PlayerEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

import java.util.*;

/*
 * Clase para manejar eventos relacionados con las estadísticas del jugador.
 * Incluye lógica para la sincronización, regeneración, daño, y manipulación de atributos.
 */
@Mod.EventBusSubscriber(modid = BrokenPath.MOD_ID, bus = Mod.EventBusSubscriber.Bus.FORGE)
public class PlayerStatEventHandler {

    // --- UUIDs para modificadores de atributos ---
    // UUID para los modificadores que anulan los atributos vanilla de armadura.
    private static final UUID VANILLA_ARMOR_NULLIFIER_UUID = UUID.fromString("f8b7a6c5-4d3e-2b1a-9c8d-7e6f5a4b3c2d");
    private static final UUID VANILLA_TOUGHNESS_NULLIFIER_UUID = UUID.fromString("e9f8d7c6-b5a4-1c2d-3e4f-5f6a7b8c9d0e");

    // UUID para modificadores de Salud Máxima (usado para establecer el valor base del atributo vanilla).
    private static final UUID CUSTOM_MAX_HEALTH_MODIFIER_UUID = UUID.fromString("1a2b3c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d");

    // Mapa para rastrear el último tick en el que se aplicó daño por inanición a un jugador.
    private static final Map<UUID, Long> lastStarveDamageTick = new java.util.HashMap<>();

    // --- Oyentes de eventos de jugador ---

    // Sincroniza las estadísticas del jugador al iniciar sesión en el servidor y ajusta las reglas de juego para la regeneración.
    @SubscribeEvent
    public static void onPlayerLoggedIn(PlayerEvent.PlayerLoggedInEvent event) {
        if (!event.getEntity().level().isClientSide()) {
            CapabilityUtils.ifPlayerStatsPresent(event.getEntity(), data -> {
                // Llama al proceso que recalcula y sincroniza las estadísticas.
                recalculateAndApplyStats(event.getEntity());
            });

            // Asegura que la regeneración natural de Minecraft esté deshabilitada en el servidor.
            if (event.getEntity() instanceof ServerPlayer serverPlayer) {
                serverPlayer.server.getGameRules().getRule(GameRules.RULE_NATURAL_REGENERATION).set(false, serverPlayer.server);
            }
            // Remueve el registro de daño por inanición para el jugador al iniciar sesión.
            lastStarveDamageTick.remove(event.getEntity().getUUID());
        }
    }

    // Restaura las estadísticas del jugador al reaparecer y recalcula la protección.
    @SubscribeEvent
    public static void onPlayerRespawn(PlayerEvent.PlayerRespawnEvent event) {
        if (!event.getEntity().level().isClientSide()) {
            // Recalcula y aplica todas las estadísticas del jugador.
            recalculateAndApplyStats(event.getEntity());

            CapabilityUtils.ifPlayerStatsPresent(event.getEntity(), stats -> {
                // Restaura los valores actuales a sus máximos y reinicia la etapa de hambre.
                stats.setCurrentHealth(stats.getMaxHealth());
                stats.setCurrentMana(stats.getMaxMana());
                stats.setCurrentVigor(stats.getMaxVigor());
                stats.setHungerStage(0);

                // Reinicia la Protección Innata al máximo al reaparecer.
                stats.setCurrentInnateProtection(stats.getMaxInnateProtection());

                // Recalcula la protección basada en la armadura equipada y la Fuerza (STR).
                float protectionFromEquippedArmor = calculateEquippedArmorProtection(event.getEntity());
                float maxSTRProtection = StatCalculator.calculateProtectionFromSTR(stats.getRace(), stats.getPlayerClass(), stats.getStrength());
                // Establece la protección actual al mínimo entre la armadura equipada y la protección máxima por STR.
                stats.setCurrentProtection(Math.min(protectionFromEquippedArmor, maxSTRProtection));
            });
            // Remueve el registro de daño por inanición para el jugador al reaparecer.
            lastStarveDamageTick.remove(event.getEntity().getUUID());
        }
    }

    // Marca a los jugadores que infligen o reciben daño como "en combate".
    @SubscribeEvent
    public static void onLivingAttack(LivingAttackEvent event) {
        // Marca al jugador que recibe el ataque como en combate.
        if (event.getEntity() instanceof Player player && !player.level().isClientSide()) {
            CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
                stats.enterCombat(player.level().getGameTime());
            });
        }

        // Marca al jugador que causa el ataque como en combate.
        if (event.getSource().getEntity() instanceof Player player && !player.level().isClientSide()) {
            CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
                stats.enterCombat(player.level().getGameTime());
            });
        }
    }

    // Recalcula y actualiza las estadísticas principales del jugador en cada tick.
    @SubscribeEvent
    public static void onLivingTick(LivingEvent.LivingTickEvent event) {
        if (event.getEntity() instanceof Player player && !player.level().isClientSide()) {

            long currentTick = player.level().getGameTime();
            ModConfigs configs = ModConfigs.getInstance();
            FoodData foodStats = player.getFoodData();
            int foodLevel = foodStats.getFoodLevel();

            // --- Lógica: Forzar Armor y Armor_Toughness a cero ---
            // Esto asegura que el sistema de Protección del mod sea el único en efecto.
            AttributeInstance armorAttribute = player.getAttribute(Attributes.ARMOR);
            if (armorAttribute != null && armorAttribute.getValue() != 0.0) {
                armorAttribute.removeModifier(VANILLA_ARMOR_NULLIFIER_UUID);
                armorAttribute.addPermanentModifier(new AttributeModifier(
                        VANILLA_ARMOR_NULLIFIER_UUID,
                        "BrokenPath Armor Reset",
                        -armorAttribute.getValue(),
                        AttributeModifier.Operation.ADDITION
                ));
            }

            AttributeInstance armorToughnessAttribute = player.getAttribute(Attributes.ARMOR_TOUGHNESS);
            if (armorToughnessAttribute != null && armorToughnessAttribute.getValue() != 0.0) {
                armorToughnessAttribute.removeModifier(VANILLA_TOUGHNESS_NULLIFIER_UUID);
                armorToughnessAttribute.addPermanentModifier(new AttributeModifier(
                        VANILLA_TOUGHNESS_NULLIFIER_UUID,
                        "BrokenPath Toughness Reset",
                        -armorToughnessAttribute.getValue(),
                        AttributeModifier.Operation.ADDITION
                ));
            }

            CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
                player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(playerXP -> {
                    int intelligence = playerStats.getIntelligence();
                    int dexterity = playerStats.getDexterity();
                    int constitution = playerStats.getConstitution();

                    boolean inCombat = playerStats.isInCombat(currentTick);
                    long lastCombatExitTick = playerStats.getLastCombatExitTick();

                    // Lógica de Drenaje y Penalización de Hambre
                    int newHungerStage = 0; // 0 = Normal/Saturado.

                    // Determina la etapa de hambre según el nivel de comida del jugador.
                    if (foodLevel <= 0) {
                        newHungerStage = 3; // Famélico (0-1 punto de comida).
                    } else if (foodLevel >= 2 && foodLevel <= 5) {
                        newHungerStage = 2; // Hambre Intensa (2-5 puntos de comida).
                    } else if (foodLevel >= 6 && foodLevel <= 15) {
                        newHungerStage = 1; // Hambre Moderada (6-15 puntos de comida).
                    }
                    // Si foodLevel es 16 o más (hasta 20), newHungerStage permanece 0.
                    playerStats.setHungerStage(newHungerStage);

                    // Lógica de daño por inanición.
                    if (newHungerStage == 3) {
                        Long lastDamage = lastStarveDamageTick.get(player.getUUID());
                        int starveDamageInterval = configs.getStarvingDamageIntervalTicks();

                        if (lastDamage == null || (currentTick - lastDamage >= starveDamageInterval)) {
                            player.hurt(player.damageSources().starve(), configs.getStarvingDamageAmount());
                            lastStarveDamageTick.put(player.getUUID(), currentTick);
                        }
                    }

                    // Aplica la penalización de agotamiento por hambre pasiva.
                    float passiveExhaustionToAdd = 0.0f;
                    switch (newHungerStage) {
                        case 1: // Hambre Moderada.
                            passiveExhaustionToAdd = configs.getHungryModeratePassiveExhaustionPerTick();
                            break;
                        case 2: // Hambre Intensa.
                            passiveExhaustionToAdd = configs.getHungryIntensePassiveExhaustionPerTick();
                            break;
                        case 3: // Famélico.
                            passiveExhaustionToAdd = configs.getStarvingPassiveExhaustionPerTick();
                            break;
                    }

                    if (passiveExhaustionToAdd > 0) {
                        foodStats.addExhaustion(passiveExhaustionToAdd);
                    }

                    // Lógica de regeneración de Maná.
                    float currentMana = playerStats.getCurrentMana();
                    float maxMana = playerStats.getMaxMana();
                    float manaRegenRate = StatCalculator.calculateManaRegenPerTick(intelligence, inCombat);

                    // Calcula el multiplicador de penalización por hambre para el Maná.
                    float hungerManaRegenPenalty = 1.0f; // Por defecto, sin penalización.
                    if (newHungerStage == 2) {
                        hungerManaRegenPenalty = 0.85f; // Reducción del 15%.
                    } else if (newHungerStage == 3) {
                        hungerManaRegenPenalty = 0.0f; // Detiene completamente la regeneración.
                    }
                    float actualManaRegenRate = manaRegenRate * hungerManaRegenPenalty;

                    // Obtiene si el Maná está siendo consumido continuamente.
                    boolean isConsumingMana = playerStats.isManaBeingConsumed();

                    // Determina si el Maná puede regenerarse.
                    boolean canRegenMana = !isConsumingMana &&
                            currentMana < maxMana &&
                            (!inCombat || (currentTick - lastCombatExitTick >= configs.getManaDelayAfterCombatTicks()));

                    if (canRegenMana && actualManaRegenRate > 0) {
                        playerStats.setCurrentMana(currentMana + actualManaRegenRate);
                    }

                    // Lógica de regeneración de Vigor.
                    float currentVigor = playerStats.getCurrentVigor();
                    float maxVigor = playerStats.getMaxVigor();
                    float vigorRegenRate = StatCalculator.calculateVigorRegenPerTick(dexterity, inCombat);

                    // Calcula el multiplicador de penalización por hambre para el Vigor.
                    float hungerVigorRegenPenalty = 1.0f; // Por defecto, sin penalización.
                    if (newHungerStage == 1) {
                        hungerVigorRegenPenalty = 1.0f + configs.getHungryModerateVigorRegenPenalty();
                    } else if (newHungerStage == 2) {
                        hungerVigorRegenPenalty = 1.0f + configs.getHungryIntenseVigorRegenPenalty();
                    } else if (newHungerStage == 3) {
                        hungerVigorRegenPenalty = 1.0f + configs.getStarvingVigorRegenPenalty();
                    }
                    // Asegura que el multiplicador no sea negativo.
                    hungerVigorRegenPenalty = Math.max(0.0f, hungerVigorRegenPenalty);

                    float actualVigorRegenRate = vigorRegenRate * hungerVigorRegenPenalty;

                    // Obtiene si el Vigor está siendo consumido continuamente.
                    boolean isConsumingVigor = playerStats.isVigorBeingConsumed();

                    // Determina si el Vigor puede regenerarse.
                    boolean canRegenVigor = !isConsumingVigor &&
                            currentVigor < maxVigor &&
                            (!inCombat || (currentTick - lastCombatExitTick >= configs.getVigorDelayAfterCombatTicks()));

                    if (canRegenVigor && actualVigorRegenRate > 0) {
                        playerStats.setCurrentVigor(currentVigor + actualVigorRegenRate);
                    }

                    // Lógica de Regeneración Lenta de Salud.
                    int effectiveHealthCooldown = StatCalculator.calculateHealthRegenCooldown(
                            constitution,
                            playerStats.getRegenSpeedBonusTicks(),
                            inCombat,
                            lastCombatExitTick,
                            currentTick
                    );

                    // Condición de regeneración de salud base.
                    boolean canRegenHealth = newHungerStage != 3 &&
                            foodStats.getFoodLevel() >= configs.getHealthMinFoodLevelForRegen() &&
                            player.getHealth() < player.getMaxHealth() &&
                            !inCombat &&
                            (currentTick - lastCombatExitTick >= configs.getHealthDelayAfterCombatTicks());

                    if (player.tickCount % effectiveHealthCooldown == 0 && canRegenHealth) {
                        player.heal(configs.getHealthAmountToHealPerPulse());
                        foodStats.addExhaustion(configs.getHealthExhaustionCostPerHealPulse());
                    }

                    // Lógica de Regeneración de Protección Innata.
                    float currentInnateProtection = playerStats.getCurrentInnateProtection();
                    float maxInnateProtection = playerStats.getMaxInnateProtection();

                    boolean canRegenInnateProtection = currentInnateProtection < maxInnateProtection &&
                            player.getHealth() == player.getMaxHealth() && // Solo si la salud está al máximo.
                            newHungerStage != 3 &&
                            (!inCombat || (currentTick - lastCombatExitTick >= configs.getInnateProtectionDelayAfterCombatTicks()));

                    if (player.tickCount % configs.getInnateProtectionRegenCooldownTicks() == 0 && canRegenInnateProtection) {
                        playerStats.restoreInnateProtection(configs.getInnateProtectionAmountPerPulse());
                    }
                });
            });
        }
    }

    // Recalcula y aplica las estadísticas al jugador.
    public static void recalculateAndApplyStats(Player player) {
        CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
            stats.recalculateStats(); // Este método se encarga de recalcular y sincronizar.

            // Asegura que el atributo MAX_HEALTH vanilla se actualice con la salud máxima del mod.
            AttributeInstance maxHealthAttribute = player.getAttribute(Attributes.MAX_HEALTH);
            if (maxHealthAttribute != null) {
                maxHealthAttribute.removeModifier(CUSTOM_MAX_HEALTH_MODIFIER_UUID); // Remueve modificadores previos.
                maxHealthAttribute.setBaseValue(stats.getMaxHealth()); // Establece el nuevo valor base.
            }

            // Asegura que la salud actual del jugador no exceda la nueva salud máxima.
            player.setHealth(Math.min(player.getHealth(), stats.getMaxHealth()));
        });
    }

    // Controla la experiencia vanilla del jugador.
    @SubscribeEvent
    public static void onPlayerTick(TickEvent.PlayerTickEvent event) {
        // Procesa solo al final del tick del jugador y únicamente en el lado del servidor lógico.
        if (event.phase == TickEvent.Phase.END && !event.player.level().isClientSide()) {
            Player player = event.player;

            // Forzar la experiencia vanilla del jugador a cero.
            // Esto asegura que la barra de XP vanilla siempre esté vacía y no afecte mecánicas vanilla.
            if (player.experienceLevel != 0) {
                player.experienceLevel = 0;
            }
            if (player.experienceProgress != 0.0f) {
                player.experienceProgress = 0.0f;
            }
            if (player.totalExperience != 0) {
                player.totalExperience = 0;
            }
        }
    }

    // Este evento se dispara justo ANTES de que el daño se aplique a la entidad.
    @SubscribeEvent
    public static void onLivingDamage(LivingDamageEvent event) {
        if (event.getEntity() instanceof Player player && !player.level().isClientSide()) {
            CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
                DamageSource source = event.getSource();
                float incomingDamage = event.getAmount();
                float currentProtectionSTRBased = stats.getCurrentProtection();
                float currentInnateProtection = stats.getCurrentInnateProtection();

                float damageToApplyToHealth = 0.0f;

                // Si la fuente de daño ignora la protección (definido por tags), el daño va directo a la salud.
                if (source.is(ModDamageTypeTags.IGNORES_PROTECTION)) {
                    damageToApplyToHealth = incomingDamage;
                } else {
                    float penetratingDamage = 0.0f;
                    float nonPenetratingDamage = incomingDamage;

                    // Si el daño es penetrante, una parte va directo a la salud.
                    if (source.is(ModDamageTypeTags.IS_PENETRATING)) {
                        float penetrationPercentage = 0.25f; // Considera mover a ModConfigs si se requiere personalización.
                        penetratingDamage = incomingDamage * penetrationPercentage;
                        nonPenetratingDamage = incomingDamage - penetratingDamage;
                        damageToApplyToHealth += penetratingDamage;
                    }

                    // El daño restante se mitiga por la Protección basada en STR.
                    float damageAfterSTRProtection = nonPenetratingDamage;
                    if (currentProtectionSTRBased > 0) {
                        float absorbedBySTRProtection = Math.min(nonPenetratingDamage, currentProtectionSTRBased);
                        stats.setCurrentProtection(currentProtectionSTRBased - absorbedBySTRProtection); // Consume protección.
                        damageAfterSTRProtection = nonPenetratingDamage - absorbedBySTRProtection;
                    }

                    // El daño restante se mitiga por la Protección Innata.
                    float damageAfterInnateProtection = damageAfterSTRProtection;
                    if (damageAfterInnateProtection > 0 && currentInnateProtection > 0) {
                        float absorbedByInnateProtection = Math.min(damageAfterInnateProtection, currentInnateProtection);
                        stats.setCurrentInnateProtection(currentInnateProtection - absorbedByInnateProtection); // Consume protección.
                        damageAfterInnateProtection = damageAfterInnateProtection - absorbedByInnateProtection;
                    }

                    // El daño final restante se aplica a la salud.
                    damageToApplyToHealth += damageAfterInnateProtection;
                }
                // Establece la cantidad final de daño que se aplicará a la entidad.
                event.setAmount(damageToApplyToHealth);
            });
        }
    }

    // No se utiliza para la anulación de atributos de armadura (manejado en onLivingTick).
    @SubscribeEvent
    public static void onItemAttributeModification(ItemAttributeModifierEvent event) {
        // Este evento se deja vacío para la anulación de la armadura vanilla.
        // La anulación se maneja en onLivingTick para una supresión más consistente.
    }

    // Controla el uso y desuso de armadura, recalculando la protección.
    @SubscribeEvent
    public static void onLivingEquipmentChange(LivingEquipmentChangeEvent event) {
        if (event.getEntity() instanceof Player player) {
            player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                float totalProtectionFromEquippedArmor = calculateEquippedArmorProtection(player);

                // La protección actual se limita por la protección STR-basada máxima.
                float finalCurrentProtection = Math.min(totalProtectionFromEquippedArmor, playerStats.getMaxProtection());

                playerStats.setCurrentProtection(finalCurrentProtection);
            });
        }
    }

    // Configuración personalizada para el Tooltip de armaduras.
    @OnlyIn(Dist.CLIENT)
    @SubscribeEvent
    public static void onTooltip(ItemTooltipEvent event) {
        ItemStack stack = event.getItemStack();
        List<Component> tooltip = event.getToolTip();

        if (stack.getItem() instanceof ArmorItem armorItem) {
            List<Component> newTooltip = new ArrayList<>();
            int insertionIndex = -1;

            // Filtra líneas de tooltip vanilla irrelevantes y busca el punto de inserción.
            for (int i = 0; i < tooltip.size(); i++) {
                Component component = tooltip.get(i);
                String text = component.getString().trim().toLowerCase(Locale.ROOT); // Usa Locale.ROOT para comparación consistente.

                // Filtra líneas de tooltip vanilla que ya no son relevantes.
                if (text.startsWith("when in ") || text.startsWith("when on ")) {
                    continue;
                }
                if (text.contains("armor") || text.contains("armadura") ||
                        text.contains("toughness") || text.contains("dureza")) {
                    continue;
                }

                // Encuentra el punto de inserción para la nueva información.
                if (insertionIndex == -1) {
                    if (text.contains("combat") || text.contains("combate")) {
                        insertionIndex = i + 1;
                    } else if (text.contains("durability") || text.contains("durabilidad") ||
                            text.contains("unbreakable") || text.contains("inrompible")) {
                        insertionIndex = i;
                    }
                }
                newTooltip.add(component);
            }

            // Si no se encontró un punto de inserción específico, añade al final.
            if (insertionIndex == -1) {
                insertionIndex = newTooltip.size();
            }

            float itemProtectionValue = ModArmorStats.getProtectionValue(armorItem);

            newTooltip.add(insertionIndex, Component.empty()); // Añade una línea vacía para espaciado.
            newTooltip.add(insertionIndex + 1, Component.literal("§9Protección BrokenPath: " + (int)itemProtectionValue));

            tooltip.clear();
            tooltip.addAll(newTooltip);
        }
    }

    // Este procedimiento se llama para manejar el gasto de puntos de atributo por parte del jugador.
    public static void onPlayerSpendAttributePoints(Player player, String attributeName, int amount) {
        CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
            boolean success = stats.spendAttributePoints(attributeName, amount);
            // spendAttributePoints ya llama a recalculateStats(), que a su vez llama a sync().
        });
    }

    // Este procedimiento se asume que es llamado por el sistema de XP cuando un jugador sube de nivel.
    public static void onPlayerGainedLevel(Player player, int newLevel) {
        CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
            int attributePointsGained = ModConfigs.getInstance().getAttributePointsForLevelRange(newLevel);
            if (attributePointsGained > 0) {
                stats.addAttributePoints(attributePointsGained); // Añade puntos al pool disponible del jugador.
            }
            recalculateAndApplyStats(player); // Recalcula estadísticas y sincroniza.
        });
    }

    // Maneja la regeneración de vida, aplicando un multiplicador si el jugador tiene el efecto de Regeneración.
    @SubscribeEvent
    public static void onLivingHeal(LivingHealEvent event) {
        if (event.getEntity() instanceof Player player) {
            // Comprueba si el jugador tiene actualmente el efecto de poción de Regeneración.
            if (player.hasEffect(MobEffects.REGENERATION)) {
                // Obtiene el multiplicador de mejora desde las configuraciones.
                float regenEffectHealingBonusMultiplier = ModConfigs.getInstance().getRegenEffectHealingBonusMultiplier();

                // Aplica el multiplicador a la cantidad de curación.
                event.setAmount(event.getAmount() * regenEffectHealingBonusMultiplier);
            }
        }
    }

    // --- Rutinas auxiliares ---

    // Calcula la protección total proporcionada por la armadura actualmente equipada por el jugador.
    private static float calculateEquippedArmorProtection(Player player) {
        float equippedProtection = 0;
        for (EquipmentSlot slot : EquipmentSlot.values()) {
            if (slot.getType() == EquipmentSlot.Type.ARMOR) {
                ItemStack equippedStack = player.getItemBySlot(slot);
                if (!equippedStack.isEmpty() && equippedStack.getItem() instanceof ArmorItem armorItem) {
                    equippedProtection += ModArmorStats.getProtectionValue(armorItem);
                }
            }
        }
        return equippedProtection;
    }
}