package com.malware98.brokenpath.events;

import com.malware98.brokenpath.BrokenPath;
import com.malware98.brokenpath.calculation.StatCalculator;
import com.malware98.brokenpath.capabilities.IPlayerXP;
import com.malware98.brokenpath.capabilities.PlayerStats;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;
import com.malware98.brokenpath.data.ModConfigs;
import com.malware98.brokenpath.data.ModDamageTypeTags;
import com.malware98.brokenpath.util.CapabilityUtils;
import com.malware98.brokenpath.util.ModArmorStats;
import net.minecraft.network.chat.Component;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.damagesource.DamageSource;
import net.minecraft.world.effect.MobEffects;
import net.minecraft.world.entity.EquipmentSlot;
import net.minecraft.world.entity.ai.attributes.AttributeInstance;
import net.minecraft.world.entity.ai.attributes.AttributeModifier;
import net.minecraft.world.entity.ai.attributes.Attributes;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.food.FoodData;
import net.minecraft.world.item.ArmorItem;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.GameRules;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.api.distmarker.OnlyIn;
import net.minecraftforge.event.ItemAttributeModifierEvent;
import net.minecraftforge.event.TickEvent;
import net.minecraftforge.event.entity.living.*;
import net.minecraftforge.event.entity.player.ItemTooltipEvent;
import net.minecraftforge.event.entity.player.PlayerEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

import java.util.*;

/**
 * Handles events related to player statistics.
 * Includes logic for synchronization, regeneration, damage, and attribute manipulation.
 */
@Mod.EventBusSubscriber(modid = BrokenPath.MOD_ID, bus = Mod.EventBusSubscriber.Bus.FORGE)
public class PlayerStatEventHandler {

    // --- UUIDs for Attribute Modifiers ---
    // UUIDs for modifiers that nullify vanilla armor attributes.
    // This is crucial to ensure the mod's custom protection system is the only one in effect.
    private static final UUID VANILLA_ARMOR_NULLIFIER_UUID = UUID.fromString("f8b7a6c5-4d3e-2b1a-9c8d-7e6f5a4b3c2d");
    private static final UUID VANILLA_TOUGHNESS_NULLIFIER_UUID = UUID.fromString("e9f8d7c6-b5a4-1c2d-3e4f-5f6a7b8c9d0e");

    // UUID for Max Health modifiers, used to set the base value of the vanilla attribute.
    private static final UUID CUSTOM_MAX_HEALTH_MODIFIER_UUID = UUID.fromString("1a2b3c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d");

    // Map to track the last tick when starvation damage was applied to a player.
    private static final Map<UUID, Long> lastStarveDamageTick = new java.util.HashMap<>();

    // --- Player Event Listeners ---

    /**
     * Synchronizes player stats on login and adjusts game rules for natural regeneration.
     * Ensures consistent stat values and disables vanilla health regen.
     * @param event The PlayerLoggedInEvent.
     */
    @SubscribeEvent
    public static void onPlayerLoggedIn(PlayerEvent.PlayerLoggedInEvent event) {
        if (!event.getEntity().level().isClientSide()) {
            ServerPlayer serverPlayer = (ServerPlayer) event.getEntity();

            BrokenPath.LOGGER.info("Player {} logged in. Syncing capabilities.", serverPlayer.getName().getString());

            // Synchronize PlayerStats capability.
            CapabilityUtils.ifPlayerStatsPresent(serverPlayer, stats -> {
                stats.sync();
                BrokenPath.LOGGER.info("PlayerStats synced for {}.", serverPlayer.getName().getString());
            });

            // Synchronize PlayerXP capability.
            serverPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(xp -> {
                xp.sync();
                BrokenPath.LOGGER.info("PlayerXP synced for {}.", serverPlayer.getName().getString());
            });

            // Recalculate and apply stats after capabilities have loaded.
            recalculateAndApplyStats(serverPlayer);

            // Ensure vanilla natural regeneration is disabled on the server.
            // This mod uses its own health regeneration system.
            serverPlayer.server.getGameRules().getRule(GameRules.RULE_NATURAL_REGENERATION).set(false, serverPlayer.server);

            // Remove starvation damage record for the player on login.
            lastStarveDamageTick.remove(serverPlayer.getUUID());
        }
    }

    /**
     * Cleans up player-specific static states when a player logs out.
     * @param event The PlayerLoggedOutEvent.
     */
    @SubscribeEvent
    public static void onPlayerLoggedOut(PlayerEvent.PlayerLoggedOutEvent event) {
        // Only process on the server-side.
        if (!event.getEntity().level().isClientSide()) {
            UUID playerUUID = event.getEntity().getUUID();

            BrokenPath.LOGGER.info("Player {} logged out. Cleaning up static consumption states.", event.getEntity().getName().getString());
            PlayerStats.removePlayerConsumptionState(playerUUID); // Remove consumption states to prevent memory leaks.
            lastStarveDamageTick.remove(playerUUID);
        }
    }

    /**
     * Copies player capabilities (stats and XP) when the player is cloned (e.g., on death or dimension change).
     * This ensures persistent data across player instances.
     * @param event The PlayerEvent.Clone event.
     */
    @SubscribeEvent
    public static void onPlayerClone(PlayerEvent.Clone event) {
        // Ensure this only runs on the logical server side.
        if (!event.getEntity().level().isClientSide()) {
            // event.getOriginal() is the player BEFORE dying/cloning.
            // event.getEntity() is the NEW player being created/respawned.

            // Copy PlayerStats capability.
            event.getOriginal().getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(oldStats -> {
                event.getEntity().getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(newStats -> {
                    newStats.copyFrom(oldStats);
                    BrokenPath.LOGGER.info("PlayerStats copied from original to new player {}.", event.getEntity().getName().getString());
                });
            });

            // Copy PlayerXP capability.
            event.getOriginal().getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(oldXP -> {
                event.getEntity().getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(newXP -> {
                    newXP.copyFrom(oldXP);
                    BrokenPath.LOGGER.info("PlayerXP copied from original to new player {}.", event.getEntity().getName().getString());
                });
            });
        }
    }

    /**
     * Restores player stats on respawn and recalculates protection.
     * Ensures players start fresh with appropriate stat values after dying.
     * @param event The PlayerEvent.PlayerRespawnEvent.
     */
    @SubscribeEvent
    public static void onPlayerRespawn(PlayerEvent.PlayerRespawnEvent event) {
        if (!event.getEntity().level().isClientSide()) {
            ServerPlayer serverPlayer = (ServerPlayer) event.getEntity();

            BrokenPath.LOGGER.info("Player {} respawned. Applying respawn logic and syncing.", serverPlayer.getName().getString());

            // Data copying is already handled in onPlayerClone.
            // Focus now on resetting combat/hunger states and syncing.

            CapabilityUtils.ifPlayerStatsPresent(serverPlayer, stats -> {
                // Restore current values to their maximums and reset hunger stage.
                stats.setCurrentHealth(stats.getMaxHealth());
                stats.setCurrentMana(stats.getMaxMana());
                stats.setCurrentVigor(stats.getMaxVigor());
                stats.setHungerStage(0);

                // Synchronize PlayerStats after all respawn adjustments.
                stats.sync();

                serverPlayer.setHealth(serverPlayer.getMaxHealth());
            });

            // Synchronize PlayerXP (already copied in Clone event).
            serverPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(IPlayerXP::sync);

            // Recalculate and apply stats after capabilities have loaded (this implicitly syncs them).
            recalculateAndApplyStats(serverPlayer);

            // Remove starvation damage record for the player on respawn.
            lastStarveDamageTick.remove(serverPlayer.getUUID());
        }
    }

    /**
     * Marks players who inflict or receive damage as "in combat."
     * Used for combat-related stat regeneration delays.
     * @param event The LivingAttackEvent.
     */
    @SubscribeEvent
    public static void onLivingAttack(LivingAttackEvent event) {
        // Mark the attacked player as in combat.
        if (event.getEntity() instanceof Player player && !player.level().isClientSide()) {
            CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
                stats.enterCombat(player.level().getGameTime());
            });
        }

        // Mark the attacking player as in combat.
        if (event.getSource().getEntity() instanceof Player player && !player.level().isClientSide()) {
            CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
                stats.enterCombat(player.level().getGameTime());
            });
        }
    }

    /**
     * Recalculates and updates the player's core statistics every tick.
     * Includes logic for nullifying vanilla armor, hunger effects, and stat regeneration.
     * @param event The LivingEvent.LivingTickEvent.
     */
    @SubscribeEvent
    public static void onLivingTick(LivingEvent.LivingTickEvent event) {
        if (event.getEntity() instanceof Player player && !player.level().isClientSide()) {

            long currentTick = player.level().getGameTime();
            ModConfigs configs = ModConfigs.getInstance();
            FoodData foodStats = player.getFoodData();
            int foodLevel = foodStats.getFoodLevel();

            // --- Logic: Force Vanilla Armor and Armor_Toughness to Zero ---
            // This ensures that the mod's custom Protection system is the only one active.
            // By applying a permanent negative modifier equal to their current value,
            // vanilla armor values are effectively nullified.
            AttributeInstance armorAttribute = player.getAttribute(Attributes.ARMOR);
            if (armorAttribute != null && armorAttribute.getValue() != 0.0) {
                armorAttribute.removeModifier(VANILLA_ARMOR_NULLIFIER_UUID); // Remove old modifier to prevent stacking issues.
                armorAttribute.addPermanentModifier(new AttributeModifier(
                        VANILLA_ARMOR_NULLIFIER_UUID,
                        "BrokenPath Armor Reset",
                        -armorAttribute.getValue(), // Nullify current value.
                        AttributeModifier.Operation.ADDITION
                ));
            }

            AttributeInstance armorToughnessAttribute = player.getAttribute(Attributes.ARMOR_TOUGHNESS);
            if (armorToughnessAttribute != null && armorToughnessAttribute.getValue() != 0.0) {
                armorToughnessAttribute.removeModifier(VANILLA_TOUGHNESS_NULLIFIER_UUID); // Remove old modifier.
                armorToughnessAttribute.addPermanentModifier(new AttributeModifier(
                        VANILLA_TOUGHNESS_NULLIFIER_UUID,
                        "BrokenPath Toughness Reset",
                        -armorToughnessAttribute.getValue(), // Nullify current value.
                        AttributeModifier.Operation.ADDITION
                ));
            }

            CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
                playerStats.setCurrentHealth(player.getHealth(), false);
                player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(playerXP -> {
                    int intelligence = playerStats.getIntelligence();
                    int dexterity = playerStats.getDexterity();
                    int constitution = playerStats.getConstitution();

                    boolean inCombat = playerStats.isInCombat(currentTick);
                    long lastCombatExitTick = playerStats.getLastCombatExitTick();

                    // --- Hunger Drain and Penalty Logic ---
                    int newHungerStage = 0; // 0 = Normal/Saturated.

                    // Determine the hunger stage based on the player's food level.
                    // This categorizes hunger into different penalty tiers.
                    if (foodLevel <= 0) {
                        newHungerStage = 3; // Starving (0-1 food point).
                    } else if (foodLevel >= 2 && foodLevel <= 5) {
                        newHungerStage = 2; // Intense Hunger (2-5 food points).
                    } else if (foodLevel >= 6 && foodLevel <= 15) {
                        newHungerStage = 1; // Moderate Hunger (6-15 food points).
                    }
                    // If foodLevel is 16 or more (up to 20), newHungerStage remains 0.
                    playerStats.setHungerStage(newHungerStage);

                    // Starvation damage logic.
                    // Players take damage periodically if in the starving hunger stage.
                    if (newHungerStage == 3) {
                        Long lastDamage = lastStarveDamageTick.get(player.getUUID());
                        int starveDamageInterval = configs.getStarvingDamageIntervalTicks();

                        if (lastDamage == null || (currentTick - lastDamage >= starveDamageInterval)) {
                            player.hurt(player.damageSources().starve(), configs.getStarvingDamageAmount());
                            lastStarveDamageTick.put(player.getUUID(), currentTick);
                        }
                    }

                    // Apply passive hunger exhaustion penalty.
                    // Different hunger stages apply varying amounts of passive exhaustion.
                    float passiveExhaustionToAdd = 0.0f;
                    switch (newHungerStage) {
                        case 1: // Moderate Hunger.
                            passiveExhaustionToAdd = configs.getHungryModeratePassiveExhaustionPerTick();
                            break;
                        case 2: // Intense Hunger.
                            passiveExhaustionToAdd = configs.getHungryIntensePassiveExhaustionPerTick();
                            break;
                        case 3: // Starving.
                            passiveExhaustionToAdd = configs.getStarvingPassiveExhaustionPerTick();
                            break;
                    }

                    if (passiveExhaustionToAdd > 0) {
                        foodStats.addExhaustion(passiveExhaustionToAdd);
                    }

                    // --- Mana Regeneration Logic ---
                    float currentMana = playerStats.getCurrentMana();
                    float maxMana = playerStats.getMaxMana();
                    float manaRegenRatePerTick = StatCalculator.calculateManaRegenPerTick(intelligence, inCombat);

                    // Calculate hunger penalty multiplier for Mana regeneration.
                    // Mana regen can be reduced or completely stopped based on hunger stage.
                    float hungerManaRegenPenalty = 1.0f; // Default: no penalty.
                    if (newHungerStage == 2) {
                        hungerManaRegenPenalty = 0.85f; // 15% reduction.
                    } else if (newHungerStage == 3) {
                        hungerManaRegenPenalty = 0.0f; // Completely stops regeneration.
                    }
                    float actualManaRegenRatePerTick = manaRegenRatePerTick * hungerManaRegenPenalty;

                    // Check if Mana is being continuously consumed (e.g., by an active spell).
                    boolean isConsumingMana = playerStats.isManaBeingConsumed();

                    // Determine if Mana can regenerate.
                    // Regeneration is prevented if mana is being consumed, or if the player is in combat
                    // and hasn't passed the combat delay threshold, or if mana is already full.
                    boolean canRegenMana = !isConsumingMana &&
                            currentMana < maxMana &&
                            (!inCombat || (currentTick - lastCombatExitTick >= configs.getManaDelayAfterCombatTicks()));

                    // Apply Mana regeneration in pulses for smoother visualization.
                            if (configs.regenSettings.manaRegenBaseCooldownTicks > 0 && // Add null/zero check for safety
                                    player.tickCount % configs.regenSettings.manaRegenBaseCooldownTicks == 0) {
                                if (canRegenMana && actualManaRegenRatePerTick > 0) {
                                    // Multiply the per-tick rate by the cooldown to get the amount for the pulse.
                                    float amountToHeal = actualManaRegenRatePerTick * configs.regenSettings.manaRegenBaseCooldownTicks;
                                    playerStats.setCurrentMana(currentMana + amountToHeal);
                                }
                    }

                    // --- Vigor Regeneration Logic ---
                    float currentVigor = playerStats.getCurrentVigor();
                    float maxVigor = playerStats.getMaxVigor();
                    float vigorRegenRatePerTick = StatCalculator.calculateVigorRegenPerTick(dexterity, inCombat);

                    // Calculate hunger penalty multiplier for Vigor regeneration.
                    // Vigor regen can also be penalized based on hunger stage.
                    float hungerVigorRegenPenalty = 1.0f; // Default: no penalty.
                    if (newHungerStage == 1) {
                        hungerVigorRegenPenalty = 1.0f + configs.getHungryModerateVigorRegenPenalty();
                    } else if (newHungerStage == 2) {
                        hungerVigorRegenPenalty = 1.0f + configs.getHungryIntenseVigorRegenPenalty();
                    } else if (newHungerStage == 3) {
                        hungerVigorRegenPenalty = 1.0f + configs.getStarvingVigorRegenPenalty();
                    }
                    // Ensure the multiplier is not negative.
                    hungerVigorRegenPenalty = Math.max(0.0f, hungerVigorRegenPenalty);

                    float actualVigorRegenRatePerTick = vigorRegenRatePerTick * hungerVigorRegenPenalty;

                    // Check if Vigor is being continuously consumed.
                    boolean isConsumingVigor = playerStats.isVigorBeingConsumed();

                    // Determine if Vigor can regenerate.
                    boolean canRegenVigor = !isConsumingVigor &&
                            currentVigor < maxVigor &&
                            (!inCombat || (currentTick - lastCombatExitTick >= configs.getVigorDelayAfterCombatTicks()));

                    // Apply Vigor regeneration in pulses for smoother visualization.
                    if (configs.regenSettings.vigorRegenBaseCooldownTicks > 0 && // Add null/zero check for safety
                            player.tickCount % configs.regenSettings.vigorRegenBaseCooldownTicks == 0) {
                        if (canRegenVigor && actualVigorRegenRatePerTick > 0) {
                            // Multiply the per-tick rate by the cooldown to get the amount for the pulse.
                            float amountToHeal = actualVigorRegenRatePerTick * configs.regenSettings.vigorRegenBaseCooldownTicks;
                            playerStats.setCurrentVigor(currentVigor + amountToHeal);
                        }
                    }

                    // --- Slow Health Regeneration Logic ---
                    // Calculates the effective cooldown for health regeneration based on Constitution.
                    int effectiveHealthCooldown = StatCalculator.calculateHealthRegenCooldown(
                            constitution,
                            playerStats.getRegenSpeedBonusTicks(),
                            inCombat,
                            lastCombatExitTick,
                            currentTick
                    );

                    // Base health regeneration conditions.
                    // Health regenerates only if not starving, food level is sufficient, player is not at max health,
                    // is out of combat, and has passed the combat delay.
                    boolean canRegenHealth = newHungerStage != 3 &&
                            foodStats.getFoodLevel() >= configs.getHealthMinFoodLevelForRegen() &&
                            player.getHealth() < player.getMaxHealth() &&
                            !inCombat &&
                            (currentTick - lastCombatExitTick >= configs.getHealthDelayAfterCombatTicks());

                    if (player.tickCount % effectiveHealthCooldown == 0 && canRegenHealth) {
                        player.heal(configs.getHealthAmountToHealPerPulse());
                        foodStats.addExhaustion(configs.getHealthExhaustionCostPerHealPulse());
                    }

                    // --- Innate Protection Regeneration Logic ---
                    float currentInnateProtection = playerStats.getCurrentInnateProtection();
                    float maxInnateProtection = playerStats.getMaxInnateProtection();

                    // Innate Protection regenerates only if not at max, health is full,
                    // not starving, and out of combat with sufficient delay.
                    boolean canRegenInnateProtection = currentInnateProtection < maxInnateProtection &&
                            player.getHealth() == player.getMaxHealth() && // Only if health is at maximum.
                            newHungerStage != 3 &&
                            (!inCombat || (currentTick - lastCombatExitTick >= configs.getInnateProtectionDelayAfterCombatTicks()));

                    if (player.tickCount % configs.getInnateProtectionRegenCooldownTicks() == 0 && canRegenInnateProtection) {
                        playerStats.restoreInnateProtection(configs.getInnateProtectionAmountPerPulse());
                    }
                });
            });
        }
    }

    /**
     * Recalculates and applies all primary player statistics.
     * This method is called after any attribute changes or on player events like respawn.
     * It ensures the vanilla MAX_HEALTH attribute is updated.
     * @param player The player whose stats need recalculating.
     */
    public static void recalculateAndApplyStats(Player player) {
        CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
            stats.recalculateStats();

            // Ensure the vanilla MAX_HEALTH attribute is updated with the mod's max health.
            AttributeInstance maxHealthAttribute = player.getAttribute(Attributes.MAX_HEALTH);
            if (maxHealthAttribute != null) {
                maxHealthAttribute.removeModifier(CUSTOM_MAX_HEALTH_MODIFIER_UUID); // Remove any previous modifiers.
                maxHealthAttribute.setBaseValue(stats.getMaxHealth()); // Set the new base value.
            }

            // Ensure the player's current health does not exceed the new maximum health.
            player.setHealth(Math.min(player.getHealth(), stats.getMaxHealth()));
        });
    }

    /**
     * Controls the player's vanilla experience.
     * Forces vanilla XP values to zero to ensure the mod's custom XP system is authoritative.
     * @param event The TickEvent.PlayerTickEvent.
     */
    @SubscribeEvent
    public static void onPlayerTick(TickEvent.PlayerTickEvent event) {
        // Process only at the end of the player's tick and only on the logical server side.
        if (event.phase == TickEvent.Phase.END && !event.player.level().isClientSide()) {
            Player player = event.player;

            // Force vanilla player experience to zero.
            // This prevents vanilla XP mechanics from interfering with the mod's system.
            if (player.experienceLevel != 0) {
                player.experienceLevel = 0;
            }
            if (player.experienceProgress != 0.0f) {
                player.experienceProgress = 0.0f;
            }
            if (player.totalExperience != 0) {
                player.totalExperience = 0;
            }
        }
    }

    /**
     * This event fires just BEFORE damage is applied to the entity.
     * Implements the mod's custom damage mitigation system, including protection and penetration.
     * @param event The LivingDamageEvent.
     */
    @SubscribeEvent
    public static void onLivingDamage(LivingDamageEvent event) {
        if (event.getEntity() instanceof Player player && !player.level().isClientSide()) {
            CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
                DamageSource source = event.getSource();
                float incomingDamage = event.getAmount();
                float currentProtectionSTRBased = stats.getCurrentProtection();
                float currentInnateProtection = stats.getCurrentInnateProtection();

                float damageToApplyToHealth = 0.0f;

                // If the damage source ignores protection (defined by tags), apply damage directly to health.
                if (source.is(ModDamageTypeTags.IGNORES_PROTECTION)) {
                    damageToApplyToHealth = incomingDamage;
                } else {
                    float penetratingDamage = 0.0f;
                    float nonPenetratingDamage = incomingDamage;

                    // If damage is penetrating, a portion goes directly to health.
                    if (source.is(ModDamageTypeTags.IS_PENETRATING)) {
                        float penetrationPercentage = ModConfigs.getInstance().getDamagePenetrationPercentage();
                        penetratingDamage = incomingDamage * penetrationPercentage;
                        nonPenetratingDamage = incomingDamage - penetratingDamage;
                        damageToApplyToHealth += penetratingDamage;
                    }

                    // Remaining damage is mitigated by Strength-based Protection.
                    float damageAfterSTRProtection = nonPenetratingDamage;
                    if (currentProtectionSTRBased > 0) {
                        float absorbedBySTRProtection = Math.min(nonPenetratingDamage, currentProtectionSTRBased);
                        // Consume the protection.
                        stats.setCurrentProtection(currentProtectionSTRBased - absorbedBySTRProtection);
                        damageAfterSTRProtection = nonPenetratingDamage - absorbedBySTRProtection;
                    }

                    // Remaining damage is mitigated by Innate Protection.
                    float damageAfterInnateProtection = damageAfterSTRProtection;
                    if (damageAfterInnateProtection > 0 && currentInnateProtection > 0) {
                        float absorbedByInnateProtection = Math.min(damageAfterInnateProtection, currentInnateProtection);
                        // Consume the innate protection.
                        stats.setCurrentInnateProtection(currentInnateProtection - absorbedByInnateProtection);
                        damageAfterInnateProtection = damageAfterInnateProtection - absorbedByInnateProtection;
                    }

                    // The final remaining damage is applied to health.
                    damageToApplyToHealth += damageAfterInnateProtection;
                }
                // Set the final amount of damage that will be applied to the entity.
                event.setAmount(damageToApplyToHealth);
            });
        }
    }

    /**
     * This event is left empty as vanilla armor attribute nullification is handled in `onLivingTick`.
     * This approach ensures more consistent suppression of vanilla armor values.
     * @param event The ItemAttributeModifierEvent.
     */
    @SubscribeEvent
    public static void onItemAttributeModification(ItemAttributeModifierEvent event) {
        // This event is intentionally empty for vanilla armor override.
        // Overriding is handled in onLivingTick for consistent suppression.
    }

    /**
     * Controls the equipping and unequipping of armor, recalculating protection.
     * Updates the player's current protection based on equipped armor.
     * @param event The LivingEquipmentChangeEvent.
     */
    @SubscribeEvent
    public static void onLivingEquipmentChange(LivingEquipmentChangeEvent event) {
        if (event.getEntity() instanceof Player player) {
            player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                float totalProtectionFromEquippedArmor = calculateEquippedArmorProtection(player);

                // Current protection is capped by the maximum STR-based protection.
                // This ensures equipped armor doesn't grant more protection than the player's STR allows.
                float finalCurrentProtection = Math.min(totalProtectionFromEquippedArmor, playerStats.getMaxProtection());

                playerStats.setCurrentProtection(finalCurrentProtection);
            });
        }
    }

    /**
     * Custom tooltip configuration for armor items.
     * Displays the mod's custom "BrokenPath Protection" value.
     * @param event The ItemTooltipEvent.
     */
    @OnlyIn(Dist.CLIENT) // Only run on the client side.
    @SubscribeEvent
    public static void onTooltip(ItemTooltipEvent event) {
        ItemStack stack = event.getItemStack();
        List<Component> tooltip = event.getToolTip();

        if (stack.getItem() instanceof ArmorItem armorItem) {
            List<Component> newTooltip = new ArrayList<>();
            int insertionIndex = -1;

            // Filter out irrelevant vanilla tooltip lines and find an insertion point.
            // This cleans up the tooltip to show only relevant mod information.
            for (int i = 0; i < tooltip.size(); i++) {
                Component component = tooltip.get(i);
                String text = component.getString().trim().toLowerCase(Locale.ROOT); // Use Locale.ROOT for consistent comparison.

                // Filter vanilla tooltip lines that are no longer relevant due to mod changes.
                if (text.startsWith("when in ") || text.startsWith("when on ")) {
                    continue;
                }
                if (text.contains("armor") || text.contains("armadura") ||
                        text.contains("toughness") || text.contains("dureza")) {
                    continue;
                }

                // Find the insertion point for the new information.
                // Insert before durability or combat-related info for better readability.
                if (insertionIndex == -1) {
                    if (text.contains("combat") || text.contains("combate")) {
                        insertionIndex = i + 1;
                    } else if (text.contains("durability") || text.contains("durabilidad") ||
                            text.contains("unbreakable") || text.contains("inrompible")) {
                        insertionIndex = i;
                    }
                }
                newTooltip.add(component);
            }

            // If no specific insertion point was found, add to the end.
            if (insertionIndex == -1) {
                insertionIndex = newTooltip.size();
            }

            float itemProtectionValue = ModArmorStats.getProtectionValue(armorItem);

            newTooltip.add(insertionIndex, Component.empty()); // Add an empty line for spacing.
            newTooltip.add(insertionIndex + 1, Component.literal("ยง9BrokenPath Protection: " + (int)itemProtectionValue));

            tooltip.clear(); // Clear existing tooltip.
            tooltip.addAll(newTooltip); // Add modified tooltip.
        }
    }

    /**
     * Handles the spending of attribute points by the player.
     * Delegates to the player's stats capability to apply the points.
     * @param player The player spending the points.
     * @param attributeName The name of the attribute to increase.
     * @param amount The number of points to spend.
     */
    public static void onPlayerSpendAttributePoints(Player player, String attributeName, int amount) {
        CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
            boolean success = stats.spendAttributePoints(attributeName, amount);
            // spendAttributePoints already calls recalculateStats(), which in turn calls sync().
        });
    }

    /**
     * This procedure is assumed to be called by the XP system when a player levels up.
     * Grants attribute points based on the new level.
     * @param player The player who leveled up.
     * @param newLevel The new level achieved by the player.
     */
    public static void onPlayerGainedLevel(Player player, int newLevel) {
        CapabilityUtils.ifPlayerStatsPresent(player, stats -> {
            int attributePointsGained = ModConfigs.getInstance().getAttributePointsForLevelRange(newLevel);
            if (attributePointsGained > 0) {
                stats.addAttributePoints(attributePointsGained); // Add points to the player's available pool.
            }
            recalculateAndApplyStats(player); // Recalculate stats and synchronize.
        });
    }

    /**
     * Handles healing events, applying a multiplier if the player has the Regeneration effect.
     * Enhances healing from all sources when Regeneration is active.
     * @param event The LivingHealEvent.
     */
    @SubscribeEvent
    public static void onLivingHeal(LivingHealEvent event) {
        if (event.getEntity() instanceof Player player) {
            // Check if the player currently has the Regeneration potion effect.
            if (player.hasEffect(MobEffects.REGENERATION)) {
                // Get the healing bonus multiplier from configurations.
                float regenEffectHealingBonusMultiplier = ModConfigs.getInstance().getRegenEffectHealingBonusMultiplier();

                // Apply the multiplier to the healing amount.
                event.setAmount(event.getAmount() * regenEffectHealingBonusMultiplier);
            }
        }
    }

    // --- Helper Routines ---

    /**
     * Calculates the total Protection provided by armor currently equipped by the player.
     * Iterates through all armor slots and sums up the mod's custom protection values.
     * @param player The player whose equipped armor protection is to be calculated.
     * @return The total equipped armor protection.
     */
    private static float calculateEquippedArmorProtection(Player player) {
        float equippedProtection = 0;
        for (EquipmentSlot slot : EquipmentSlot.values()) {
            // Only consider armor slots.
            if (slot.getType() == EquipmentSlot.Type.ARMOR) {
                ItemStack equippedStack = player.getItemBySlot(slot);
                // If the item is an armor item and not empty, add its protection value.
                if (!equippedStack.isEmpty() && equippedStack.getItem() instanceof ArmorItem armorItem) {
                    equippedProtection += ModArmorStats.getProtectionValue(armorItem);
                }
            }
        }
        return equippedProtection;
    }
}