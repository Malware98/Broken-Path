package com.malware98.brokenpath.capabilities;

import com.malware98.brokenpath.data.ModConfigs;
import com.malware98.brokenpath.events.PlayerStatEventHandler; // ¡NUEVA IMPORTACIÓN!
import com.malware98.brokenpath.network.PacketHandler;
import com.malware98.brokenpath.network.messages.SyncPlayerXPPacket;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.player.Player;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;

public class PlayerXP implements IPlayerXP {
    private int experience; // XP actual del jugador en el nivel actual
    private int level;      // Nivel actual del jugador
    private int xpDebt;     // ¡NUEVO CAMPO! Deuda de XP del jugador (si es negativa)
    private final Player player; // Referencia al jugador para la sincronización

    public PlayerXP(Player player) {
        this.player = player;
        this.experience = 0; // Inicia con 0 XP
        this.level = 1;      // Inicia en Nivel 1
        this.xpDebt = 0;     // ¡NUEVO! Inicia sin deuda
    }

    @Override
    public int getExperience() {
        return experience;
    }

    @Override
    public int getLevel() {
        return level;
    }

    @Override
    public void setExperience(int experience) {
        this.experience = experience;
        sync();
    }

    @Override
    public void setLevel(int level) {
        this.level = level;
        sync();
    }

    // ¡NUEVO! Getters y Setters para la deuda de XP
    @Override
    public int getXPDebt() {
        return xpDebt;
    }

    @Override
    public void setXPDebt(int xpDebt) {
        this.xpDebt = xpDebt;
        sync();
    }

    // ¡CAMBIADO! addExperience ahora es void y maneja la deuda y la pérdida de XP
    @Override
    public void addExperience(int amount) {
        // Si hay deuda de XP, primero la reducimos
        if (this.xpDebt > 0) {
            this.xpDebt -= amount;
            if (this.xpDebt < 0) {
                // Si la XP excede la deuda, el excedente se convierte en XP positiva
                amount = -this.xpDebt; // amount ahora es el excedente positivo
                this.xpDebt = 0;
            } else {
                // Toda la XP se usó para reducir la deuda, no hay XP para ganar
                amount = 0;
            }
        }

        // Si la XP es negativa (por penalización de muerte, etc.)
        if (amount < 0) {
            this.experience += amount; // Restar la XP
            if (this.experience < 0) {
                this.xpDebt += -this.experience; // Añadir el déficit a la deuda
                this.experience = 0; // La XP actual no puede ser negativa
            }
            // Si la XP es negativa, no se sube de nivel, solo se gestiona la deuda/pérdida
            sync(); // Sincroniza la XP con el cliente después de la pérdida
            return; // Salir del método
        }

        // Lógica normal de ganancia de XP (solo si amount > 0 después de gestionar la deuda)
        if (amount > 0) {
            if (level >= ModConfigs.MAX_LEVEL) {
                // Si ya está en el nivel máximo, no gana más XP
                sync();
                return;
            }

            this.experience += amount;
            boolean leveledUpThisCall = false; // Indica si se subió de nivel en esta llamada
            int xpNeededForNextLevel;

            // BUCLE CLAVE: Maneja múltiples subidas de nivel si se acumula suficiente XP
            while (level < ModConfigs.MAX_LEVEL) {
                xpNeededForNextLevel = ModConfigs.getInstance().getXPForNextLevel(this.level);
                if (this.experience >= xpNeededForNextLevel) {
                    this.experience -= xpNeededForNextLevel;
                    this.level++;
                    leveledUpThisCall = true; // Se subió de nivel en esta iteración

                    // Lógica para otorgar puntos de atributo al subir de nivel
                    final int pointsToAward = ModConfigs.getInstance().getAttributePointsForLevelRange(this.level);
                    if (pointsToAward > 0) {
                        player.getCapability(ModCapabilities.PLAYER_DATA_CAPABILITY).ifPresent(playerStats -> {
                            playerStats.addAttributePoints(pointsToAward); // Añade puntos al pool disponible
                        });
                    }
                } else {
                    break; // No hay suficiente XP para el siguiente nivel, salimos del bucle.
                }
            }

            // Si el jugador supera el nivel máximo, ajustamos la XP a 0 y el nivel al máximo.
            if (level >= ModConfigs.MAX_LEVEL) {
                this.level = ModConfigs.MAX_LEVEL;
                this.experience = 0;
            }

            // ¡IMPORTANTE! Recalcular y aplicar estadísticas inmediatamente después de subir de nivel
            // Esto asegura que Protección Innata y otros atributos se actualicen en el cliente.
            if (leveledUpThisCall) {
                PlayerStatEventHandler.recalculateAndApplyStats(player);
            }

            sync(); // Sincroniza la XP con el cliente
        }
    }

    @Override
    public void resetXP() {
        this.experience = 0;
        this.level = 1;
        this.xpDebt = 0;
        sync(); // Sincroniza los cambios
    }

    @Override
    public void copyFrom(IPlayerXP source) {
        this.experience = source.getExperience();
        this.level = source.getLevel();
        this.xpDebt = source.getXPDebt();
        sync(); // Cuando se copia, es importante sincronizar los datos.
    }

    @Override
    public void sync() {
        if (!player.level().isClientSide()) {
            if (player instanceof ServerPlayer serverPlayer) {
                PacketHandler.sendToPlayer(new SyncPlayerXPPacket(this.experience, this.level, this.xpDebt), serverPlayer);
            }
        }
    }

    // Implementación del método serializeNBT() de INBTSerializable.
    @Override
    public CompoundTag serializeNBT() {
        CompoundTag tag = new CompoundTag();
        tag.putInt("brokenpath.player_xp", this.experience);
        tag.putInt("brokenpath.player_level", this.level);
        tag.putInt("brokenpath.player_xp_debt", this.xpDebt); // ¡NUEVO! Guarda la deuda
        return tag;
    }

    // Implementación del método deserializeNBT(CompoundTag) de INBTSerializable.
    @Override
    public void deserializeNBT(CompoundTag nbt) {
        this.experience = nbt.getInt("brokenpath.player_xp");
        this.level = nbt.getInt("brokenpath.player_level");
        this.xpDebt = nbt.getInt("brokenpath.player_xp_debt"); // ¡NUEVO! Carga la deuda

        // Asegurarse de que el nivel no exceda el máximo o sea menor que 1.
        if (this.level > ModConfigs.MAX_LEVEL) {
            this.level = ModConfigs.MAX_LEVEL;
            this.experience = 0;
            this.xpDebt = 0; // Asegurarse de que no haya deuda si ya está al máximo
        } else if (this.level < 1) {
            this.level = 1;
            this.experience = 0;
            this.xpDebt = 0; // Asegurarse de que no haya deuda si el nivel es inválido
        }
    }
}
