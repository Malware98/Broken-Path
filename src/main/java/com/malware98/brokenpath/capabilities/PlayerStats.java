package com.malware98.brokenpath.capabilities;

import com.malware98.brokenpath.calculation.StatCalculator;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;
import com.malware98.brokenpath.data.ModConfigs;
import com.malware98.brokenpath.network.PacketHandler;
import com.malware98.brokenpath.network.messages.SyncPlayerStatsPacket;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.player.Player;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

public class PlayerStats implements IPlayerStats {

    // Atributos de Combate y Bonificaciones Temporales
    private long lastCombatTick; // El último tick en el que el jugador estuvo en combate
    private long lastCombatExitTick; // El tick en el que el jugador salió de combate
    private float luckBonusMultiplier = 1.0f; // Multiplicador para la suerte (puede venir de equipo/efectos)
    private float regenSpeedBonusTicks = 0.0F; // Bonificación a la velocidad de regeneración (en ticks)

    // Atributos de Progresión y Rol del Jugador
    private int attributePoints = 0; // Puntos disponibles para gastar en atributos principales
    private String race = "HUMAN"; // Raza actual del jugador
    private String playerClass = "NO_CLASS"; // Clase actual del jugador
    private String specialization = ""; // Especialización (subclase) del jugador
    private int skillPoints = 0; // Puntos disponibles para gastar en habilidades/árboles de talentos
    private Map<String, Integer> professions; // Niveles de profesiones del jugador

    // Estadísticas Principales del Jugador
    private float currentHealth; // Salud actual del jugador
    private float maxHealth = 20.0f; // Salud máxima del jugador (valor inicial, se recalcula)
    private float currentProtection; // Protección actual que puede absorber daño
    private float maxProtection = 0.0f; // Protección máxima basada en Fuerza y equipamiento (se recalcula)
    private float currentMana; // Maná actual del jugador
    private float maxMana = 0.0f; // Maná máximo del jugador (se recalcula)
    private float currentVigor; // Vigor actual del jugador
    private float maxVigor = 0.0f; // Vigor máximo del jugador (se recalcula)
    private float luck = -3.0f; // Valor de suerte del jugador

    // Atributos Base (manuales/incremental)
    private int constitution = 0; // Atributo de Constitución
    private int strength = 0; // Atributo de Fuerza
    private int dexterity = 0; // Atributo de Destreza
    private int intelligence = 0; // Atributo de Inteligencia

    // --- Referencia al Jugador ---
    private final Player player; // Referencia al objeto Player al que pertenecen estas estadísticas

    //Constructor para PlayerStats.
    public PlayerStats(Player player) {
        this.player = player;
        this.professions = new HashMap<>();

        recalculateStats();

        // Establece las estadísticas actuales a sus valores máximos iniciales
        this.currentHealth = this.maxHealth;
        this.currentProtection = this.maxProtection;
        this.currentMana = this.maxMana;
        this.currentVigor = this.maxVigor;
    }

    // Métodos de IPlayerStats (Getters y Setters)

    @Override
    public int getAttributePoints() { return attributePoints; }
    @Override
    public void setAttributePoints(int points) { this.attributePoints = points; sync(); }
    @Override
    public void addAttributePoints(int amount) {
        if (amount > 0) { this.attributePoints += amount; }
        sync();
    }

    @Override
    public boolean spendAttributePoints(String attributeName, int amount) {
        if (amount <= 0 || this.attributePoints < amount) return false;

        int currentManualAttributeValue;
        String lowerCaseAttributeName = attributeName.toLowerCase();

        // Determina el valor actual del atributo antes de aplicar el gasto
        switch (lowerCaseAttributeName) {
            case "constitution": currentManualAttributeValue = this.constitution; break;
            case "strength": currentManualAttributeValue = this.strength; break;
            case "dexterity": currentManualAttributeValue = this.dexterity; break;
            case "intelligence": currentManualAttributeValue = this.intelligence; break;
            default: return false;
        }

        // Aplica el límite máximo configurable para el atributo
        int manualAttributeLimit = ModConfigs.getInstance().getManualAttributeLimit(attributeName);
        int potentialNewManualValue = currentManualAttributeValue + amount;

        if (potentialNewManualValue > manualAttributeLimit) {
            amount = manualAttributeLimit - currentManualAttributeValue;
            if (amount <= 0) return false;
        }

        // Aplica el gasto al atributo correspondiente
        switch (lowerCaseAttributeName) {
            case "constitution": this.constitution += amount; break;
            case "strength": this.strength += amount; break;
            case "dexterity": this.dexterity += amount; break;
            case "intelligence": this.intelligence += amount; break;
        }

        this.attributePoints -= amount;
        recalculateStats();
        sync();
        return true;
    }

    @Override public String getRace() { return race; }
    @Override public void setRace(String race) { this.race = race; recalculateStats(); sync(); }

    @Override public String getPlayerClass() { return playerClass; }
    @Override public void setPlayerClass(String playerClass) { this.playerClass = playerClass; recalculateStats(); sync(); }

    @Override public String getSpecialization() { return specialization; }
    @Override public void setSpecialization(String specialization) { this.specialization = specialization; recalculateStats(); sync(); }

    @Override public int getSkillPoints() { return skillPoints; }
    @Override public void addSkillPoints(int amount) { if (amount > 0) { this.skillPoints += amount; } sync(); }
    @Override public void spendSkillPoints(int amount) { if (amount > 0 && this.skillPoints >= amount) { this.skillPoints -= amount; sync(); } }

    @Override public Map<String, Integer> getProfessions() { return professions; }
    @Override public void setProfessions(Map<String, Integer> professions) { this.professions = new HashMap<>(professions); sync(); }
    @Override public int getProfessionLevel(String professionName) { return professions.getOrDefault(professionName, 0); }
    @Override public void setProfessionLevel(String professionName, int level) { if (level < 0) { level = 0; } professions.put(professionName, level); sync(); }
    @Override public void addOrUpdateProfession(String professionName, int level) { setProfessionLevel(professionName, level); }
    @Override public void removeProfession(String professionName) { professions.remove(professionName); sync(); }

    @Override public float getCurrentHealth() { return currentHealth; }
    @Override public void setCurrentHealth(float health) { this.currentHealth = Math.max(0, Math.min(health, this.maxHealth)); sync(); }
    @Override public float getMaxHealth() { return this.maxHealth; }
    @Override public void setMaxHealth(float maxHealth) { this.maxHealth = maxHealth; this.currentHealth = Math.min(this.currentHealth, this.maxHealth); sync(); }

    @Override public float getCurrentProtection() { return currentProtection; }
    @Override public void setCurrentProtection(float protection) { this.currentProtection = Math.max(0, Math.min(protection, this.maxProtection)); sync(); }
    @Override public float getMaxProtection() { return this.maxProtection; }
    @Override public void setMaxProtection(float maxProtection) { this.maxProtection = maxProtection; this.currentProtection = Math.min(this.currentProtection, this.maxProtection); sync(); }

    @Override public float getCurrentMana() { return currentMana; }
    @Override public void setCurrentMana(float mana) { this.currentMana = Math.max(0, Math.min(mana, this.maxMana)); sync(); }
    @Override public float getMaxMana() { return this.maxMana; }
    @Override public void setMaxMana(float maxMana) { this.maxMana = maxMana; this.currentMana = Math.min(this.currentMana, this.maxMana); sync(); }

    @Override public float getCurrentVigor() { return currentVigor; }
    @Override public void setCurrentVigor(float vigor) { this.currentVigor = Math.max(0, Math.min(vigor, this.maxVigor)); sync(); }
    @Override public float getMaxVigor() { return this.maxVigor; }
    @Override public void setMaxVigor(float maxVigor) { this.maxVigor = maxVigor; this.currentVigor = Math.min(this.currentVigor, this.maxVigor); sync(); }

    @Override public float getLuck() { return luck; }
    @Override public void setLuck(float luck) { this.luck = luck; sync(); }
    @Override public void addLuck(float amount) { this.luck += amount; sync(); }

    @Override public int getConstitution() { return constitution; }
    @Override public void setConstitution(int constitution) { this.constitution = constitution; recalculateStats(); sync(); }
    @Override public int getStrength() { return strength; }
    @Override public void setStrength(int strength) { this.strength = strength; recalculateStats(); sync(); }
    @Override public int getDexterity() { return dexterity; }
    @Override public void setDexterity(int dexterity) { this.dexterity = dexterity; recalculateStats(); sync(); }
    @Override public int getIntelligence() { return intelligence; }
    @Override public void setIntelligence(int intelligence) { this.intelligence = intelligence; recalculateStats(); sync(); }

    //Recalcula todas las estadísticas máximas del jugador (Salud, Maná, Vigor, Protección)
    public void recalculateStats() {
        String currentRace = this.getRace();
        String currentPlayerClass = this.getPlayerClass();
        int currentLevel = 1;

        // Obtener el nivel real del jugador si está en el servidor
        if (player instanceof ServerPlayer serverPlayer) {
            serverPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(xp -> {
                final int[] levelHolder = {1};
                levelHolder[0] = xp.getLevel();
            });
        }

        // Recalculo de Salud Máxima
        float newMaxHealth = StatCalculator.calculateHealth(currentRace, currentPlayerClass, this.constitution);
        if (this.currentHealth > newMaxHealth) {
            this.currentHealth = newMaxHealth;
        }
        this.maxHealth = newMaxHealth;

        // Recalculo de Maná Máximo
        float newMaxMana = StatCalculator.calculateMana(currentRace, currentPlayerClass, this.intelligence);
        if (this.currentMana > newMaxMana) {
            this.currentMana = newMaxMana;
        }
        this.maxMana = newMaxMana;

        // Recalculo de Vigor Máximo
        float newMaxVigor = StatCalculator.calculateVigor(currentRace, currentPlayerClass, this.dexterity);
        if (this.currentVigor > newMaxVigor) {
            this.currentVigor = newMaxVigor;
        }
        this.maxVigor = newMaxVigor;

        // Recalculo de Protección Máxima
        float newMaxProtectionSTR = StatCalculator.calculateProtectionFromSTR(currentRace, currentPlayerClass, this.strength);
        if (this.currentProtection > newMaxProtectionSTR) {
            this.currentProtection = newMaxProtectionSTR;
        }
        this.maxProtection = newMaxProtectionSTR;

        //  Recalculo de Suerte
        ModConfigs.LuckConfig luckConfig = ModConfigs.getInstance().getRaceLuckConfig(currentRace);
        if (luckConfig != null) {
            // La suerte se inicializa con el valor base de la raza
            float calculatedLuck = luckConfig.baseLuck;

            // Aplicar límites
            calculatedLuck = Math.min(calculatedLuck, luckConfig.maxLimit);
            calculatedLuck = Math.max(calculatedLuck, luckConfig.minLimit);

            this.luck = calculatedLuck;
        } else {
            // Fallback si no hay configuración de suerte para la raza
            this.luck = -3.0f;
        }
    }

    // Métodos de Reseteo de Datos

    //Resetea todas las estadísticas y progresión del jugador a sus valores predeterminados.
    @Override
    public void resetData() {
        this.attributePoints = 0;
        this.race = "HUMAN";
        this.playerClass = "NO_CLASS";
        this.specialization = "";
        this.skillPoints = 0;
        this.professions.clear();

        this.constitution = 0;
        this.strength = 0;
        this.dexterity = 0;
        this.intelligence = 0;

        recalculateStats();
        this.currentHealth = this.maxHealth;
        this.currentProtection = this.maxProtection; // Ahora currentProtection se ajusta a la STR-basada
        this.currentMana = this.maxMana;
        this.currentVigor = this.maxVigor;
        this.luck = -3.0f;

        sync();
    }

    //Resetea solo los datos específicos de la clase del jugador (clase, especialización, puntos de habilidad).
    @Override
    public void resetClassSpecificData() {
        this.playerClass = "NO_CLASS";
        this.specialization = "";
        this.skillPoints = 0;
        recalculateStats();
        sync();
    }

    // Métodos de Copia de Datos

    //Copia todas las estadísticas de una fuente IPlayerStats a esta instancia.
    @Override
    public void copyFrom(IPlayerStats source) {
        this.attributePoints = source.getAttributePoints();
        this.race = source.getRace();
        this.playerClass = source.getPlayerClass();
        this.specialization = source.getSpecialization();
        this.skillPoints = source.getSkillPoints();
        this.professions = new HashMap<>(source.getProfessions());

        this.constitution = source.getConstitution();
        this.strength = source.getStrength();
        this.dexterity = source.getDexterity();
        this.intelligence = source.getIntelligence();

        recalculateStats();

        // Sincronizar los valores actuales y máximos después de recalcular
        this.currentHealth = source.getCurrentHealth();
        if (this.currentHealth > this.maxHealth) { this.currentHealth = this.maxHealth; }

        // maxProtection ahora solo STR-based.
        this.currentProtection = source.getCurrentProtection();
        if (this.currentProtection > this.maxProtection) { this.currentProtection = this.maxProtection; }

        this.maxMana = source.getMaxMana(); this.currentMana = source.getCurrentMana();
        if (this.currentMana > this.maxMana) { this.currentMana = this.maxMana; }

        this.maxVigor = source.getMaxVigor(); this.currentVigor = source.getCurrentVigor();
        if (this.currentVigor > this.maxVigor) { this.currentVigor = this.maxVigor; }

        this.luck = source.getLuck();

        sync();
    }

    //Aplica un modificador de suerte al valor de suerte del jugador basado en una acción.
    public void applyLuckModifier(String actionKey) {
        Float baseModifier = ModConfigs.getInstance().luckActionModifiers.get(actionKey.toUpperCase());
        if (baseModifier != null) {
            float bonusMultiplier = this.getLuckBonusMultiplier();
            float finalModifier = baseModifier * bonusMultiplier;
            this.luck += finalModifier;

            String playerCurrentRace = this.getRace();
            ModConfigs.LuckConfig currentLuckConfig = ModConfigs.getInstance().getRaceLuckConfig(playerCurrentRace);
            if (currentLuckConfig != null) {
                this.luck = Math.min(this.luck, currentLuckConfig.maxLimit);
                this.luck = Math.max(this.luck, currentLuckConfig.minLimit);
            } else {
                this.luck = Math.min(this.luck, 3.0f);
                this.luck = Math.max(this.luck, -3.0f);
            }

            sync();
        }
    }

    //Recalcula el multiplicador de bonus de suerte del jugador (basado en equipo, efectos, etc.).
    public void recalculateLuckBonusMultiplier() {
        float totalBonus = 1.0f;
        // TODO: Implementar lógica para calcular luckBonusMultiplier
        this.luckBonusMultiplier = totalBonus; // Asegúrate de asignar el resultado
    }

    //Métodos de Serialización y Deserialization (Persistencia)

    //Guarda el estado actual de las estadísticas del jugador en un CompoundTag (NBT) para persistencia en el disco.
    @Override
    public CompoundTag serializeNBT() {
        CompoundTag nbt = new CompoundTag();
        nbt.putInt("AttributePoints", attributePoints);
        nbt.putString("Race", race);
        nbt.putString("PlayerClass", playerClass);
        nbt.putString("Specialization", specialization);
        nbt.putInt("SkillPoints", skillPoints);

        nbt.putFloat("LuckBonusMultiplier", luckBonusMultiplier);

        CompoundTag professionsNBT = new CompoundTag();
        for (Map.Entry<String, Integer> entry : professions.entrySet()) {
            professionsNBT.putInt(entry.getKey(), entry.getValue());
        }
        nbt.put("Professions", professionsNBT);

        nbt.putFloat("CurrentHealth", currentHealth);
        nbt.putFloat("MaxHealth", maxHealth);
        nbt.putFloat("CurrentProtection", currentProtection);
        nbt.putFloat("MaxProtection", maxProtection); // MaxProtection es la STR-basada
        nbt.putFloat("CurrentMana", currentMana);
        nbt.putFloat("MaxMana", maxMana);
        nbt.putFloat("CurrentVigor", currentVigor);
        nbt.putFloat("MaxVigor", maxVigor);
        nbt.putFloat("Luck", luck);

        nbt.putInt("Constitution", constitution);
        nbt.putInt("Strength", strength);
        nbt.putInt("Dexterity", dexterity);
        nbt.putInt("Intelligence", intelligence);

        // Ya cargamos luckBonusMultiplier en deserializeNBT, pero aquí lo guardamos
        nbt.putFloat("LuckBonusMultiplier", luckBonusMultiplier); // Asegúrate de guardar el valor actualizado.

        nbt.putLong("LastCombatTick", this.lastCombatTick);
        nbt.putLong("LastCombatExitTick", this.lastCombatExitTick);
        nbt.putFloat("RegenSpeedBonusTicks", this.regenSpeedBonusTicks);

        return nbt;
    }

    //Carga las estadísticas del jugador desde un CompoundTag (NBT).
    @Override
    public void deserializeNBT(CompoundTag nbt) {
        attributePoints = nbt.getInt("AttributePoints");
        race = nbt.getString("Race");
        playerClass = nbt.getString("PlayerClass");
        specialization = nbt.getString("Specialization");
        skillPoints = nbt.getInt("SkillPoints");

        professions.clear();
        CompoundTag professionsNBT = nbt.getCompound("Professions");
        for (String key : professionsNBT.getAllKeys()) {
            professions.put(key, professionsNBT.getInt(key));
        }

        // Cargar atributos base PRIMERO para que recalculateStats los use
        constitution = nbt.getInt("Constitution");
        strength = nbt.getInt("Strength");
        dexterity = nbt.getInt("Dexterity");
        intelligence = nbt.getInt("Intelligence");

        // Después de cargar los atributos, recalcula todas las estadísticas máximas.
        recalculateStats();

        currentHealth = nbt.getFloat("CurrentHealth");
        if (currentHealth > maxHealth) currentHealth = maxHealth;

        currentProtection = nbt.getFloat("CurrentProtection");
        if (currentProtection > maxProtection) currentProtection = maxProtection; // maxProtection ahora es STR-basada

        currentMana = nbt.getFloat("CurrentMana");
        if (currentMana > maxMana) currentMana = maxMana;

        currentVigor = nbt.getFloat("CurrentVigor");
        if (currentVigor > maxVigor) currentVigor = maxVigor;

        luck = nbt.getFloat("Luck"); // La suerte no depende directamente de recalculateStats en este flujo.

        // Asegúrate de cargar también el luckBonusMultiplier
        luckBonusMultiplier = nbt.getFloat("LuckBonusMultiplier");

        if (!player.level().isClientSide() && player instanceof ServerPlayer serverPlayer) {
            serverPlayer.setHealth(currentHealth);
            // No hay setMaxHealth directo en Entity, se gestiona con atributos y ModConfigs.
        }

        this.lastCombatTick = nbt.getLong("LastCombatTick");
        this.lastCombatExitTick = nbt.getLong("LastCombatExitTick");
        this.regenSpeedBonusTicks = nbt.contains("RegenSpeedBonusTicks") ? nbt.getFloat("RegenSpeedBonusTicks") : 0.0F;
    }

    // Sincronización con el Cliente
    @Override
    public void sync() {
        if (this.player instanceof ServerPlayer serverPlayer) {
            PacketHandler.sendToPlayer(new SyncPlayerStatsPacket(
                    this.attributePoints,
                    this.constitution, this.strength, this.dexterity, this.intelligence,
                    this.currentHealth, this.maxHealth,
                    this.currentProtection, this.maxProtection, // maxProtection sigue siendo la STR-basada
                    this.currentMana, this.maxMana,
                    this.currentVigor, this.maxVigor,
                    this.luck,
                    this.race, this.playerClass, this.specialization, this.skillPoints,
                    this.professions
            ), serverPlayer);
        }
    }

    // Getters y Setters Adicionales (específicos de PlayerStats, no en IPlayerStats)

    @Override
    public float getLuckBonusMultiplier() {
        return luckBonusMultiplier;
    }

    @Override
    public void setLuckBonusMultiplier(float multiplier) {
        float maxLimit = ModConfigs.getInstance().maxLuckBonusMultiplier; // Asegúrate de que esto exista en ModConfigs
        this.luckBonusMultiplier = Math.max(1.0f, Math.min(multiplier, maxLimit));
        sync();
    }

    //Calcula y retorna la protección innata del jugador basada en su raza y nivel.
    @Override
    public float getInnateProtection() {
        int currentLevel = 1; // Valor predeterminado

        // Si el jugador está en el servidor, intenta obtener el nivel real para el cálculo
        if (player instanceof ServerPlayer serverPlayer) {
            Optional<IPlayerXP> xpCapability = serverPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).resolve();
            if (xpCapability.isPresent()) {
                currentLevel = xpCapability.get().getLevel();
            }
        }
        return StatCalculator.calculateInnateProtection(this.race, currentLevel);
    }

    // Métodos de Estado de Combate

    @Override
    public long getLastCombatTick() {
        return lastCombatTick;
    }

    @Override
    public void setLastCombatTick(long tick) {
        this.lastCombatTick = tick;
    }

    @Override
    public boolean isInCombat(long currentTick) {
        return (currentTick - this.lastCombatTick) < 100;
    }

    //Marca al jugador como "en combate"
    @Override
    public void enterCombat(long currentTick) {
        this.lastCombatTick = currentTick;
    }

    @Override
    public void exitCombat() {
        // Reinicia el tick de combate a 0 para asegurar que el jugador no esté en combate.
        this.lastCombatTick = 0;
        this.lastCombatExitTick = player.level().getGameTime();
    }

    @Override
    public long getLastCombatExitTick() {
        return lastCombatExitTick;
    }

    @Override
    public float getRegenSpeedBonusTicks() {
        return this.regenSpeedBonusTicks;
    }

    @Override
    public void restoreProtection(float amount) {
        if (amount > 0) {
            // Asegura que la protección actual no exceda la protección máxima
            this.currentProtection = Math.min(this.currentProtection + amount, this.maxProtection);
            sync();
        }
    }

    @Override
    public void restoreMana(float amount) {
        if (amount > 0) {
            // Asegura que el maná actual no exceda el maná máximo
            this.currentMana = Math.min(this.currentMana + amount, this.maxMana);
            sync();
        }
    }

    @Override
    public void restoreVigor(float amount) {
        if (amount > 0) {
            // Asegura que el vigor actual no exceda el vigor máximo
            this.currentVigor = Math.min(this.currentVigor + amount, this.maxVigor);
            sync();
        }
    }

}