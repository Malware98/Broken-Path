package com.malware98.brokenpath.capabilities;

import com.malware98.brokenpath.BrokenPath;
import com.malware98.brokenpath.calculation.StatCalculator;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;
import com.malware98.brokenpath.data.ModConfigs;
import com.malware98.brokenpath.network.PacketHandler;
import com.malware98.brokenpath.network.messages.SyncPlayerStatsPacket;
import net.minecraft.core.registries.Registries;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.nbt.ListTag;
import net.minecraft.nbt.StringTag;
import net.minecraft.nbt.Tag;
import net.minecraft.resources.ResourceKey;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.biome.Biome;

import java.util.*;

/*
 * Implementación de la interfaz IPlayerStats, que gestiona todas las estadísticas
 * y atributos del jugador, incluyendo salud, maná, vigor, puntos de atributo,
 * raza, clase, profesiones y estado de combate.
 * Se encarga de los cálculos de estadísticas, persistencia y sincronización.
 */
public class PlayerStats implements IPlayerStats {

    // --- Atributos de Combate y Bonificaciones Temporales ---
    // El último tick en el que el jugador estuvo en combate
    private long lastCombatTick;
    // El tick en el que el jugador salió de combate
    private long lastCombatExitTick;
    // Multiplicador para el Favor (suerte), puede provenir de equipo/efectos
    private float favorBonusMultiplier = 1.0f;
    // Bonificación a la velocidad de regeneración en ticks
    private float regenSpeedBonusTicks = 0.0F;

    // --- Atributos de Progresión y Rol del Jugador ---
    // Puntos disponibles para gastar en atributos principales (Constitución, Fuerza, etc.)
    private int attributePoints = 0;
    // Raza actual del jugador (ej. "HUMAN", "ELF")
    private String race = "HUMAN";
    // Clase actual del jugador (ej. "WARRIOR", "MAGE")
    private String playerClass = "NO_CLASS";
    // Especialización (subclase) del jugador
    private String specialization = "";
    // Puntos disponibles para gastar en habilidades o árboles de talentos
    private int skillPoints = 0;
    // Mapa que almacena los niveles de las profesiones del jugador (ej. "MINING": 5)
    private Map<String, Integer> professions;

    // --- Estadísticas Principales del Jugador ---
    // Salud actual del jugador
    private float currentHealth;
    // Salud máxima del jugador (valor inicial, se recalcula con base en atributos)
    private float maxHealth = 20.0f;
    // Protección actual que puede absorber daño (basada en Fuerza y equipamiento)
    private float currentProtection;
    // Protección máxima (basada en Fuerza y equipamiento, se recalcula)
    private float maxProtection = 0.0f;
    // Protección Innata actual del jugador (se recalcula)
    private float currentInnateProtection;
    // Protección Innata máxima del jugador (se recalcula)
    private float maxInnateProtection = 0.0f;
    // Maná actual del jugador
    private float currentMana;
    // Maná máximo del jugador (se recalcula con base en atributos)
    private float maxMana = 0.0f;
    // Vigor actual del jugador
    private float currentVigor;
    // Vigor máximo del jugador (se recalcula con base en atributos)
    private float maxVigor = 0.0f;
    // Valor de Favor (suerte) del jugador
    private float favor = -40.0f;

    // --- Atributos Base (manuales/incrementales) ---
    // Atributo de Constitución (afecta la salud, resistencia)
    private int constitution = 0;
    // Atributo de Fuerza (afecta el daño físico, protección basada en STR)
    private int strength = 0;
    // Atributo de Destreza (afecta la velocidad, evasión, vigor)
    private int dexterity = 0;
    // Atributo de Inteligencia (afecta el maná, poder mágico)
    private int intelligence = 0;

    // --- Referencia al Jugador ---
    // Referencia al objeto Player al que pertenecen estas estadísticas
    private final Player player;

    // --- Campo de Hambre ---
    // Etapa actual de hambre del jugador (0 = Normal, 1 = Moderada, 2 = Intensa, 3 = Famélico)
    private int hungerStage = 0;

    // --- Banderas para habilidades de consumo continuo (se almacenan por UUID del jugador) ---
    // Mapa estático para rastrear si el maná se está consumiendo continuamente para cada jugador
    private static final Map<UUID, Boolean> isManaBeingConsumedContinuously = new HashMap<>();
    // Mapa estático para rastrear si el vigor se está consumiendo continuamente para cada jugador
    private static final Map<UUID, Boolean> isVigorBeingConsumedContinuously = new HashMap<>();

    // Atributos para Hitos/Logros
    private Map<String, Integer> achievementProgress; // Almacena el progreso numérico de cada hito (ej. "WALK_1000_STEPS": 500)
    private Map<String, Boolean> completedAchievements; // Almacena si un hito ya ha sido completado (ej. "FIRST_KILL": true)

    // Atributos para hitos específicos que necesitan persistencia de conjuntos
    private Set<ResourceKey<Biome>> discoveredBiomes;
    private Set<ResourceKey<Level>> visitedDimensions;
    private Set<ResourceLocation> craftedUniqueItems;

    // --- Constructor ---

    // Constructor para PlayerStats, inicializa las estadísticas del jugador.
    public PlayerStats(Player player) {
        this.player = player;
        this.professions = new HashMap<>();
        this.achievementProgress = new HashMap<>();
        this.completedAchievements = new HashMap<>();

        // Al crear la instancia, inicializamos las estadísticas con el nivel 1
        // y NO llamamos a sync() aquí. La sincronización inicial se maneja en
        // PlayerStatEventHandler.onPlayerLoggedIn/onPlayerRespawn.
        recalculateStatsInternal(1);

        // Establece las estadísticas actuales a sus valores máximos iniciales
        this.currentHealth = this.maxHealth;
        this.currentProtection = this.maxProtection;
        this.currentInnateProtection = this.maxInnateProtection;
        this.currentMana = this.maxMana;
        this.currentVigor = this.maxVigor;

        // Inicializar las banderas de consumo continuo para este jugador, si no existen
        isManaBeingConsumedContinuously.put(player.getUUID(), false);
        isVigorBeingConsumedContinuously.put(player.getUUID(), false);

        this.discoveredBiomes = new HashSet<>();
        this.visitedDimensions = new HashSet<>();
        this.craftedUniqueItems = new HashSet<>();
    }

    // --- Métodos de IPlayerStats (Getters y Setters) ---

    // Obtiene los puntos de atributo disponibles
    @Override
    public int getAttributePoints() { return attributePoints; }
    // Establece los puntos de atributo y sincroniza
    @Override
    public void setAttributePoints(int points) { this.attributePoints = points; sync(); }
    // Añade puntos de atributo (solo si es positivo) y sincroniza
    @Override
    public void addAttributePoints(int amount) {
        if (amount > 0) { this.attributePoints += amount; }
        sync();
    }

    // Gasta puntos de atributo en un atributo específico, aplicando límites configurables
    @Override
    public boolean spendAttributePoints(String attributeName, int amount) {
        if (amount <= 0 || this.attributePoints < amount) return false;

        int currentManualAttributeValue;
        String lowerCaseAttributeName = attributeName.toLowerCase();

        // Determina el valor actual del atributo antes de aplicar el gasto
        switch (lowerCaseAttributeName) {
            case "constitution": currentManualAttributeValue = this.constitution; break;
            case "strength": currentManualAttributeValue = this.strength; break;
            case "dexterity": currentManualAttributeValue = this.dexterity; break;
            case "intelligence": currentManualAttributeValue = this.intelligence; break;
            default: return false; // Atributo no reconocido
        }

        // Aplica el límite máximo configurable para el atributo
        int manualAttributeLimit = ModConfigs.getInstance().getManualAttributeLimit(attributeName);
        int potentialNewManualValue = currentManualAttributeValue + amount;

        // Ajusta la cantidad si excede el límite
        if (potentialNewManualValue > manualAttributeLimit) {
            amount = manualAttributeLimit - currentManualAttributeValue;
            if (amount <= 0) return false; // No se pueden añadir puntos si ya está en el límite o lo excede
        }

        // Aplica el gasto al atributo correspondiente
        switch (lowerCaseAttributeName) {
            case "constitution": this.constitution += amount; break;
            case "strength": this.strength += amount; break;
            case "dexterity": this.dexterity += amount; break;
            case "intelligence": this.intelligence += amount; break;
        }

        this.attributePoints -= amount; // Resta los puntos gastados del pool disponible
        recalculateStats(); // Recalcula las estadísticas derivadas y sincroniza
        return true;
    }

    // Obtiene la raza del jugador
    @Override public String getRace() { return race; }
    // Establece la raza del jugador, recalcula estadísticas y sincroniza
    @Override public void setRace(String race) { this.race = race; recalculateStats(); sync(); }

    // Obtiene la clase del jugador
    @Override public String getPlayerClass() { return playerClass; }
    // Establece la clase del jugador, recalcula estadísticas y sincroniza
    @Override public void setPlayerClass(String playerClass) { this.playerClass = playerClass; recalculateStats(); sync(); }

    // Obtiene la especialización del jugador
    @Override public String getSpecialization() { return specialization; }
    // Establece la especialización del jugador, recalcula estadísticas y sincroniza
    @Override public void setSpecialization(String specialization) { this.specialization = specialization; recalculateStats(); sync(); }

    // Obtiene los puntos de habilidad disponibles
    @Override public int getSkillPoints() { return skillPoints; }
    // Añade puntos de habilidad (solo si es positivo) y sincroniza
    @Override public void addSkillPoints(int amount) { if (amount > 0) { this.skillPoints += amount; } sync(); }
    // Gasta puntos de habilidad (solo si es positivo y hay suficientes) y sincroniza
    @Override public void spendSkillPoints(int amount) { if (amount > 0 && this.skillPoints >= amount) { this.skillPoints -= amount; sync(); } }

    // Obtiene el mapa de profesiones (solo lectura para evitar modificaciones externas)
    @Override public Map<String, Integer> getProfessions() { return professions; }
    // Establece todas las profesiones, creando una nueva instancia del mapa y sincroniza
    @Override public void setProfessions(Map<String, Integer> professions) { this.professions = new HashMap<>(professions); sync(); }
    // Obtiene el nivel de una profesión específica, o 0 si no existe
    @Override public int getProfessionLevel(String professionName) { return professions.getOrDefault(professionName, 0); }
    // Establece el nivel de una profesión (con un mínimo de 0) y sincroniza
    @Override public void setProfessionLevel(String professionName, int level) { if (level < 0) { level = 0; } professions.put(professionName, level); sync(); }
    // Añade o actualiza una profesión, delegando a setProfessionLevel
    @Override public void addOrUpdateProfession(String professionName, int level) { setProfessionLevel(professionName, level); }
    // Elimina una profesión y sincroniza
    @Override public void removeProfession(String professionName) { professions.remove(professionName); sync(); }

    // --- Setters/Getters de Salud ---

    // Obtiene la salud actual
    @Override
    public float getCurrentHealth() { return currentHealth; }
    // Establece la salud actual y sincroniza
    @Override
    public void setCurrentHealth(float health) {
        setCurrentHealth(health, true);
    }
    // Establece la salud actual con opción de sincronizar
    @Override
    public void setCurrentHealth(float health, boolean doSync) {
        this.currentHealth = Math.max(0, Math.min(health, this.maxHealth)); // Asegura que la salud esté dentro de los límites
        if (doSync) sync();
    }
    // Obtiene la salud máxima
    @Override
    public float getMaxHealth() { return this.maxHealth; }
    // Establece la salud máxima y sincroniza
    @Override
    public void setMaxHealth(float maxHealth) {
        setMaxHealth(maxHealth, true);
    }
    // Establece la salud máxima con opción de sincronizar
    @Override
    public void setMaxHealth(float maxHealth, boolean doSync) {
        this.maxHealth = maxHealth;
        // Asegura que la salud actual no exceda la nueva salud máxima
        this.currentHealth = Math.min(this.currentHealth, this.maxHealth);
        if (doSync) sync();
    }

    // --- Setters/Getters de Protección (basada en Fuerza) ---

    // Obtiene la protección actual
    @Override
    public float getCurrentProtection() { return currentProtection; }
    // Establece la protección actual y sincroniza
    @Override
    public void setCurrentProtection(float protection) {
        setCurrentProtection(protection, true);
    }
    // Establece la protección actual con opción de sincronizar
    @Override
    public void setCurrentProtection(float protection, boolean doSync) {
        this.currentProtection = Math.max(0, Math.min(protection, this.maxProtection)); // Asegura que la protección esté dentro de los límites
        if (doSync) sync();
    }
    // Obtiene la protección máxima
    @Override
    public float getMaxProtection() { return this.maxProtection; }
    // Establece la protección máxima y sincroniza
    @Override
    public void setMaxProtection(float maxProtection) {
        setMaxProtection(maxProtection, true);
    }
    // Establece la protección máxima con opción de sincronizar
    @Override
    public void setMaxProtection(float maxProtection, boolean doSync) {
        this.maxProtection = maxProtection;
        this.currentProtection = Math.min(this.currentProtection, this.maxProtection);
        if (doSync) sync();
    }

    // --- Setters/Getters de Protección Innata ---

    // Obtiene la protección innata actual
    @Override
    public float getCurrentInnateProtection() { return currentInnateProtection; }
    // Establece la protección innata actual y sincroniza
    @Override
    public void setCurrentInnateProtection(float innateProtection) {
        setCurrentInnateProtection(innateProtection, true);
    }
    // Establece la protección innata actual con opción de sincronizar
    @Override
    public void setCurrentInnateProtection(float innateProtection, boolean doSync) {
        this.currentInnateProtection = Math.max(0, Math.min(innateProtection, this.maxInnateProtection)); // Asegura que esté dentro de los límites
        if (doSync) sync();
    }
    // Obtiene la protección innata máxima
    @Override
    public float getMaxInnateProtection() { return this.maxInnateProtection; }
    // Establece la protección innata máxima y sincroniza
    @Override
    public void setMaxInnateProtection(float maxInnateProtection) {
        setMaxInnateProtection(maxInnateProtection, true);
    }
    // Establece la protección innata máxima con opción de sincronizar
    @Override
    public void setMaxInnateProtection(float maxInnateProtection, boolean doSync) {
        this.maxInnateProtection = maxInnateProtection;
        this.currentInnateProtection = Math.min(this.currentInnateProtection, this.maxInnateProtection);
        if (doSync) sync();
    }

    // --- Setters/Getters de Maná ---

    // Obtiene el maná actual
    @Override
    public float getCurrentMana() { return currentMana; }
    // Establece el maná actual y sincroniza
    @Override
    public void setCurrentMana(float mana) {
        setCurrentMana(mana, true);
    }
    // Establece el maná actual con opción de sincronizar
    @Override
    public void setCurrentMana(float mana, boolean doSync) {
        this.currentMana = Math.max(0, Math.min(mana, this.maxMana)); // Asegura que el maná esté dentro de los límites
        if (doSync) sync();
    }
    // Obtiene el maná máximo
    @Override
    public float getMaxMana() { return this.maxMana; }
    // Establece el maná máximo y sincroniza
    @Override
    public void setMaxMana(float maxMana) {
        setMaxMana(maxMana, true);
    }
    // Establece el maná máximo con opción de sincronizar
    @Override
    public void setMaxMana(float maxMana, boolean doSync) {
        this.maxMana = maxMana;
        this.currentMana = Math.min(this.currentMana, this.maxMana);
        if (doSync) sync();
    }

    // --- Setters/Getters de Vigor ---

    // Obtiene el vigor actual
    @Override
    public float getCurrentVigor() { return currentVigor; }
    // Establece el vigor actual y sincroniza
    @Override
    public void setCurrentVigor(float vigor) {
        setCurrentVigor(vigor, true);
    }
    // Establece el vigor actual con opción de sincronizar
    @Override
    public void setCurrentVigor(float vigor, boolean doSync) {
        this.currentVigor = Math.max(0, Math.min(vigor, this.maxVigor)); // Asegura que el vigor esté dentro de los límites
        if (doSync) sync();
    }
    // Obtiene el vigor máximo
    @Override
    public float getMaxVigor() { return this.maxVigor; }
    // Establece el vigor máximo y sincroniza
    @Override
    public void setMaxVigor(float maxVigor) {
        setMaxVigor(maxVigor, true);
    }
    // Establece el vigor máximo con opción de sincronizar
    @Override
    public void setMaxVigor(float maxVigor, boolean doSync) {
        this.maxVigor = maxVigor;
        this.currentVigor = Math.min(this.currentVigor, this.maxVigor);
        if (doSync) sync();
    }

    // Obtiene el Favor (suerte)
    @Override public float getFavor() { return favor; }
    // Establece el Favor y sincroniza
    @Override public void setFavor(float favor) { this.favor = favor; sync(); }
    // Añade Favor y sincroniza
    @Override public void addFavor(float amount) { this.favor += amount; sync(); }

    // --- Getters/Setters de Atributos Base ---

    // Obtiene el valor de Constitución
    @Override public int getConstitution() { return constitution; }
    // Establece Constitución y recalcula estadísticas
    @Override public void setConstitution(int constitution) { this.constitution = constitution; recalculateStats(); }
    // Obtiene el valor de Fuerza
    @Override public int getStrength() { return strength; }
    // Establece Fuerza y recalcula estadísticas
    @Override public void setStrength(int strength) { this.strength = strength; recalculateStats(); }
    // Obtiene el valor de Destreza
    @Override public int getDexterity() { return dexterity; }
    // Establece Destreza y recalcula estadísticas
    @Override public void setDexterity(int dexterity) { this.dexterity = dexterity; recalculateStats(); }
    // Obtiene el valor de Inteligencia
    @Override public int getIntelligence() { return intelligence; }
    // Establece Inteligencia y recalcula estadísticas
    @Override public void setIntelligence(int intelligence) { this.intelligence = intelligence; recalculateStats(); }

    // Obtiene la etapa de hambre actual
    @Override public int getHungerStage() {return hungerStage;}
    // Establece la etapa de hambre y sincroniza si ha cambiado
    @Override public void setHungerStage(int hungerStage) {
        if (this.hungerStage != hungerStage) {
            this.hungerStage = hungerStage;
            sync(); // Sincroniza solo cuando el estado de hambre cambia
        }
    }

    // --- Métodos de Recalculo de Estadísticas ---

    // Recalcula todas las estadísticas máximas del jugador (Salud, Maná, Vigor, Protección).
    // Este proceso es público, obtiene el nivel actual del jugador y luego llama a la lógica interna y sincroniza.
    @Override
    public void recalculateStats() {
        int currentLevel = 1; // Valor predeterminado
        // Obtener el nivel real del jugador solo si está en el servidor
        if (player instanceof ServerPlayer serverPlayer) {
            Optional<IPlayerXP> xpCapability = serverPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).resolve();
            if (xpCapability.isPresent()) {
                currentLevel = xpCapability.get().getLevel();
            }
        }
        recalculateStatsInternal(currentLevel); // Llama a la lógica de cálculo sin sincronizar
        sync(); // Sincroniza una única vez después de que todos los cálculos se han completado
    }

    // Lógica interna para recalcular las estadísticas máximas.
    private void recalculateStatsInternal(int currentLevel) {
        String currentRace = this.getRace();
        String currentPlayerClass = this.getPlayerClass();

        // Recalculo de Salud Máxima
        float newMaxHealth = StatCalculator.calculateHealth(currentRace, currentPlayerClass, this.constitution);
        setMaxHealth(newMaxHealth, false); // Usa el setter interno sin sincronizar

        // Recalculo de Maná Máximo
        float newMaxMana = StatCalculator.calculateMana(currentRace, currentPlayerClass, this.intelligence);
        setMaxMana(newMaxMana, false);

        // Recalculo de Vigor Máximo
        float newMaxVigor = StatCalculator.calculateVigor(currentRace, currentPlayerClass, this.dexterity);
        setMaxVigor(newMaxVigor, false);

        // Recalculo de Protección Máxima (basada en Fuerza)
        float newMaxProtectionSTR = StatCalculator.calculateProtectionFromSTR(currentRace, currentPlayerClass, this.strength);
        setMaxProtection(newMaxProtectionSTR, false);

        // Recalculo de Protección Innata Máxima
        float newMaxInnateProtection = StatCalculator.calculateInnateProtection(currentRace, currentLevel);
        setMaxInnateProtection(newMaxInnateProtection, false); // Usa el setter interno sin sincronizar

        // Recalculo de Favor (Suerte)
        ModConfigs.FavorConfig favorConfig = ModConfigs.getInstance().getRaceFavorConfig(currentRace);
        if (favorConfig != null) {
            float calculatedFavor = favorConfig.baseFavor;
            calculatedFavor = Math.min(calculatedFavor, favorConfig.maxLimit);
            calculatedFavor = Math.max(calculatedFavor, favorConfig.minLimit);
            this.favor = calculatedFavor; // Asignación directa, ya que setFavor llama a sync()
        } else {
            this.favor = 0.0f; // Valor de respaldo si no hay configuración de Favor para la raza
        }
    }

    // --- Métodos de Reseteo de Datos ---

    // Resetea todas las estadísticas y progresión del jugador a sus valores predeterminados.
    @Override
    public void resetData() {
        this.attributePoints = 0;
        this.race = "HUMAN";
        this.playerClass = "NO_CLASS";
        this.specialization = "";
        this.skillPoints = 0;
        this.professions.clear();

        this.constitution = 0;
        this.strength = 0;
        this.dexterity = 0;
        this.intelligence = 0;

        // Recalcula todas las estadísticas máximas basadas en los valores reiniciados
        recalculateStats();

        // Asegurarse de que las estadísticas actuales también se reinicien a sus máximos
        setCurrentHealth(this.maxHealth, false);
        setCurrentProtection(this.maxProtection, false);
        setCurrentInnateProtection(this.maxInnateProtection, false);
        setCurrentMana(this.maxMana, false);
        setCurrentVigor(this.maxVigor, false);

        this.achievementProgress.clear();
        this.completedAchievements.clear();

        this.discoveredBiomes.clear();
        this.visitedDimensions.clear();
        this.craftedUniqueItems.clear();

        sync(); // Sincronización final después del reinicio completo
    }

    // Resetea solo los datos específicos de la clase del jugador (clase, especialización, puntos de habilidad).
    @Override
    public void resetClassSpecificData() {
        this.playerClass = "NO_CLASS";
        this.specialization = "";
        this.skillPoints = 0;
        recalculateStats(); // Recalcula las estadísticas derivadas y sincroniza
    }

    // --- Métodos de Copia de Datos ---

    // Copia todas las estadísticas de una fuente IPlayerStats a esta instancia.
    @Override
    public void copyFrom(IPlayerStats source) {
        this.attributePoints = source.getAttributePoints();
        this.race = source.getRace();
        this.playerClass = source.getPlayerClass();
        this.specialization = source.getSpecialization();
        this.skillPoints = source.getSkillPoints();
        this.professions = new HashMap<>(source.getProfessions()); // Crea una nueva instancia del mapa

        this.constitution = source.getConstitution();
        this.strength = source.getStrength();
        this.dexterity = source.getDexterity();
        this.intelligence = source.getIntelligence();

        // Recalcular las estadísticas máximas basadas en los datos copiados
        int currentLevel = 1; // Valor predeterminado
        if (player instanceof ServerPlayer serverPlayer) {
            Optional<IPlayerXP> xpCapability = serverPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).resolve();
            if (xpCapability.isPresent()) {
                currentLevel = xpCapability.get().getLevel();
            }
        }
        recalculateStatsInternal(currentLevel); // Recalcula sin sincronizar aquí

        // Establecer los valores actuales, usando los setters con doSync = false
        setCurrentHealth(source.getCurrentHealth(), false);
        setCurrentProtection(source.getCurrentProtection(), false);
        setCurrentInnateProtection(source.getCurrentInnateProtection(), false);
        setCurrentMana(source.getCurrentMana(), false);
        setCurrentVigor(source.getCurrentVigor(), false);

        // La suerte y el multiplicador de suerte también se copian
        this.favor = source.getFavor();
        this.favorBonusMultiplier = source.getFavorBonusMultiplier();

        this.lastCombatTick = source.getLastCombatTick();
        this.lastCombatExitTick = source.getLastCombatExitTick();
        this.regenSpeedBonusTicks = source.getRegenSpeedBonusTicks();
        this.hungerStage = source.getHungerStage();

        // Copiar el estado de consumo continuo
        isManaBeingConsumedContinuously.put(player.getUUID(), source.isManaBeingConsumed());
        isVigorBeingConsumedContinuously.put(player.getUUID(), source.isVigorBeingConsumed());

        this.achievementProgress = new HashMap<>(source.getAchievementProgress());
        this.completedAchievements = new HashMap<>(source.getCompletedAchievements());

        this.discoveredBiomes = new HashSet<>(source.getDiscoveredBiomes());
        this.visitedDimensions = new HashSet<>(source.getVisitedDimensions());
        this.craftedUniqueItems = new HashSet<>(source.getCraftedUniqueItems());

        sync(); // Sincroniza una única vez al final de la copia
    }

    // --- Métodos de Favor (Suerte) ---

    // Aplica un modificador de Favor al valor de Favor del jugador basado en una acción.
    public void applyFavorModifier(String actionKey) {
        Float baseModifier = ModConfigs.getInstance().favorActionModifiers.get(actionKey.toUpperCase());
        if (baseModifier != null) {
            float bonusMultiplier = this.getFavorBonusMultiplier();
            float finalModifier = baseModifier * bonusMultiplier;
            this.favor += finalModifier;

            // Asegura que el Favor se mantenga dentro de los límites configurados por raza
            String playerCurrentRace = this.getRace();
            ModConfigs.FavorConfig currentFavorConfig = ModConfigs.getInstance().getRaceFavorConfig(playerCurrentRace);
            if (currentFavorConfig != null) {
                this.favor = Math.min(this.favor, currentFavorConfig.maxLimit);
                this.favor = Math.max(this.favor, currentFavorConfig.minLimit);
            } else {
                // Límites por defecto si no hay configuración específica de raza
                this.favor = Math.min(this.favor, 90.0f);
                this.favor = Math.max(this.favor, -90.0f);
            }

            sync();
        }
    }

    // Recalcula el multiplicador de bonificación de Favor (basado en equipo, efectos, etc.).
    public void recalculateFavorBonusMultiplier() {
        float totalBonus = 1.0f;
        // TODO: Implementar lógica para calcular favorBonusMultiplier (ej. basada en equipo, efectos, etc.)
        this.favorBonusMultiplier = totalBonus; // Asigna el resultado del cálculo
        sync(); // Sincroniza el cambio en el multiplicador
    }

    // --- Métodos de Serialización y Deserialización (Persistencia) ---

    // Guarda el estado actual de las estadísticas del jugador en un CompoundTag (NBT) para persistencia.
    @Override
    public CompoundTag serializeNBT() {
        CompoundTag nbt = new CompoundTag();
        nbt.putInt("AttributePoints", attributePoints);
        nbt.putString("Race", race);
        nbt.putString("PlayerClass", playerClass);
        nbt.putString("Specialization", specialization);
        nbt.putInt("SkillPoints", skillPoints);

        nbt.putInt("HungerStage", hungerStage);

        CompoundTag professionsNBT = new CompoundTag();
        for (Map.Entry<String, Integer> entry : professions.entrySet()) {
            professionsNBT.putInt(entry.getKey(), entry.getValue());
        }
        nbt.put("Professions", professionsNBT);

        // Agregamos Math.max(0, ...) para asegurar que los valores sean no negativos antes de guardarlos.
        nbt.putFloat("CurrentHealth", Math.max(0, currentHealth));
        nbt.putFloat("MaxHealth", Math.max(0, maxHealth));
        nbt.putFloat("CurrentProtection", Math.max(0, currentProtection));
        nbt.putFloat("MaxProtection", Math.max(0, maxProtection));
        nbt.putFloat("CurrentInnateProtection", Math.max(0, currentInnateProtection));
        nbt.putFloat("MaxInnateProtection", Math.max(0, maxInnateProtection));
        nbt.putFloat("CurrentMana", Math.max(0, currentMana));
        nbt.putFloat("MaxMana", Math.max(0, maxMana));
        nbt.putFloat("CurrentVigor", Math.max(0, currentVigor));
        nbt.putFloat("MaxVigor", Math.max(0, maxVigor));
        nbt.putFloat("Favor", favor);

        nbt.putInt("Constitution", constitution);
        nbt.putInt("Strength", strength);
        nbt.putInt("Dexterity", dexterity);
        nbt.putInt("Intelligence", intelligence);

        nbt.putFloat("FavorBonusMultiplier", favorBonusMultiplier);

        nbt.putLong("LastCombatTick", this.lastCombatTick);
        nbt.putLong("LastCombatExitTick", this.lastCombatExitTick);
        nbt.putFloat("RegenSpeedBonusTicks", this.regenSpeedBonusTicks);

        // Guardar el estado de consumo continuo para este jugador
        nbt.putBoolean("IsManaBeingConsumedContinuously", isManaBeingConsumedContinuously.getOrDefault(player.getUUID(), false));
        nbt.putBoolean("IsVigorBeingConsumedContinuously", isVigorBeingConsumedContinuously.getOrDefault(player.getUUID(), false));

        // Serializar progreso de logros (Map<String, Integer>)
        CompoundTag achievementProgressNBT = new CompoundTag();
        for (Map.Entry<String, Integer> entry : achievementProgress.entrySet()) {
            achievementProgressNBT.putInt(entry.getKey(), entry.getValue());
        }
        nbt.put("AchievementProgress", achievementProgressNBT);

        // Serializar logros completados (Map<String, Boolean>)
        CompoundTag completedAchievementsNBT = new CompoundTag();
        for (Map.Entry<String, Boolean> entry : completedAchievements.entrySet()) {
            completedAchievementsNBT.putBoolean(entry.getKey(), entry.getValue());
        }
        nbt.put("CompletedAchievements", completedAchievementsNBT);

        // Serializar Set de biomas descubiertos
        ListTag biomesListNBT = new ListTag();
        for (ResourceKey<Biome> biome : discoveredBiomes) {
            biomesListNBT.add(StringTag.valueOf(biome.location().toString()));
        }
        nbt.put("DiscoveredBiomes", biomesListNBT);

        // Serializar Set de dimensiones visitadas
        ListTag dimensionsListNBT = new ListTag();
        for (ResourceKey<net.minecraft.world.level.Level> dimension : visitedDimensions) {
            dimensionsListNBT.add(StringTag.valueOf(dimension.location().toString()));
        }
        nbt.put("VisitedDimensions", dimensionsListNBT);

        // Serializar Set de ítems crafteados únicos
        ListTag craftedItemsListNBT = new ListTag();
        for (ResourceLocation item : craftedUniqueItems) {
            craftedItemsListNBT.add(StringTag.valueOf(item.toString()));
        }
        nbt.put("CraftedUniqueItems", craftedItemsListNBT);


        return nbt;
    }

    // Carga las estadísticas del jugador desde un CompoundTag (NBT).
    @Override
    public void deserializeNBT(CompoundTag nbt) {
        // Envolvemos toda la lógica de deserialización en un try-catch.
        try {
            // Cargar atributos básicos primero. Usamos .getOrDefault() para mayor robustez
            // si el NBT no tiene estas etiquetas (ej. en saves antiguos)
            attributePoints = nbt.getInt("AttributePoints");
            race = nbt.getString("Race");
            playerClass = nbt.getString("PlayerClass");
            specialization = nbt.getString("Specialization");
            skillPoints = nbt.getInt("SkillPoints");

            hungerStage = nbt.getInt("HungerStage");

            professions.clear();
            // CRÍTICO: Comprobar si la etiqueta "Professions" existe Y es del tipo correcto (CompoundTag).
            // Esto previene errores si se carga un archivo de jugador antiguo sin esta etiqueta o con un tipo diferente.
            if (nbt.contains("Professions", Tag.TAG_COMPOUND)) {
                CompoundTag professionsNBT = nbt.getCompound("Professions");
                for (String key : professionsNBT.getAllKeys()) {
                    professions.put(key, professionsNBT.getInt(key));
                }
            } else {
                BrokenPath.LOGGER.warn("NBT 'Professions' tag not found or is not a CompoundTag for player {}. Initializing empty professions map.", player.getName().getString());
                // Si la etiqueta falta o es de tipo incorrecto, aseguramos que el mapa de profesiones esté vacío.
                professions = new HashMap<>(); // Re-inicializar para estar seguro
            }

            // Cargar atributos fundamentales. Son críticos para los cálculos posteriores.
            constitution = nbt.getInt("Constitution");
            strength = nbt.getInt("Strength");
            dexterity = nbt.getInt("Dexterity");
            intelligence = nbt.getInt("Intelligence");

            final int[] currentLevelHolder = {1}; // Valor predeterminado en un array para poder modificarlo en lambda
            // Solo si es el lado del servidor para obtener el nivel real.
            // Es vital que la capacidad de XP se haya cargado y esté disponible.
            if (player instanceof ServerPlayer serverPlayer) {
                player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).resolve().ifPresent(xpCapability -> {
                    currentLevelHolder[0] = xpCapability.getLevel(); // Modifica el elemento del array
                });
            }
            // Después de cargar los atributos, recalcula todas las estadísticas máximas.
            recalculateStatsInternal(currentLevelHolder[0]); // Llama al proceso interno sin sync()

            // Cargar los valores actuales y máximos.
            // Usamos .getFloat() que devuelve 0.0f si no se encuentra la etiqueta.
            currentHealth = nbt.getFloat("CurrentHealth");
            currentProtection = nbt.getFloat("CurrentProtection");
            currentInnateProtection = nbt.getFloat("CurrentInnateProtection");
            currentMana = nbt.getFloat("CurrentMana");
            currentVigor = nbt.getFloat("CurrentVigor");

            // Asegurarse de que los valores actuales no excedan los máximos recién calculados, y que no sean negativos
            this.currentHealth = Math.min(Math.max(0, currentHealth), this.maxHealth);
            this.currentProtection = Math.min(Math.max(0, currentProtection), this.maxProtection);
            this.currentInnateProtection = Math.min(Math.max(0, currentInnateProtection), this.maxInnateProtection);
            this.currentMana = Math.min(Math.max(0, currentMana), this.maxMana);
            this.currentVigor = Math.min(Math.max(0, currentVigor), this.maxVigor);

            favor = nbt.getFloat("Favor");
            // Usar .contains() para etiquetas que podrían ser nuevas u opcionales para evitar problemas de valor por defecto
            favorBonusMultiplier = nbt.contains("FavorBonusMultiplier") ? nbt.getFloat("FavorBonusMultiplier") : 1.0f; // El valor por defecto debe ser 1.0f si no está presente

            this.lastCombatTick = nbt.getLong("LastCombatTick");
            this.lastCombatExitTick = nbt.getLong("LastCombatExitTick");
            this.regenSpeedBonusTicks = nbt.contains("RegenSpeedBonusTicks") ? nbt.getFloat("RegenSpeedBonusTicks") : 0.0F;

            // Cargar el estado de consumo continuo. Usar .contains() para booleanos nuevos.
            isManaBeingConsumedContinuously.put(player.getUUID(), nbt.contains("IsManaBeingConsumedContinuously") ? nbt.getBoolean("IsManaBeingConsumedContinuously") : false);
            isVigorBeingConsumedContinuously.put(player.getUUID(), nbt.contains("IsVigorBeingConsumedContinuously") ? nbt.getBoolean("IsVigorBeingConsumedContinuously") : false);

            // Sí es el lado del servidor, actualizar la salud vanilla del jugador después de cargar.
            if (!player.level().isClientSide() && player instanceof ServerPlayer serverPlayer) {
                serverPlayer.setHealth(this.currentHealth); // Usar 'this.currentHealth' después de la sujeción
            }

            // Deserializar progreso de logros
            achievementProgress.clear();
            if (nbt.contains("AchievementProgress", Tag.TAG_COMPOUND)) {
                CompoundTag achievementProgressNBT = nbt.getCompound("AchievementProgress");
                for (String key : achievementProgressNBT.getAllKeys()) {
                    achievementProgress.put(key, achievementProgressNBT.getInt(key));
                }
            } else {
                achievementProgress = new HashMap<>(); // Asegurar que sea un mapa vacío si no existe
            }

            // Deserializar logros completados
            completedAchievements.clear();
            if (nbt.contains("CompletedAchievements", Tag.TAG_COMPOUND)) {
                CompoundTag completedAchievementsNBT = nbt.getCompound("CompletedAchievements");
                for (String key : completedAchievementsNBT.getAllKeys()) {
                    completedAchievements.put(key, completedAchievementsNBT.getBoolean(key));
                }
            } else {
                completedAchievements = new HashMap<>(); // Asegurar que sea un mapa vacío si no existe
            }

            // Deserializar Set de biomas descubiertos
            this.discoveredBiomes.clear();
            if (nbt.contains("DiscoveredBiomes", Tag.TAG_LIST)) {
                ListTag biomesListNBT = nbt.getList("DiscoveredBiomes", Tag.TAG_STRING);
                for (Tag tag : biomesListNBT) {
                    // Es crucial crear el ResourceKey<Biome> correctamente
                    try {
                        ResourceLocation loc = new ResourceLocation(tag.getAsString());
                        this.discoveredBiomes.add(ResourceKey.create(Registries.BIOME, loc));
                    } catch (Exception e) {
                        BrokenPath.LOGGER.warn("Failed to load biome ResourceKey from NBT for player {}: {}", player.getName().getString(), tag.getAsString(), e);
                    }
                }
            } else {
                this.discoveredBiomes = new HashSet<>(); // Asegurar que sea un set vacío si no existe
            }

            // Deserializar Set de dimensiones visitadas
            this.visitedDimensions.clear();
            if (nbt.contains("VisitedDimensions", Tag.TAG_LIST)) {
                ListTag dimensionsListNBT = nbt.getList("VisitedDimensions", Tag.TAG_STRING);
                for (Tag tag : dimensionsListNBT) {
                    // Es crucial crear el ResourceKey<Level> correctamente
                    try {
                        ResourceLocation loc = new ResourceLocation(tag.getAsString());
                        this.visitedDimensions.add(ResourceKey.create(Registries.DIMENSION, loc));
                    } catch (Exception e) {
                        BrokenPath.LOGGER.warn("Failed to load dimension ResourceKey from NBT for player {}: {}", player.getName().getString(), tag.getAsString(), e);
                    }
                }
            } else {
                this.visitedDimensions = new HashSet<>(); // Asegurar que sea un set vacío si no existe
            }

            // Deserializar Set de ítems crafteados únicos
            this.craftedUniqueItems.clear();
            if (nbt.contains("CraftedUniqueItems", Tag.TAG_LIST)) {
                ListTag craftedItemsListNBT = nbt.getList("CraftedUniqueItems", Tag.TAG_STRING);
                for (Tag tag : craftedItemsListNBT) {
                    // ResourceLocation es más sencillo, pero también puede fallar si el string es inválido
                    try {
                        this.craftedUniqueItems.add(new ResourceLocation(tag.getAsString()));
                    } catch (Exception e) {
                        BrokenPath.LOGGER.warn("Failed to load crafted item ResourceLocation from NBT for player {}: {}", player.getName().getString(), tag.getAsString(), e);
                    }
                }
            } else {
                this.craftedUniqueItems = new HashSet<>();
            }

        }catch (Exception e) {
            BrokenPath.LOGGER.error("Error al deserializar PlayerStats para el jugador {}. Reseteando datos.", player.getName().getString(), e);
            this.resetData();
        }
    }

    // --- Sincronización con el Cliente ---

    // Sincroniza todas las estadísticas del jugador desde el servidor al cliente.
    @Override
    public void sync() {
        if (this.player instanceof ServerPlayer serverPlayer) {
            PacketHandler.sendToPlayer(new SyncPlayerStatsPacket(
                    this.attributePoints,
                    this.constitution, this.strength, this.dexterity, this.intelligence,
                    this.currentHealth, this.maxHealth,
                    this.currentProtection, this.maxProtection,
                    this.currentInnateProtection, this.maxInnateProtection,
                    this.currentMana, this.maxMana,
                    this.currentVigor, this.maxVigor,
                    this.favor,
                    this.race, this.playerClass, this.specialization, this.skillPoints,
                    this.professions,
                    this.hungerStage,
                    this.favorBonusMultiplier,
                    this.achievementProgress,
                    this.completedAchievements,
                    this.discoveredBiomes,
                    this.visitedDimensions,
                    this.craftedUniqueItems
            ), serverPlayer);
        }
    }

    // --- Getters y Setters Adicionales (específicos de PlayerStats, no en IPlayerStats) ---

    // Obtiene el multiplicador de bonificación de Favor
    @Override
    public float getFavorBonusMultiplier() {
        return favorBonusMultiplier;
    }

    // Establece el multiplicador de bonificación de Favor, aplicando límites, y sincroniza
    @Override
    public void setFavorBonusMultiplier(float multiplier) {
        float maxLimit = ModConfigs.getInstance().maxFavorBonusMultiplier;
        this.favorBonusMultiplier = Math.max(1.0f, Math.min(multiplier, maxLimit)); // Asegura que esté entre 1.0 y el límite máximo
        sync();
    }

    // --- Métodos de Estado de Combate ---

    // Obtiene el último tick en el que el jugador estuvo en combate
    @Override
    public long getLastCombatTick() {
        return lastCombatTick;
    }

    // Establece el último tick en el que el jugador estuvo en combate
    @Override
    public void setLastCombatTick(long tick) {
        this.lastCombatTick = tick;
    }

    // Verifica si el jugador está actualmente en combate
    @Override
    public boolean isInCombat(long currentTick) {
        // El jugador está en combate si el último tick de combate fue dentro del umbral de tiempo configurado
        return (currentTick - this.lastCombatTick) < ModConfigs.getInstance().getHealthDelayAfterCombatTicks();
    }

    // Marca al jugador como "en combate"
    @Override
    public void enterCombat(long currentTick) {
        this.lastCombatTick = currentTick;
    }

    // Marca al jugador como "fuera de combate"
    @Override
    public void exitCombat() {
        this.lastCombatTick = 0; // Esto asegura que isInCombat() sea falso
        this.lastCombatExitTick = player.level().getGameTime(); // Registra el momento de salida
        sync(); // Sincroniza el estado de combate
    }

    // Obtiene el tick en el que el jugador salió por última vez de combate
    @Override
    public long getLastCombatExitTick() {
        return lastCombatExitTick;
    }

    // Obtiene la bonificación a la velocidad de regeneración en ticks
    @Override
    public float getRegenSpeedBonusTicks() {
        return this.regenSpeedBonusTicks;
    }

    // --- Métodos de Restauración de Estadísticas ---

    // Restaura la protección actual del jugador
    @Override
    public void restoreProtection(float amount) {
        if (amount > 0) {
            // Usa el setter que se encarga de limitar y sincronizar
            setCurrentProtection(this.currentProtection + amount, true);
        }
    }

    // Restaura el maná actual del jugador
    @Override
    public void restoreMana(float amount) {
        if (amount > 0) {
            // Usa el setter que se encarga de limitar y sincronizar
            setCurrentMana(this.currentMana + amount, true);
        }
    }

    // Restaura el vigor actual del jugador
    @Override
    public void restoreVigor(float amount) {
        if (amount > 0) {
            // Usa el setter que se encarga de limitar y sincronizar
            setCurrentVigor(this.currentVigor + amount, true);
        }
    }

    // Restaura la protección innata actual del jugador
    @Override
    public void restoreInnateProtection(float amount) {
        if (amount > 0) {
            // Usa el setter que se encarga de limitar y sincronizar
            setCurrentInnateProtection(this.currentInnateProtection + amount, true);
        }
    }

    // --- Métodos de Consumo Continuo ---

    // Establece si el maná se está consumiendo continuamente para este jugador y sincroniza
    @Override
    public void setManaBeingConsumed(boolean consuming) {
        if (isManaBeingConsumedContinuously.getOrDefault(player.getUUID(), false) != consuming) {
            isManaBeingConsumedContinuously.put(player.getUUID(), consuming);
            sync();
        }
    }

    // Verifica si el maná se está consumiendo continuamente para este jugador
    @Override
    public boolean isManaBeingConsumed() {
        return isManaBeingConsumedContinuously.getOrDefault(player.getUUID(), false);
    }

    // Establece si el vigor se está consumiendo continuamente para este jugador y sincroniza
    @Override
    public void setVigorBeingConsumed(boolean consuming) {
        if (isVigorBeingConsumedContinuously.getOrDefault(player.getUUID(), false) != consuming) {
            isVigorBeingConsumedContinuously.put(player.getUUID(), consuming);
            sync();
        }
    }

    // Verifica si el vigor se está consumiendo continuamente para este jugador
    @Override
    public boolean isVigorBeingConsumed() {
        return isVigorBeingConsumedContinuously.getOrDefault(player.getUUID(), false);
    }

    // -- Implementación de métodos para hitos --
    @Override
    public Map<String, Integer> getAchievementProgress() {
        return Collections.unmodifiableMap(achievementProgress); // Devolvemos una vista no modificable
    }

    @Override
    public void setAchievementProgress(String achievementKey, int progress) {
        this.achievementProgress.put(achievementKey, progress);
        sync(); // Sincroniza el progreso con el cliente
    }

    @Override
    public int getAchievementProgress(String achievementKey) {
        return achievementProgress.getOrDefault(achievementKey, 0); // Devuelve 0 si el hito no existe
    }

    @Override
    public Map<String, Boolean> getCompletedAchievements() {
        return Collections.unmodifiableMap(completedAchievements); // Devolvemos una vista no modificable
    }

    @Override
    public void setAchievementCompleted(String achievementKey, boolean completed) {
        this.completedAchievements.put(achievementKey, completed);
        sync(); // Sincroniza el estado de compleción con el cliente
    }

    @Override
    public boolean isAchievementCompleted(String achievementKey) {
        return completedAchievements.getOrDefault(achievementKey, false); // Devuelve false si no está completado o no existe
    }

    // --- Implementación de Métodos para persistencia de hitos específicos ---

    @Override
    public Set<ResourceKey<Biome>> getDiscoveredBiomes() {
        return Collections.unmodifiableSet(this.discoveredBiomes);
    }

    @Override
    public void addDiscoveredBiome(ResourceKey<Biome> biome) {
        if (this.discoveredBiomes.add(biome)) { // Añade y comprueba si fue un nuevo elemento
            sync(); // Sincroniza si se añadió un nuevo bioma
        }
    }

    @Override
    public Set<ResourceKey<net.minecraft.world.level.Level>> getVisitedDimensions() {
        return Collections.unmodifiableSet(this.visitedDimensions);
    }

    @Override
    public void addVisitedDimension(ResourceKey<net.minecraft.world.level.Level> dimension) {
        if (this.visitedDimensions.add(dimension)) { // Añade y comprueba si fue un nuevo elemento
            sync(); // Sincroniza si se añadió una nueva dimensión
        }
    }

    @Override
    public Set<ResourceLocation> getCraftedUniqueItems() {
        return Collections.unmodifiableSet(this.craftedUniqueItems);
    }

    @Override
    public void addCraftedUniqueItem(ResourceLocation item) {
        if (this.craftedUniqueItems.add(item)) { // Añade y comprueba si fue un nuevo elemento
            sync(); // Sincroniza si se añadió un nuevo ítem crafteado único
        }
    }
}