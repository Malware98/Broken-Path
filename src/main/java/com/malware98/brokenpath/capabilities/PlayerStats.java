// PlayerStats.java
package com.malware98.brokenpath.capabilities;

import com.malware98.brokenpath.BrokenPath;
import com.malware98.brokenpath.calculation.StatCalculator;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;
import com.malware98.brokenpath.client.PlayerStatsClient;
import com.malware98.brokenpath.data.config.AffinityMappingConfig; // NEW: Import AffinityMappingConfig
import com.malware98.brokenpath.data.config.AffinityTierDataConfig;
import com.malware98.brokenpath.data.config.AttributeConfig;
import com.malware98.brokenpath.data.config.ChimeraFormDataConfig;
import com.malware98.brokenpath.data.config.ClassDataConfig;
import com.malware98.brokenpath.data.config.MainModConfigManager;
import com.malware98.brokenpath.data.config.RaceDataConfig;
import com.malware98.brokenpath.data.config.RegenDataConfig;
import com.malware98.brokenpath.data.ModDamageTypeTags;
import com.malware98.brokenpath.network.PacketHandler;
import com.malware98.brokenpath.network.messages.SyncPlayerStatsPacket;
import net.minecraft.core.registries.Registries;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.nbt.ListTag;
import net.minecraft.nbt.StringTag;
import net.minecraft.nbt.Tag;
import net.minecraft.resources.ResourceKey;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.biome.Biome;

import java.util.*;
import java.util.stream.Collectors;

/**
 * // Implementation of the {@link IPlayerStats} interface.
 * // This class manages all detailed player statistics and attributes,
 * // including health, mana, vigor, protection, core attributes, race, class,
 * // professions, combat state, hunger, luck, and achievement progression.
 * // It handles stat calculations, data persistence (NBT), and synchronization
 * // between the server and client.
 */
public class PlayerStats implements IPlayerStats {

    // // --- Combat and Temporary Bonuses ---
    // The last game tick when the player was engaged in combat. Used to determine combat status.
    private long lastCombatTick;
    // The game tick when the player last exited combat. Used for out-of-combat regeneration delays.
    private long lastCombatExitTick;
    // A multiplier applied to Favor (luck) gains and losses, influenced by equipment or effects.
    private float favorBonusMultiplier = 1.0f;
    // A bonus (in ticks) that reduces health regeneration cooldown.
    private float regenSpeedBonusTicks = 0.0F;

    // // --- Sync Cooldown Fields ---
    private long lastHealthSyncTick = 0; // Last game tick when health was synchronized.

    // // --- Player Progression and Role Attributes ---
    // Points available for the player to manually allocate to core attributes (Constitution, Strength, etc.).
    private int attributePoints = 0;
    // The player's current race (e.g., "HUMAN", "ELF").
    private String race = "SPIRIT";
    // The player's current class (e.g., "WARRIOR", "MAGE").
    private String playerClass = "";
    // The player's chosen specialization within their class.
    private String specialization = "";
    // Skill points available for abilities or talent trees.
    private int skillPoints = 0;
    // A map storing the player's professions and their respective levels (e.g., "MINING": 5).
    private Map<String, Integer> professions;

    // // --- Primary Player Statistics ---
    // Current health of the player.
    private float currentHealth;
    // Maximum health of the player, calculated based on attributes and race/class.
    private float maxHealth = 20.0f;
    // Current Protection (STR-based) that absorbs incoming damage.
    private float currentProtection;
    // Maximum Protection (STR-based), calculated based on Strength and race/class.
    private float maxProtection = 0.0f;
    // Current Innate Protection, a passive damage reduction.
    private float currentInnateProtection;
    // Maximum Innate Protection, calculated based on level and race.
    private float maxInnateProtection = 0.0f;
    // Current mana, used for casting spells or abilities.
    private float currentMana;
    // Maximum mana.
    private float maxMana = 0.0f;
    // Current vigor, used for physical abilities or movement.
    private float currentVigor;
    // Maximum vigor.
    private float maxVigor = 0.0f;
    // The player's Favor (luck) value, influencing various in-game events.
    private float favor = 0.0f;

    // // --- Core Attributes (Manual Allocation / Incremental) ---
    // Constitution attribute: affects health and resilience.
    private int constitution = 0;
    // Strength attribute: affects physical damage and STR-based protection.
    private int strength = 0;
    // Dexterity attribute: affects speed, evasion, and vigor.
    private int dexterity = 0;
    // Intelligence attribute: affects mana and magical power.
    private int intelligence = 0;

    // // --- Player Reference ---
    // Reference to the actual Player entity associated with these stats.
    private final Player player;

    // // --- Hunger State ---
    // Current hunger stage of the player (0 = Normal, 1 = Moderate, 2 = Intense, 3 = Starving).
    private int hungerStage = 0;

    // // --- Flags for Continuous Resource Consumption (Static per Player) ---
    // Static map to track if mana is being continuously consumed for each player (by UUID).
    // This is static because it represents a transient state that can be set by external systems.
    private static final Map<UUID, Boolean> isManaBeingConsumedContinuously = new HashMap<>();
    // Static map to track if vigor is being continuously consumed for each player (by UUID).
    // This is static because it represents a transient state that can be set by external systems.
    private static final Map<UUID, Boolean> isVigorBeingConsumedContinuously = new HashMap<>();

    // // --- Achievement and Exploration Data ---
    // Stores the numerical progress towards each achievement (e.g., "WALK_1000_STEPS": 500 blocks walked).
    private Map<String, Integer> achievementProgress;
    // Stores whether a specific achievement has been completed (e.g., "FIRST_KILL": true).
    private Map<String, Boolean> completedAchievements;
    // Set of unique animal entity IDs that the player has tamed. Used for "Tireless Shepherd".
    private Set<ResourceLocation> tamedAnimals;
    // Set of unique biome ResourceKeys the player has discovered. Used for exploration achievements.
    private Set<ResourceKey<Biome>> discoveredBiomes;
    // Set of unique dimension ResourceKeys the player has visited. Used for dimension-related achievements.
    private Set<ResourceKey<Level>> visitedDimensions;
    // Set of unique item ResourceLocations that the player has crafted. Used for crafting achievements.
    private Set<ResourceLocation> craftedUniqueItems;

    // Cooldown for villager trading favor gain
    private int villagerTradesSinceLastFavor;
    private long lastVillagerFavorGainTick;

    // // --- Chimera Chaotic Transformation State ---
    private boolean inChaoticTransformation;
    private long chaoticTransformationEndTime;
    private long chaoticTransformationCooldownEndTime;

    // Store original attribute values when chaotic transformation starts (kept for potential future uses/debugging)
    private Map<String, Integer> originalAttributesOnTransform;
    // Store random percentage adjustments for stats during transformation (key: stat name, value: percentage -0.15 to +0.15)
    private Map<String, Float> chaoticStatAdjustments;

    // // --- Affinity Bonuses Applied ---
    // The part of the affinity bonus that was applied when the class was chosen.
    private float classAffinityBonusApplied;
    // The part of the affinity bonus that was applied when the specialization was chosen.
    private float specializationAffinityBonusApplied;


    /**
     * // Constructs a new PlayerStats instance for a given player.
     * // Initializes all stats to default values and sets up necessary collections.
     * @param player The player entity for whom these stats are managed.
     */
    public PlayerStats(Player player) {
        this.player = player;
        this.professions = new HashMap<>();
        this.achievementProgress = new HashMap<>();
        this.completedAchievements = new HashMap<>();
        this.tamedAnimals = new HashSet<>();
        this.discoveredBiomes = new HashSet<>();
        this.visitedDimensions = new HashSet<>();
        this.craftedUniqueItems = new HashSet<>();

        // Ensure default race is set before initial stat calculation
        this.race = "SPIRIT";

        // Set initial favor based on the default race.
        this.favor = RaceDataConfig.getInstance().getRaceSettings(this.race).getFavor();

        // Initialize affinity bonuses to 0
        this.classAffinityBonusApplied = 0.0f;
        this.specializationAffinityBonusApplied = 0.0f;

        // Initialize stats with base values (typically level 1 values).
        // This will calculate max stats based on the default "SPIRIT" race.
        recalculateStatsInternal(1);

        // Set current stats to their initial maximums at creation.
        // This ensures the player starts with full health/mana/vigor/protection.
        this.currentHealth = this.maxHealth;
        this.currentProtection = this.maxProtection;
        this.currentInnateProtection = this.maxInnateProtection;
        this.currentMana = this.maxMana;
        this.currentVigor = this.maxVigor;

        // Initialize continuous consumption flags for this player's UUID.
        isManaBeingConsumedContinuously.put(player.getUUID(), false);
        isVigorBeingConsumedContinuously.put(player.getUUID(), false);

        // Initialize new cooldown fields
        this.villagerTradesSinceLastFavor = 0;
        this.lastVillagerFavorGainTick = 0;

        // Initialize Chimera Chaotic Transformation state
        this.inChaoticTransformation = false;
        this.chaoticTransformationEndTime = 0;
        this.chaoticTransformationCooldownEndTime = 0;
        this.originalAttributesOnTransform = new HashMap<>();
        this.chaoticStatAdjustments = new HashMap<>();
    }

    // // --- IPlayerStats Interface Implementation (Getters and Setters) ---

    // // --- Attribute Points ---
    @Override
    public int getAttributePoints() { return attributePoints; }
    @Override
    public void setAttributePoints(int points) { this.attributePoints = points; }
    @Override
    public void addAttributePoints(int amount) {
        if (amount > 0) { this.attributePoints += amount; }
    }

    /**
     * // Spends a specified amount of attribute points on a given attribute.
     * // Applies configurable manual allocation limits to prevent over-allocation.
     * @param attributeName The name of the attribute (e.g., "CONSTITUTION").
     * @param amount The number of points to spend.
     * @return True if points were successfully spent, false otherwise (e.g., insufficient points, hit limit).
     */
    @Override
    public boolean spendAttributePoints(String attributeName, int amount) {
        if (amount <= 0 || this.attributePoints < amount) return false;

        int currentManualAttributeValue;
        String lowerCaseAttributeName = attributeName.toLowerCase();

        switch (lowerCaseAttributeName) {
            case "constitution": currentManualAttributeValue = this.constitution; break;
            case "strength": currentManualAttributeValue = this.strength; break;
            case "dexterity": currentManualAttributeValue = this.dexterity; break;
            case "intelligence": currentManualAttributeValue = this.intelligence; break;
            default: return false; // Attribute not recognized
        }

        // Apply configurable maximum limit for manual attribute allocation.
        int manualAttributeLimit = AttributeConfig.getInstance().getManualAllocationLimit(attributeName);
        int potentialNewManualValue = currentManualAttributeValue + amount;

        // Adjust amount if it exceeds the limit.
        if (potentialNewManualValue > manualAttributeLimit) {
            amount = manualAttributeLimit - currentManualAttributeValue;
            if (amount <= 0) return false;
        }

        // Apply the spent points to the corresponding attribute.
        switch (lowerCaseAttributeName) {
            case "constitution": this.constitution += amount; break;
            case "strength": this.strength += amount; break;
            case "dexterity": this.dexterity += amount; break;
            case "intelligence": this.intelligence += amount; break;
        }

        this.attributePoints -= amount; // Subtract spent points from available pool.
        recalculateStats(); // Recalculate derived stats (health, mana, etc.) and synchronize.
        return true;
    }

    // // --- Race, Class, Specialization ---
    @Override public String getRace() { return race; }
    @Override public void setRace(String race) {
        if (!Objects.equals(this.race, race)) { // Only update if race actually changes
            this.race = race;
            // Now using RaceDataConfig to get favor.
            this.favor = RaceDataConfig.getInstance().getRaceSettings(this.race).getFavor();
            // Reset affinity bonuses when race changes, as they depend on race-class interaction
            this.classAffinityBonusApplied = 0.0f;
            this.specializationAffinityBonusApplied = 0.0f;
            this.playerClass = ""; // Clear class and specialization on race change
            this.specialization = "";
            recalculateStats();
        }
    }
    @Override public String getPlayerClass() { return playerClass; }
    @Override public void setPlayerClass(String playerClass) {
        if (!Objects.equals(this.playerClass, playerClass)) { // Only update if class actually changes
            this.playerClass = playerClass;
            this.specialization = ""; // Clear specialization when class changes

            // Recalculate class affinity bonus
            String currentRace = this.getRace();
            // Get affinity tier directly from mapping config
            String affinityTier = AffinityMappingConfig.getInstance().getAffinityTier(currentRace, playerClass);
            this.classAffinityBonusApplied = AffinityTierDataConfig.getInstance().getClassSelectionTierBonus(getDummyTagCountForTier(affinityTier)); // Use dummy count to get correct tier value
            BrokenPath.LOGGER.debug("PlayerStats Debug: Setting class {}. Race {}. Affinity Tier: {}. Class Affinity Bonus Applied: {}.", playerClass, this.getRace(), affinityTier, this.classAffinityBonusApplied);


            recalculateStats();
        }
    }
    @Override public String getSpecialization() { return specialization; }
    @Override public void setSpecialization(String specialization) {
        if (!Objects.equals(this.specialization, specialization)) { // Only update if specialization actually changes
            this.specialization = specialization;

            // Recalculate specialization affinity bonus
            String currentRace = this.getRace();
            String currentPlayerClass = this.getPlayerClass();
            // Get affinity tier directly from mapping config
            String affinityTier = AffinityMappingConfig.getInstance().getAffinityTier(currentRace, currentPlayerClass);
            this.specializationAffinityBonusApplied = AffinityTierDataConfig.getInstance().getSpecializationSelectionTierBonus(getDummyTagCountForTier(affinityTier)); // Use dummy count to get correct tier value
            BrokenPath.LOGGER.debug("PlayerStats: Setting specialization {}. Race {}. Class {}. Affinity Tier: {}. Specialization Affinity Bonus Applied: {}.", specialization, this.getRace(), this.getPlayerClass(), affinityTier, this.specializationAffinityBonusApplied);

            recalculateStats();
        }
    }

    @Override public float getClassAffinityBonusApplied() { return classAffinityBonusApplied; }
    @Override public void setClassAffinityBonusApplied(float bonus) { this.classAffinityBonusApplied = bonus; }

    @Override public float getSpecializationAffinityBonusApplied() { return specializationAffinityBonusApplied; }
    @Override public void setSpecializationAffinityBonusApplied(float bonus) { this.specializationAffinityBonusApplied = bonus; }

    /**
     * // Helper method to map affinity tier string to a dummy tag count for AffinityTierDataConfig getters.
     * // This is needed because AffinityTierDataConfig uses tag counts in its getter signatures.
     * @param tier The affinity tier string (e.g., "IDEAL").
     * @return A dummy tag count that maps to the correct tier in AffinityTierDataConfig.
     */
    private int getDummyTagCountForTier(String tier) {
        switch (tier) {
            case "IDEAL": return 8; // Corresponds to 8 matching tags for Ideal tier
            case "EFFICIENT": return 6; // Corresponds to 6-7 matching tags for Efficient tier
            case "ACCEPTABLE": return 3; // Corresponds to 3-5 matching tags for Acceptable tier
            case "DEFICIENT": return 0; // Corresponds to 0-2 matching tags for Deficient tier
            default: return 0; // Fallback
        }
    }


    // // --- Skill Points ---
    @Override public int getSkillPoints() { return skillPoints; }
    @Override public void addSkillPoints(int amount) { if (amount > 0) { this.skillPoints += amount; } }
    @Override public void spendSkillPoints(int amount) { if (amount > 0 && this.skillPoints >= amount) { this.skillPoints -= amount; } }

    // // --- Professions ---
    /**
     * // Returns an unmodifiable view of the player's professions map.
     * // This prevents external modification of the internal map.
     * @return An unmodifiable map of professions and their levels.
     */
    @Override public Map<String, Integer> getProfessions() { return Collections.unmodifiableMap(professions); }
    @Override public void setProfessions(Map<String, Integer> professions) { this.professions = new HashMap<>(professions); }
    @Override public int getProfessionLevel(String professionName) { return professions.getOrDefault(professionName, 0); }
    @Override public void setProfessionLevel(String professionName, int level) { if (level < 0) { level = 0; } professions.put(professionName, level); }
    @Override public void addOrUpdateProfession(String professionName, int level) { setProfessionLevel(professionName, level); }
    @Override public void removeProfession(String professionName) { professions.remove(professionName); }

    // // --- Primary Stat Getters/Setters (Internal management with sync) ---

    @Override public float getCurrentHealth() { return currentHealth; }
    @Override public void setCurrentHealth(float health) { setCurrentHealth(health, true); }
    @Override public void setCurrentHealth(float health, boolean doSync) {
        float oldHealth = this.currentHealth; // Store old value before clamping for sync check

        // Clamp health within bounds directly here for clarity in this critical method
        this.currentHealth = Math.max(0, Math.min(health, this.maxHealth));

        // If on server-side, explicitly set vanilla health to match mod's health.
        // This is crucial for Minecraft's internal health mechanisms.
        if (!player.level().isClientSide() && player instanceof ServerPlayer serverPlayer && oldHealth != this.currentHealth) {
            serverPlayer.setHealth(this.currentHealth);
        }

        // Only synchronize if doSync is true, on server-side, and if the value actually changed.
        if (doSync && !player.level().isClientSide() && oldHealth != this.currentHealth) {
            sync();
        }
    }
    @Override public float getMaxHealth() { return this.maxHealth; }
    @Override public void setMaxHealth(float maxHealth) { setMaxHealth(maxHealth, true); }
    @Override public void setMaxHealth(float maxHealth, boolean doSync) {
        this.maxHealth = maxHealth;
        this.currentHealth = Math.min(this.currentHealth, this.maxHealth); // Adjust current health if max decreases.
        if (doSync) sync();
    }

    @Override public float getCurrentProtection() { return currentProtection; }
    @Override public void setCurrentProtection(float protection) { setCurrentProtection(protection, true); }
    @Override public void setCurrentProtection(float protection, boolean doSync) {
        this.currentProtection = updateAndSyncStat(protection, this.maxProtection, this.currentProtection, doSync);
    }
    @Override public float getMaxProtection() { return this.maxProtection; }
    @Override public void setMaxProtection(float maxProtection) { setMaxProtection(maxProtection, true); }
    @Override public void setMaxProtection(float maxProtection, boolean doSync) {
        this.maxProtection = maxProtection;
        this.currentProtection = Math.min(this.currentProtection, this.maxProtection); // Adjust current protection if max decreases.
        if (doSync) sync();
    }

    @Override public float getCurrentInnateProtection() { return currentInnateProtection; }
    @Override public void setCurrentInnateProtection(float innateProtection) { setCurrentInnateProtection(innateProtection, true); }
    @Override public void restoreInnateProtection(float innateProtection, boolean doSync) { // Corrected: Match IPlayerStats signature
        this.currentInnateProtection = updateAndSyncStat(innateProtection, this.maxInnateProtection, this.currentInnateProtection, doSync);
    }
    @Override public float getMaxInnateProtection() { return this.maxInnateProtection; }
    @Override public void setMaxInnateProtection(float maxInnateProtection) { setMaxInnateProtection(maxInnateProtection, true); }
    @Override public void setMaxInnateProtection(float maxInnateProtection, boolean doSync) {
        this.maxInnateProtection = maxInnateProtection;
        this.currentInnateProtection = Math.min(this.currentInnateProtection, this.maxInnateProtection); // Adjust current if max decreases.
        if (doSync) sync();
    }

    @Override public float getCurrentMana() { return currentMana; }
    @Override public void setCurrentMana(float mana) { setCurrentMana(mana, true); }
    @Override public void setCurrentMana(float mana, boolean doSync) {
        this.currentMana = updateAndSyncStat(mana, this.maxMana, this.currentMana, doSync);
    }
    @Override public float getMaxMana() { return this.maxMana; }
    @Override public void setMaxMana(float maxMana) { setMaxMana(maxMana, true); }
    @Override public void setMaxMana(float maxMana, boolean doSync) {
        this.maxMana = maxMana;
        this.currentMana = Math.min(this.currentMana, this.maxMana); // Adjust current mana if max decreases.
        if (doSync) sync();
    }

    @Override public float getCurrentVigor() { return currentVigor; }
    @Override public void setCurrentVigor(float vigor) { setCurrentVigor(vigor, true); }
    @Override public void setCurrentVigor(float vigor, boolean doSync) {
        this.currentVigor = updateAndSyncStat(vigor, this.maxVigor, this.currentVigor, doSync);
    }
    @Override public float getMaxVigor() { return this.maxVigor; }
    @Override public void setMaxVigor(float maxVigor) { setMaxVigor(maxVigor, true); }
    @Override public void setMaxVigor(float maxVigor, boolean doSync) {
        this.maxVigor = maxVigor;
        this.currentVigor = Math.min(this.currentVigor, this.maxVigor); // Adjust current vigor if max decreases.
        if (doSync) sync();
    }

    // // --- Favor (Luck) Methods ---
    @Override public float getFavor() { return favor; }
    @Override public void setFavor(float favor) { this.favor = favor; }
    @Override public void addFavor(float amount) { this.favor += amount; }

    // // --- Core Attributes ---
    @Override public int getConstitution() { return constitution; }
    @Override public void setConstitution(int constitution) { this.constitution = constitution; recalculateStats(); }
    @Override public int getStrength() { return strength; }
    @Override
    public void setStrength(int strength) {
        this.strength = strength;
        recalculateStats();
    }
    @Override public int getDexterity() { return dexterity; }
    @Override
    public void setDexterity(int dexterity) {
        this.dexterity = dexterity;
        recalculateStats();
    }
    @Override public int getIntelligence() { return intelligence; }
    @Override
    public void setIntelligence(int intelligence) {
        this.intelligence = intelligence;
        recalculateStats();
    }

    // // --- Hunger State ---
    @Override public int getHungerStage() {return hungerStage;}
    @Override public void setHungerStage(int hungerStage) {
        // Only synchronize if the hunger stage has actually changed to reduce network traffic.
        if (this.hungerStage != hungerStage) {
            this.hungerStage = hungerStage;
        }
    }

    // // --- Stat Recalculation ---

    /**
     * // Recalculates all maximum primary statistics (Health, Mana, Vigor, Protection, Innate Protection, Favor)
     * // based on the player's current attributes, race, and class.
     * // This method is the primary entry point for updating a player's derived stats.
     */
    @Override
    public void recalculateStats() {
        int currentLevel = 1; // Default level.
        // Retrieve the player's actual level from their XP capability (server-side only).
        if (player instanceof ServerPlayer serverPlayer) {
            Optional<IPlayerXP> xpCapability = serverPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).resolve();
            if (xpCapability.isPresent()) {
                currentLevel = xpCapability.get().getLevel();
            }
        }
        recalculateStatsInternal(currentLevel); // Perform the actual calculations without immediate sync.
        sync(); // Synchronize all changes once after all calculations are complete.
    }

    /**
     * // Internal logic for recalculating maximum primary statistics.
     * // This method is called by {@link #recalculateStats()} and during initialization/deserialization.
     * // It does NOT perform synchronization itself; synchronization is handled by the caller.
     * @param currentLevel The current level of the player.
     */
    private void recalculateStatsInternal(int currentLevel) {
        String currentRace = this.getRace();
        String currentPlayerClass = this.getPlayerClass();
        String currentSpecialization = this.getSpecialization();

        BrokenPath.LOGGER.debug("PlayerStats Debug: Recalculating for {} (Race: {}, Class: {}, Spec: {}). Current Level: {}. Class Affinity Bonus Applied: {}. Spec Affinity Bonus Applied: {}.", player.getName().getString(), currentRace, currentPlayerClass, currentSpecialization, currentLevel, classAffinityBonusApplied, specializationAffinityBonusApplied);


        // Calculate raw max stats from base, attributes, and fixed bonuses
        float rawMaxHealth = StatCalculator.calculateHealth(this, currentRace, currentPlayerClass, currentSpecialization, this.constitution);
        float rawMaxMana = StatCalculator.calculateMana(this, currentRace, currentPlayerClass, currentSpecialization, this.intelligence);
        float rawMaxVigor = StatCalculator.calculateVigor(this, currentRace, currentPlayerClass, currentSpecialization, this.dexterity);
        float rawMaxProtectionSTR = StatCalculator.calculateProtectionFromSTR(this, currentRace, currentPlayerClass, currentSpecialization, this.strength);
        float rawMaxInnateProtection = StatCalculator.calculateInnateProtection(this, currentRace, currentLevel);


        // // --- Apply Chaotic Transformation Effects (if active) ---
        // This logic is now handled inside calculateGenericStat and calculateInnateProtection.
        // The adjustments are read from playerStats.getChaoticStatAdjustment()

        setMaxHealth(rawMaxHealth, false); // Set without immediate sync, will sync after all calculations
        setMaxMana(rawMaxMana, false);
        setMaxVigor(rawMaxVigor, false);
        setMaxProtection(rawMaxProtectionSTR, false);
        setMaxInnateProtection(rawMaxInnateProtection, false);

        // Recalculate Favor (Luck) based on race configuration.
        this.favor = RaceDataConfig.getInstance().getRaceSettings(currentRace).getFavor();
    }

    // // --- Data Reset Methods ---

    /**
     * // Resets all player statistics, attributes, race, class, professions, and achievement progress
     * // to their default starting values. This is typically used for character resets or debugging.
     */
    @Override
    public void resetData() {
        this.attributePoints = 0;
        this.playerClass = "";
        this.specialization = "";
        this.skillPoints = 0;
        this.professions.clear();

        // Reset manual attributes to zero (as they are usually gained via attribute points).
        this.constitution = 0;
        this.strength = 0;
        this.dexterity = 0;
        this.intelligence = 0;

        // Reset affinity bonuses
        this.classAffinityBonusApplied = 0.0f;
        this.specializationAffinityBonusApplied = 0.0f;

        // Achievements and exploration data are non-racial, so they are reset/cleared.
        this.achievementProgress.clear();
        this.completedAchievements.clear();
        this.discoveredBiomes.clear();
        this.visitedDimensions.clear();
        this.craftedUniqueItems.clear();
        this.tamedAnimals.clear();

        // Reset villager trade cooldowns
        this.villagerTradesSinceLastFavor = 0;
        this.lastVillagerFavorGainTick = 0;

        // Recalculate max stats based on the *current* race and reset attributes (0).
        // This will set maxHealth, maxMana, maxVigor, maxProtection, maxInnateProtection to their base values for the current race.
        recalculateStats();

        // Set current stats to their newly calculated maximums (base values).
        // For current health, we set it to maxHealth to ensure the player is full health after a reset.
        setCurrentHealth(this.maxHealth, false);
        setCurrentProtection(this.maxProtection, false);
        setCurrentInnateProtection(this.maxInnateProtection, false);
        setCurrentMana(this.maxMana, false);
        setCurrentVigor(this.maxVigor, false);

        // Reset Favor to its base value for the current race.
        this.favor = RaceDataConfig.getInstance().getRaceSettings(this.race).getFavor();

        // Reset combat state flags.
        this.lastCombatTick = 0;
        this.lastCombatExitTick = 0;
        this.regenSpeedBonusTicks = 0.0F;
        this.hungerStage = 0;
        this.favorBonusMultiplier = 1.0f;

        // Reset Chimera chaotic transformation state
        this.inChaoticTransformation = false;
        this.chaoticTransformationEndTime = 0;
        this.chaoticTransformationCooldownEndTime = 0;
        this.originalAttributesOnTransform.clear();
        this.chaoticStatAdjustments.clear();

        // Clean up static consumption states for this player.
        PlayerStats.removePlayerConsumptionState(player.getUUID());

        sync();
    }

    /**
     * // Resets only the player's class-specific data (class, specialization, skill points)
     * // to defaults. This is used for class changes without affecting other core stats.
     */
    @Override
    public void resetClassSpecificData() {
        this.playerClass = "";
        this.specialization = "";
        this.skillPoints = 0;
        // Reset affinity bonuses related to class/specialization
        this.classAffinityBonusApplied = 0.0f;
        this.specializationAffinityBonusApplied = 0.0f;

        recalculateStats(); // Recalculate stats as class can affect derived values.
    }

    // // --- Data Copy Method ---

    /**
     * // Copies all player statistics and data from a source {@link IPlayerStats} instance to this one.
     * // This is crucial for handling player clones (e.g., respawning after death, dimension changes)
     * // to ensure data persistence.
     * @param source The source IPlayerStats instance to copy data from.
     */
    @Override
    public void copyFrom(IPlayerStats source) {
        this.attributePoints = source.getAttributePoints();
        this.race = source.getRace();
        this.playerClass = source.getPlayerClass();
        this.specialization = source.getSpecialization();
        this.skillPoints = source.getSkillPoints();
        // Create a new map instance to ensure a deep copy, preventing shared references.
        this.professions = new HashMap<>(source.getProfessions());

        this.constitution = source.getConstitution();
        this.strength = source.getStrength();
        this.dexterity = source.getDexterity();
        this.intelligence = source.getIntelligence();

        // Copy affinity bonuses
        this.classAffinityBonusApplied = source.getClassAffinityBonusApplied();
        this.specializationAffinityBonusApplied = source.getSpecializationAffinityBonusApplied();

        // Recalculate maximum stats based on copied attributes before setting current values.
        int currentLevel = 1;
        if (player instanceof ServerPlayer serverPlayer) {
            Optional<IPlayerXP> xpCapability = serverPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).resolve();
            if (xpCapability.isPresent()) {
                currentLevel = xpCapability.get().getLevel();
            }
        }
        recalculateStatsInternal(currentLevel); // Calculate without syncing here.

        // Set current values using setters with no sync, as a final sync will happen.
        setCurrentHealth(source.getCurrentHealth(), false);
        setCurrentProtection(source.getCurrentProtection(), false);
        setCurrentInnateProtection(source.getCurrentInnateProtection(), false);
        setCurrentMana(source.getCurrentMana(), false);
        setCurrentVigor(source.getCurrentVigor(), false);

        this.favor = source.getFavor();
        this.favorBonusMultiplier = source.getFavorBonusMultiplier();

        this.lastCombatTick = source.getLastCombatTick();
        this.lastCombatExitTick = source.getLastCombatExitTick();
        this.regenSpeedBonusTicks = source.getRegenSpeedBonusTicks();
        this.hungerStage = source.getHungerStage();

        // Copy the state of continuous consumption flags.
        isManaBeingConsumedContinuously.put(player.getUUID(), source.isManaBeingConsumed());
        isVigorBeingConsumedContinuously.put(player.getUUID(), source.isVigorBeingConsumed());

        // Deep copy achievement data.
        this.achievementProgress = new HashMap<>(source.getAchievementProgress());
        this.completedAchievements = new HashMap<>(source.getCompletedAchievements());

        // Deep copy exploration and crafting data.
        this.discoveredBiomes = new HashSet<>(source.getDiscoveredBiomes());
        this.visitedDimensions = new HashSet<>(source.getVisitedDimensions());
        this.craftedUniqueItems = new HashSet<>(source.getCraftedUniqueItems());
        this.tamedAnimals = new HashSet<>(source.getTamedAnimals());

        this.villagerTradesSinceLastFavor = source.getVillagerTradesSinceLastFavor();
        this.lastVillagerFavorGainTick = source.getLastVillagerFavorGainTick();

        // Copy Chimera Chaotic Transformation state
        // Make sure source is of type PlayerStats to access these fields
        if (source instanceof PlayerStats originalStats) {
            this.inChaoticTransformation = originalStats.inChaoticTransformation;
            this.chaoticTransformationEndTime = originalStats.chaoticTransformationEndTime;
            this.chaoticTransformationCooldownEndTime = originalStats.chaoticTransformationCooldownEndTime;
            // Deep copy the maps if they are not null
            this.originalAttributesOnTransform = originalStats.originalAttributesOnTransform != null ? new HashMap<>(originalStats.originalAttributesOnTransform) : new HashMap<>();
            this.chaoticStatAdjustments = originalStats.chaoticStatAdjustments != null ? new HashMap<>(originalStats.chaoticStatAdjustments) : new HashMap<>();
        } else {
            // Default to not in transformation if source is not PlayerStats type
            this.inChaoticTransformation = false;
            this.chaoticTransformationEndTime = 0;
            this.chaoticTransformationCooldownEndTime = 0;
            this.originalAttributesOnTransform.clear();
            this.chaoticStatAdjustments.clear();
        }

        sync(); // Perform a single synchronization after all data has been copied.
    }

    // // --- Favor (Luck) Methods ---

    /**
     * // Applies a configurable Favor modifier to the player's current Favor value.
     * // This method incorporates the `favorBonusMultiplier` and clamps the result
     * // within the race-specific Favor limits.
     * @param actionKey The key identifying the action that modifies Favor (e.g., "TAME_WOLF").
     */
    public void applyFavorModifier(String actionKey) {
        // This will use FavorActionDataConfig in future.
        Float baseModifier = 1.0f; // TEMPORARY: Placeholder for actual favor modifier from config
        if (baseModifier != null) {
            float bonusMultiplier = this.getFavorBonusMultiplier();
            float finalModifier = baseModifier * bonusMultiplier;
            this.favor += finalModifier;

            // Clamp Favor within race-specific limits.
            String playerCurrentRace = this.getRace();
            RaceDataConfig.RaceSettings currentRaceSettings = RaceDataConfig.getInstance().getRaceSettings(playerCurrentRace);
            this.favor = Math.min(this.favor, currentRaceSettings.getFavor()); // Assuming favor max limit is the base favor for now
            this.favor = Math.max(this.favor, 0.0f); // Assuming favor min limit is 0 for now
        }
    }

    /**
     * // Recalculates the `favorBonusMultiplier` based on various in-game factors
     * // (e.g., equipped items, active potion effects).
     * // Currently, this method is a placeholder and should be implemented with actual game logic.
     */
    public void recalculateFavorBonusMultiplier() {
        float totalBonus = 1.0f;
        // TODO: Implement logic to calculate favorBonusMultiplier (e.g., based on equipment, effects, etc.)
        this.favorBonusMultiplier = totalBonus;
    }


    // // --- NBT Serialization and Deserialization (Data Persistence) ---

    /**
     * // Serializes the player's current statistics and progression data to a {@link CompoundTag}.
     * // This method is called by Forge when the player's data needs to be saved (e.g., world save, player logout).
     * @return A CompoundTag containing all serialized player data.
     */
    @Override
    public CompoundTag serializeNBT() {
        CompoundTag nbt = new CompoundTag();
        nbt.putInt("attributePoints", attributePoints);
        nbt.putString("race", race);
        nbt.putString("playerClass", playerClass);
        nbt.putString("specialization", specialization);
        nbt.putInt("skillPoints", skillPoints);
        nbt.putInt("hungerStage", hungerStage);

        // Serialize professions map.
        CompoundTag professionsNBT = new CompoundTag();
        for (Map.Entry<String, Integer> entry : professions.entrySet()) {
            professionsNBT.putInt(entry.getKey(), entry.getValue());
        }
        nbt.put("professions", professionsNBT);

        // Ensure current and max stat values are non-negative before saving to prevent issues.
        nbt.putFloat("currentHealth", Math.max(0, currentHealth));
        nbt.putFloat("maxHealth", Math.max(0, maxHealth));
        nbt.putFloat("currentProtection", Math.max(0, currentProtection));
        nbt.putFloat("maxProtection", Math.max(0, maxProtection));
        nbt.putFloat("currentInnateProtection", Math.max(0, currentInnateProtection));
        nbt.putFloat("maxInnateProtection", Math.max(0, maxInnateProtection));
        nbt.putFloat("currentMana", Math.max(0, currentMana));
        nbt.putFloat("maxMana", Math.max(0, maxMana));
        nbt.putFloat("currentVigor", Math.max(0, currentVigor));
        nbt.putFloat("maxVigor", Math.max(0, maxVigor));
        nbt.putFloat("favor", favor);

        nbt.putInt("constitution", constitution);
        nbt.putInt("strength", strength);
        nbt.putInt("dexterity", dexterity);
        nbt.putInt("intelligence", intelligence);

        nbt.putFloat("favorBonusMultiplier", favorBonusMultiplier);

        nbt.putLong("lastCombatTick", this.lastCombatTick);
        nbt.putLong("lastCombatExitTick", this.lastCombatExitTick);
        nbt.putFloat("regenSpeedBonusTicks", this.regenSpeedBonusTicks);

        // Save the state of continuous consumption flags for this player.
        nbt.putBoolean("isManaBeingConsumedContinuously", isManaBeingConsumedContinuously.getOrDefault(player.getUUID(), false));
        nbt.putBoolean("isVigorBeingConsumedContinuously", isVigorBeingConsumedContinuously.getOrDefault(player.getUUID(), false));

        // Serialize achievement progress (Map<String, Integer>).
        CompoundTag achievementProgressNBT = new CompoundTag();
        for (Map.Entry<String, Integer> entry : achievementProgress.entrySet()) {
            achievementProgressNBT.putInt(entry.getKey(), entry.getValue());
        }
        nbt.put("achievementProgress", achievementProgressNBT);

        // Serialize completed achievements (Map<String, Boolean>).
        CompoundTag completedAchievementsNBT = new CompoundTag();
        for (Map.Entry<String, Boolean> entry : completedAchievements.entrySet()) {
            completedAchievementsNBT.putBoolean(entry.getKey(), entry.getValue());
        }
        nbt.put("completedAchievements", completedAchievementsNBT);

        // Serialize Set of discovered biomes to a ListTag of StringTags.
        ListTag biomesListNBT = new ListTag();
        for (ResourceKey<Biome> biome : discoveredBiomes) {
            biomesListNBT.add(StringTag.valueOf(biome.location().toString()));
        }
        nbt.put("discoveredBiomes", biomesListNBT);

        // Serialize Set of visited dimensions to a ListTag of StringTags.
        ListTag dimensionsListNBT = new ListTag();
        for (ResourceKey<net.minecraft.world.level.Level> dimension : visitedDimensions) {
            dimensionsListNBT.add(StringTag.valueOf(dimension.location().toString()));
        }
        nbt.put("visitedDimensions", dimensionsListNBT);

        // Serialize Set of crafted unique items to a ListTag of StringTags.
        ListTag craftedItemsListNBT = new ListTag();
        for (ResourceLocation item : craftedUniqueItems) {
            craftedItemsListNBT.add(StringTag.valueOf(item.toString()));
        }
        nbt.put("craftedUniqueItems", craftedItemsListNBT);

        // Serialize Set of tamed unique animals to a ListTag of StringTags.
        ListTag tamedAnimalsListNBT = new ListTag();
        for (ResourceLocation animal : tamedAnimals) {
            tamedAnimalsListNBT.add(StringTag.valueOf(animal.toString()));
        }
        nbt.put("tamedAnimals", tamedAnimalsListNBT);

        nbt.putInt("villagerTradesSinceLastFavor", villagerTradesSinceLastFavor);
        nbt.putLong("lastVillagerFavorGainTick", lastVillagerFavorGainTick);

        // Save Chimera Chaotic Transformation state
        nbt.putBoolean("inChaoticTransformation", inChaoticTransformation);
        nbt.putLong("chaoticTransformationEndTime", chaoticTransformationEndTime);
        nbt.putLong("chaoticTransformationCooldownEndTime", chaoticTransformationCooldownEndTime);

        // Save original attributes on transform
        CompoundTag originalAttrNBT = new CompoundTag();
        originalAttributesOnTransform.forEach(originalAttrNBT::putInt);
        nbt.put("originalAttributesOnTransform", originalAttrNBT);

        // Save chaotic stat adjustments (floats)
        CompoundTag chaoticAdjustmentsNBT = new CompoundTag();
        chaoticStatAdjustments.forEach(chaoticAdjustmentsNBT::putFloat);
        nbt.put("chaoticStatAdjustments", chaoticAdjustmentsNBT);

        // Save affinity bonuses
        nbt.putFloat("classAffinityBonusApplied", classAffinityBonusApplied);
        nbt.putFloat("specializationAffinityBonusApplied", specializationAffinityBonusApplied);


        return nbt;
    }

    /**
     * // Loads the player's statistics and progression data from a {@link CompoundTag}.
     * // This method is called by Forge when the player's data is loaded (e.g., world load, player login).
     * // Includes robust error handling and backward compatibility checks for missing NBT tags.
     * @param nbt The CompoundTag containing the serialized player data.
     */
    @Override
    public void deserializeNBT(CompoundTag nbt) {
        // Wrap deserialization in a try-catch for robustness against corrupted or old NBT data.
        try {
            // Load basic attributes first, using .getOrDefault() or .contains() for safety.
            attributePoints = nbt.getInt("attributePoints");
            race = nbt.getString("race");
            playerClass = nbt.contains("playerClass") ? nbt.getString("playerClass") : "";
            specialization = nbt.contains("specialization") ? nbt.getString("specialization") : "";
            skillPoints = nbt.getInt("skillPoints");
            hungerStage = nbt.getInt("hungerStage");

            professions.clear();
            // Check if "professions" tag exists and is of the correct type (CompoundTag) before loading.
            if (nbt.contains("professions", Tag.TAG_COMPOUND)) {
                CompoundTag professionsNBT = nbt.getCompound("professions");
                for (String key : professionsNBT.getAllKeys()) {
                    professions.put(key, professionsNBT.getInt(key));
                }
            } else {
                BrokenPath.LOGGER.warn("NBT 'professions' tag not found or is not a CompoundTag for player {}. Initializing empty professions map.", player.getName().getString());
                professions = new HashMap<>(); // Ensure the map is empty if tag is missing/incorrect.
            }

            // Load core attributes. These are critical for subsequent stat calculations.
            constitution = nbt.getInt("constitution");
            strength = nbt.getInt("strength");
            dexterity = nbt.getInt("dexterity");
            intelligence = nbt.getInt("intelligence");

            // Load affinity bonuses
            this.classAffinityBonusApplied = nbt.getFloat("classAffinityBonusApplied");
            this.specializationAffinityBonusApplied = nbt.getFloat("specializationAffinityBonusApplied");

            final int[] currentLevelHolder = {1}; // Use an array to modify value within lambda.
            // Retrieve player's XP level (server-side only) to accurately recalculate stats.
            if (player instanceof ServerPlayer serverPlayer) {
                player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).resolve().ifPresent(xpCapability -> {
                    currentLevelHolder[0] = xpCapability.getLevel();
                });
            }
            // Recalculate maximum stats based on loaded attributes and level.
            // This ensures that max stats are correct even if configs changed or data was from older versions.
            recalculateStatsInternal(currentLevelHolder[0]);

            // Load current stat values. .getFloat() returns 0.0f if tag is not found.
            float loadedCurrentHealth = nbt.getFloat("currentHealth");
            float loadedCurrentProtection = nbt.getFloat("currentProtection");
            float loadedCurrentInnateProtection = nbt.getFloat("currentInnateProtection");
            float loadedCurrentMana = nbt.getFloat("currentMana");
            float loadedCurrentVigor = nbt.getFloat("currentVigor");

            // Set current values using setters with no sync, as the setters themselves apply clamping.
            // The overall sync will happen later if triggered by PlayerStatEventHandler.
            setCurrentHealth(loadedCurrentHealth, false);
            setCurrentProtection(loadedCurrentProtection, false);
            setCurrentInnateProtection(loadedCurrentInnateProtection, false);
            setCurrentMana(loadedCurrentMana, false);
            setCurrentVigor(loadedCurrentVigor, false);
            favor = nbt.getFloat("favor");
            favorBonusMultiplier = nbt.contains("favorBonusMultiplier") ? nbt.getFloat("favorBonusMultiplier") : 1.0f;

            this.lastCombatTick = nbt.getLong("lastCombatTick");
            this.lastCombatExitTick = nbt.getLong("lastCombatExitTick");
            this.regenSpeedBonusTicks = nbt.contains("regenSpeedBonusTicks") ? nbt.getFloat("regenSpeedBonusTicks") : 0.0F;

            // Load continuous consumption states.
            isManaBeingConsumedContinuously.put(player.getUUID(), nbt.contains("isManaBeingConsumedContinuously") ? nbt.getBoolean("isManaBeingConsumedContinuously") : false);
            isVigorBeingConsumedContinuously.put(player.getUUID(), nbt.contains("isVigorBeingConsumedContinuously") ? nbt.getBoolean("isVigorBeingConsumedContinuously") : false);

            // Load achievement progress (Map<String, Integer>).
            achievementProgress.clear();
            if (nbt.contains("achievementProgress", Tag.TAG_COMPOUND)) {
                CompoundTag progressNBT = nbt.getCompound("achievementProgress");
                for (String key : progressNBT.getAllKeys()) {
                    achievementProgress.put(key, progressNBT.getInt(key));
                }
            }

            // Load completed achievements (Map<String, Boolean>).
            completedAchievements.clear();
            if (nbt.contains("completedAchievements", Tag.TAG_COMPOUND)) {
                CompoundTag completedNBT = nbt.getCompound("completedAchievements");
                for (String key : completedNBT.getAllKeys()) {
                    completedAchievements.put(key, completedNBT.getBoolean(key));
                }
            }

            // Load discovered biomes (ListTag of StringTags).
            discoveredBiomes.clear();
            if (nbt.contains("discoveredBiomes", Tag.TAG_LIST)) {
                ListTag biomesListNBT = nbt.getList("discoveredBiomes", Tag.TAG_STRING);
                for (int i = 0; i < biomesListNBT.size(); i++) {
                    discoveredBiomes.add(ResourceKey.create(Registries.BIOME, new ResourceLocation(biomesListNBT.getString(i))));
                }
            }

            // Load visited dimensions (ListTag of StringTags).
            visitedDimensions.clear();
            if (nbt.contains("visitedDimensions", Tag.TAG_LIST)) {
                ListTag dimensionsListNBT = nbt.getList("visitedDimensions", Tag.TAG_STRING);
                for (int i = 0; i < dimensionsListNBT.size(); i++) {
                    visitedDimensions.add(ResourceKey.create(Registries.DIMENSION, new ResourceLocation(dimensionsListNBT.getString(i))));
                }
            }

            // Load crafted unique items (ListTag of StringTags).
            craftedUniqueItems.clear();
            if (nbt.contains("craftedUniqueItems", Tag.TAG_LIST)) {
                ListTag craftedItemsListNBT = nbt.getList("craftedUniqueItems", Tag.TAG_STRING);
                for (int i = 0; i < craftedItemsListNBT.size(); i++) {
                    craftedUniqueItems.add(new ResourceLocation(craftedItemsListNBT.getString(i))));
                }
            }

            // Load tamed unique animals (ListTag of StringTags).
            tamedAnimals.clear();
            if (nbt.contains("tamedAnimals", Tag.TAG_LIST)) {
                ListTag tamedAnimalsListNBT = nbt.getList("tamedAnimals", Tag.TAG_STRING);
                for (int i = 0; i < tamedAnimalsListNBT.size(); i++) {
                    tamedAnimals.add(new ResourceLocation(tamemodifiedAnimalsListNBT.getString(i))));
                }
            }

            this.villagerTradesSinceLastFavor = nbt.getInt("villagerTradesSinceLastFavor");
            this.lastVillagerFavorGainTick = nbt.getLong("lastVillagerFavorGainTick");

            // Load Chimera Chaotic Transformation state
            this.inChaoticTransformation = nbt.getBoolean("inChaoticTransformation");
            this.chaoticTransformationEndTime = nbt.getLong("chaoticTransformationEndTime");
            this.chaoticTransformationCooldownEndTime = nbt.getLong("chaoticTransformationCooldownEndTime");

            // Load original attributes on transform
            originalAttributesOnTransform.clear();
            if (nbt.contains("originalAttributesOnTransform", Tag.TAG_COMPOUND)) {
                CompoundTag originalAttrNBT = nbt.getCompound("originalAttributesOnTransform");
                for (String key : originalAttrNBT.getAllKeys()) {
                    originalAttributesOnTransform.put(key, originalAttrNBT.getInt(key));
                }
            }

            // Load chaotic stat adjustments
            chaoticStatAdjustments.clear();
            if (nbt.contains("chaoticStatAdjustments", Tag.TAG_COMPOUND)) {
                CompoundTag chaoticAdjustmentsNBT = nbt.getCompound("chaoticAdjustments");
                for (String key : chaoticAdjustmentsNBT.getAllKeys()) {
                    chaoticStatAdjustments.put(key, chaoticAdjustmentsNBT.getFloat(key));
                }
            }


        } catch (Exception e) {
            // If any error occurs during deserialization, log it and reset data to prevent corrupted states.
            BrokenPath.LOGGER.error("Error deserializing PlayerStats for player {}. Resetting data. Stack trace: ", player.getName().getString(), e);
            this.resetData();
        }
    }

    // // --- Data Synchronization with Client ---

    /**
     * // Synchronizes all player statistics data from the server to the client.
     * // This method is essential for keeping the client-side UI and gameplay elements
     * // updated with the most current server-side player data.
     * // Only runs on the server side to prevent client-side desynchronization.
     */
    @Override
    public void sync() {
        if (this.player instanceof ServerPlayer serverPlayer) {
            // Call updateClientData directly with the current server-side stats.
            // This ensures all client-side clamping and deep copying logic is applied.
            // We pass the raw collection types here as updateClientData handles the conversion to List<String> for the packet.
            PlayerStatsClient.setAllStats(
                    this.attributePoints,
                    this.constitution, this.strength, this.dexterity, this.intelligence,
                    this.currentHealth, this.maxHealth,
                    this.currentProtection, this.maxProtection,
                    this.currentInnateProtection, this.maxInnateProtection,
                    this.currentMana, this.maxMana,
                    this.currentVigor, this.maxVigor,
                    this.favor,
                    this.race,
                    this.playerClass,
                    this.specialization,
                    this.skillPoints,
                    this.professions,
                    this.hungerStage,
                    this.favorBonusMultiplier,
                    this.achievementProgress,
                    this.completedAchievements,
                    this.discoveredBiomes.stream().map(biome -> biome.location().toString()).collect(Collectors.toList()),
                    this.visitedDimensions.stream().map(dim -> dim.location().toString()).collect(Collectors.toList()),
                    this.craftedUniqueItems.stream().map(ResourceLocation::toString).collect(Collectors.toList()),
                    this.tamedAnimals.stream().map(ResourceLocation::toString).collect(Collectors.toList())
            );

            // Now send the packet to the client for actual network synchronization
            PacketHandler.sendToPlayer(new SyncPlayerStatsPacket(
                    this.attributePoints,
                    this.constitution, this.strength, this.dexterity, this.intelligence,
                    this.currentHealth, this.maxHealth,
                    this.currentProtection, this.maxProtection,
                    this.currentInnateProtection, this.maxInnateProtection,
                    this.currentMana, this.maxMana,
                    this.currentVigor, this.maxVigor,
                    this.favor,
                    this.race, this.playerClass, this.specialization, this.skillPoints,
                    this.professions,
                    this.hungerStage,
                    this.favorBonusMultiplier,
                    this.achievementProgress,
                    this.completedAchievements,
                    this.discoveredBiomes,
                    this.visitedDimensions,
                    this.craftedUniqueItems,
                    this.tamedAnimals
            ), serverPlayer);
            this.lastHealthSyncTick = serverPlayer.level().getGameTime();
        }
    }

    // // --- Additional Getters and Setters (Specific to PlayerStats) ---

    @Override
    public float getFavorBonusMultiplier() {
        return favorBonusMultiplier;
    }

    @Override
    public void setFavorBonusMultiplier(float multiplier) {
        float maxLimit = MainModConfigManager.getInstance().maxFavorBonusMultiplier;
        this.favorBonusMultiplier = Math.max(1.0f, Math.min(multiplier, maxLimit)); // Clamp between 1.0f and max limit.
    }

    // // --- Combat State Management ---

    @Override
    public long getLastCombatTick() { return lastCombatTick; }
    @Override
    public void setLastCombatTick(long tick) { this.lastCombatTick = tick; }

    /**
     * // Checks if the player is currently considered "in combat."
     * // Combat status is determined by the time elapsed since the last combat action.
     * @param currentTick The current game tick.
     * @return True if the player is in combat, false otherwise.
     */
    @Override
    public boolean isInCombat(long currentTick) {
        return (currentTick - this.lastCombatTick) < RegenDataConfig.getInstance().getHealthDelayAfterCombatTicks();
    }

    /**
     * // Marks the player as having entered combat.
     * // Updates the `lastCombatTick` to the current game time.
     * @param currentTick The current game tick.
     */
    @Override
    public void enterCombat(long currentTick) {
        this.lastCombatTick = currentTick;
    }

    /**
     * // Marks the player as having exited combat.
     * // Resets `lastCombatTick` and records `lastCombatExitTick` to manage regen delays.
     */
    @Override
    public void exitCombat() {
        this.lastCombatTick = 0; // Ensures isInCombat() returns false immediately.
        this.lastCombatExitTick = player.level().getGameTime(); // Record exit time for regen delays.
    }

    @Override
    public long getLastCombatExitTick() { return lastCombatExitTick; }
    @Override
    public float getRegenSpeedBonusTicks() { return this.regenSpeedBonusTicks; }

    // // --- Resource Restoration Methods ---

    @Override public void restoreProtection(float amount) { if (amount > 0) { setCurrentProtection(this.currentProtection + amount, true); } }
    @Override public void restoreMana(float amount) { if (amount > 0) { setCurrentMana(this.currentMana + amount, true); } }
    @Override public void restoreVigor(float amount) { if (amount > 0) { setCurrentVigor(this.currentVigor + amount, true); } }
    @Override public void restoreInnateProtection(float amount) { if (amount > 0) { setCurrentInnateProtection(this.currentInnateProtection + amount, true); } }


    // // --- Continuous Consumption Flags ---

    /**
     * // Sets whether mana is being continuously consumed for this player.
     * // Used by abilities that drain mana over time.
     * @param consuming True if mana is being consumed, false otherwise.
     */
    @Override
    public void setManaBeingConsumed(boolean consuming) {
        // Only update and sync if the state has actually changed.
        if (isManaBeingConsumedContinuously.getOrDefault(player.getUUID(), false) != consuming) {
            isManaBeingConsumedContinuously.put(player.getUUID(), consuming);
        }
    }

    /**
     * // Checks if mana is being continuously consumed for this player.
     * @return True if mana is being consumed, false otherwise.
     */
    @Override
    public boolean isManaBeingConsumed() {
        return isManaBeingConsumedContinuously.getOrDefault(player.getUUID(), false);
    }

    /**
     * // Sets whether vigor is being continuously consumed for this player.
     * // Used by abilities that drain vigor over time.
     * @param consuming True if vigor is being consumed, false otherwise.
     */
    @Override
    public void setVigorBeingConsumed(boolean consuming) {
        // Only update and sync if the state has actually changed.
        if (isVigorBeingConsumedContinuously.getOrDefault(player.getUUID(), false) != consuming) {
            isVigorBeingConsumedContinuously.put(player.getUUID(), consuming);
        }
    }

    /**
     * // Checks if vigor is being continuously consumed for this player.
     * @return True if vigor is being consumed, false otherwise.
     */
    @Override
    public boolean isVigorBeingConsumed() {
        return isVigorBeingConsumedContinuously.getOrDefault(player.getUUID(), false);
    }

    // // --- Achievement Progress Methods ---
    /**
     * // Returns an unmodifiable map of achievement progress.
     * @return A map where keys are achievement IDs and values are current progress.
     */
    @Override
    public Map<String, Integer> getAchievementProgress() {
        return Collections.unmodifiableMap(achievementProgress);
    }
    @Override
    public void setAchievementProgress(String achievementKey, int progress) {
        this.achievementProgress.put(achievementKey, progress);
    }
    @Override
    public int getAchievementProgress(String achievementKey) {
        return achievementProgress.getOrDefault(achievementKey, 0);
    }

    /**
     * // Returns an unmodifiable map of completed achievements.
     * @return A map where keys are achievement IDs and values are boolean completion status.
     */
    @Override
    public Map<String, Boolean> getCompletedAchievements() {
        return Collections.unmodifiableMap(completedAchievements);
    }
    @Override
    public void setAchievementCompleted(String achievementKey, boolean completed) {
        this.completedAchievements.put(achievementKey, completed);
    }
    @Override
    public boolean isAchievementCompleted(String achievementKey) {
        return completedAchievements.getOrDefault(achievementKey, false);
    }

    // // --- Exploration and Crafting Tracking Methods ---

    /**
     * // Returns an unmodifiable set of discovered biomes.
     * @return A set of ResourceKeys representing discovered biomes.
     */
    @Override
    public Set<ResourceKey<Biome>> getDiscoveredBiomes() {
        return Collections.unmodifiableSet(this.discoveredBiomes);
    }
    @Override
    public void addDiscoveredBiome(ResourceKey<Biome> biome) {
        if (this.discoveredBiomes.add(biome)) {
            sync(); // Sync only if a new biome was added.
        }
    }

    /**
     * // Returns an unmodifiable set of visited dimensions.
     * @return A set of ResourceKeys representing visited dimensions.
     */
    @Override
    public Set<ResourceKey<net.minecraft.world.level.Level>> getVisitedDimensions() {
        return Collections.unmodifiableSet(this.visitedDimensions);
    }
    @Override
    public void addVisitedDimension(ResourceKey<net.minecraft.world.level.Level> dimension) {
        if (this.visitedDimensions.add(dimension)) {
            sync(); // Sync only if a new dimension was added.
        }
    }

    /**
     * // Returns an unmodifiable set of unique crafted items.
     * @return A set of ResourceLocations representing unique crafted items.
     */
    @Override
    public Set<ResourceLocation> getCraftedUniqueItems() {
        return Collections.unmodifiableSet(this.craftedUniqueItems);
    }
    @Override
    public void addCraftedUniqueItem(ResourceLocation item) {
        if (this.craftedUniqueItems.add(item)) {
            sync(); // Sync only if a new unique item was added.
        }
    }

    /**
     * // Returns an unmodifiable set of unique tamed animals.
     * @return A set of ResourceLocations representing unique tamed animals.
     */
    @Override
    public Set<ResourceLocation> getTamedAnimals() {
        return Collections.unmodifiableSet(this.tamedAnimals);
    }
    @Override
    public void addTamedAnimal(ResourceLocation entityId) {
        if (this.tamedAnimals.add(entityId)) {
            sync(); // Sync only if a new unique animal was added.
        }
    }

    /**
     * // Removes the continuous mana and vigor consumption state for a specific player.
     * // This static method is called upon player logout to clean up transient data.
     * @param playerUUID The UUID of the player to remove state for.
     */
    public static void removePlayerConsumptionState(UUID playerUUID) {
        isManaBeingConsumedContinuously.remove(playerUUID);
        isVigorBeingConsumedContinuously.remove(playerUUID);
    }

    // // --- Update Client-Side Data from Sync Packet ---
    @Override
    public void updateClientData(int attributePoints,
                                 int constitution, int strength, int dexterity, int intelligence,
                                 float currentHealth, float maxHealth,
                                 float currentProtection, float maxProtection,
                                 float currentInnateProtection, float maxInnateProtection,
                                 float currentMana, float maxMana,
                                 float currentVigor, float maxVigor,
                                 float favor,
                                 String race, String playerClass, String specialization, int skillPoints,
                                 Map<String, Integer> professions,
                                 int hungerStage,
                                 float favorBonusMultiplier,
                                 Map<String, Integer> achievementProgress,
                                 Map<String, Boolean> completedAchievements,
                                 List<String> discoveredBiomesLocations,
                                 List<String> visitedDimensionsLocations,
                                 List<String> craftedUniqueItemsLocations,
                                 List<String> tamedAnimalsLocations) {
        this.attributePoints = attributePoints;
        this.constitution = constitution;
        this.strength = strength;
        this.dexterity = dexterity;
        this.intelligence = intelligence;

        this.maxHealth = maxHealth;
        this.currentHealth = Math.min(Math.max(0, currentHealth), this.maxHealth); // Clamp
        this.maxProtection = maxProtection;
        this.currentProtection = Math.min(Math.max(0, currentProtection), this.maxProtection); // Clamp
        this.maxInnateProtection = maxInnateProtection;
        this.currentInnateProtection = Math.min(Math.max(0, currentInnateProtection), this.maxInnateProtection); // Clamp
        this.maxMana = maxMana;
        this.currentMana = Math.min(Math.max(0, currentMana), this.maxMana); // Clamp
        this.maxVigor = maxVigor;
        this.currentVigor = Math.min(Math.max(0, currentVigor), this.maxVigor); // Clamp

        this.favor = favor;
        this.race = race;
        this.playerClass = playerClass;
        this.specialization = specialization;
        this.skillPoints = skillPoints;
        this.professions = new HashMap<>(professions); // Deep copy
        this.hungerStage = hungerStage;
        this.favorBonusMultiplier = favorBonusMultiplier;

        this.achievementProgress = new HashMap<>(achievementProgress); // Deep copy
        this.completedAchievements = new HashMap<>(completedAchievements); // Deep copy

        // Clear and re-add to sets
        this.discoveredBiomes.clear();
        discoveredBiomesLocations.stream()
                .map(loc -> ResourceKey.create(Registries.BIOME, new ResourceLocation(loc)))
                .forEach(this.discoveredBiomes::add);

        this.visitedDimensions.clear();
        visitedDimensionsLocations.stream()
                .map(loc -> ResourceKey.create(Registries.DIMENSION, new ResourceLocation(loc)))
                .forEach(this.visitedDimensions::add);

        this.craftedUniqueItems.clear();
        craftedUniqueItemsLocations.stream()
                .map(ResourceLocation::new)
                .forEach(this.craftedUniqueItems::add);

        this.tamedAnimals.clear();
        tamedAnimalsLocations.stream()
                .map(ResourceLocation::new)
                .forEach(this.tamedAnimals::add);
    }

    // // --- Villager Trade Favor Cooldown Methods ---
    @Override
    public int getVillagerTradesSinceLastFavor() {
        return villagerTradesSinceLastFavor;
    }

    @Override
    public void setVillagerTradesSinceLastFavor(int count) {
        this.villagerTradesSinceLastFavor = count;
    }

    @Override
    public long getLastVillagerFavorGainTick() {
        return lastVillagerFavorGainTick;
    }

    @Override
    public void setLastVillagerFavorGainTick(long tick) {
        this.lastVillagerFavorGainTick = tick;
    }

    // // Generic helper method to handle setting a stat value with clamping and optional sync.
    // // It returns the clamped value. The caller is responsible for assigning it to the correct field.
    private float updateAndSyncStat(float newValue, float maxValue, float currentValue, boolean doSync) {
        float clampedValue = Math.max(0, Math.min(newValue, maxValue));
        // Only sync if requested, on server side, and if the value actually changed.
        if (doSync && !player.level().isClientSide() && clampedValue != currentValue) {
            sync();
        }
        return clampedValue;
    }

    // // --- Chimera Chaotic Transformation Methods ---

    /**
     * // Initiates the Chaotic Transformation for the player (if they are a Chimera).
     * // Applies random percentage adjustments to stats and sets transformation timers.
     * @param currentTime The current game tick.
     * @return True if transformation was successfully initiated, false otherwise.
     */
    public boolean startChaoticTransformation(long currentTime) {
        // Only Chimera race can transform
        if (!"CHIMERA".equalsIgnoreCase(this.race)) {
            BrokenPath.LOGGER.warn("Player {} is not a Chimera and cannot use Chaotic Transformation.", player.getName().getString());
            return false;
        }

        // Check if already in transformation or on cooldown
        if (this.inChaoticTransformation) {
            BrokenPath.LOGGER.warn("Player {} is already in Chaotic Transformation.", player.getName().getString());
            return false;
        }
        if (currentTime < this.chaoticTransformationCooldownEndTime) {
            long remainingCooldown = (this.chaoticTransformationCooldownEndTime - currentTime) / 20; // in seconds
            BrokenPath.LOGGER.warn("Player {} Chaotic Transformation is on cooldown for {} seconds.", player.getName().getString(), remainingCooldown);
            return false;
        }

        // Get transformation settings
        ChimeraFormDataConfig.ChaoticTransformationSettings settings =
                ChimeraFormDataConfig.getInstance().getTransformationSettings("CHAOTIC_TRANSFORMATION");

        if (settings.getDurationTicks() <= 0) {
            BrokenPath.LOGGER.error("Chaotic Transformation duration is not configured. Cannot start.");
            return false;
        }

        this.inChaoticTransformation = true;
        this.chaoticTransformationEndTime = currentTime + settings.getDurationTicks();
        this.chaoticTransformationCooldownEndTime = 0; // Cooldown starts AFTER transformation ends

        // Store original attributes (not used for direct stat calculation during transformation anymore,
        // but can be used for other side effects if needed, or simply for debugging/state logging.)
        this.originalAttributesOnTransform.put("CONSTITUTION", this.constitution);
        this.originalAttributesOnTransform.put("STRENGTH", this.strength);
        this.originalAttributesOnTransform.put("DEXTERITY", this.dexterity);
        this.originalAttributesOnTransform.put("INTELLIGENCE", this.intelligence);

        // Generate and store random stat adjustments for the duration of transformation
        this.chaoticStatAdjustments.clear();
        // Use StatCalculator.RANDOM for consistency
        this.chaoticStatAdjustments.put("HEALTH", StatCalculator.RANDOM.nextFloat() * (settings.getRandomChangePercentageMax() - settings.getRandomChangePercentageMin()) + settings.getRandomChangePercentageMin());
        this.chaoticStatAdjustments.put("PROTECTION", StatCalculator.RANDOM.nextFloat() * (settings.getRandomChangePercentageMax() - settings.getRandomChangePercentageMin()) + settings.getRandomChangePercentageMin());
        this.chaoticStatAdjustments.put("INNATE_PROTECTION", StatCalculator.RANDOM.nextFloat() * (settings.getRandomChangePercentageMax() - settings.getRandomChangePercentageMin()) + settings.getRandomChangePercentageMin());
        this.chaoticStatAdjustments.put("MANA", StatCalculator.RANDOM.nextFloat() * (settings.getRandomChangePercentageMax() - settings.getRandomChangePercentageMin()) + settings.getRandomChangePercentageMin());
        this.chaoticStatAdjustments.put("VIGOR", StatCalculator.RANDOM.nextFloat() * (settings.getRandomChangePercentageMax() - settings.getRandomChangePercentageMin()) + settings.getRandomChangePercentageMin());

        // Recalculate stats with chaotic adjustments applied
        recalculateStats();
        BrokenPath.LOGGER.info("Player {} initiated Chaotic Transformation. Ends at tick {}.", player.getName().getString(), chaoticTransformationEndTime);
        return true;
    }

    /**
     * // Checks if the chaotic transformation should end and applies cooldown.
     * // Called every tick (e.g., from LivingTickEvent in PlayerStatEventHandler).
     * @param currentTick The current game tick.
     */
    @Override // Implemented from IPlayerStats
    public void handleChaoticTransformationTick(long currentTick) {
        if (!this.inChaoticTransformation) {
            return;
        }

        if (currentTick >= this.chaoticTransformationEndTime) {
            endChaoticTransformation(currentTick);
        }
    }

    /**
     * // Ends the Chaotic Transformation and reverts stats to normal.
     * @param currentTime The current game tick when transformation ends.
     */
    private void endChaoticTransformation(long currentTime) {
        if (!this.inChaoticTransformation) {
            return;
        }

        this.inChaoticTransformation = false;
        this.chaoticTransformationEndTime = 0;

        // Set cooldown
        ChimeraFormDataConfig.ChaoticTransformationSettings settings =
                ChimeraFormDataConfig.getInstance().getTransformationSettings("CHAOTIC_TRANSFORMATION");
        this.chaoticTransformationCooldownEndTime = currentTime + settings.getCooldownTicks();

        // Clear chaotic adjustments
        this.chaoticStatAdjustments.clear();
        this.originalAttributesOnTransform.clear(); // Clear original attributes too

        // Recalculate stats to revert to normal values
        recalculateStats();
        BrokenPath.LOGGER.info("Player {} Chaotic Transformation ended. Cooldown until tick {}.", player.getName().getString(), chaoticTransformationCooldownEndTime);
    }

    /**
     * // Checks if the player is currently in Chaotic Transformation.
     * @return True if in transformation, false otherwise.
     */
    @Override // Implemented from IPlayerStats
    public boolean isInChaoticTransformation() {
        return inChaoticTransformation;
    }

    /**
     * // Retrieves the chaotic stat adjustment for a specific stat.
     * // Used by StatCalculator to apply the random percentage.
     * @param statName The name of the stat (e.g., "HEALTH").
     * @return The random percentage adjustment for that stat, or 0.0f if not in transformation or stat not adjusted.
     */
    @Override // Implemented from IPlayerStats
    public float getChaoticStatAdjustment(String statName) {
        return chaoticStatAdjustments.getOrDefault(statName.toUpperCase(), 0.0f);
    }

    /**
     * // Retrieves the map of chaotic stat adjustments.
     * // This is primarily for debugging or advanced external use.
     * @return An unmodifiable map of stat adjustments during chaotic transformation.
     */
    @Override // Implemented from IPlayerStats
    public Map<String, Float> getChaoticStatAdjustments() {
        return Collections.unmodifiableMap(chaoticStatAdjustments);
    }

    /**
     * // Retrieves the end time of the chaotic transformation.
     * @return The game tick when the transformation will end.
     */
    @Override // Implemented from IPlayerStats
    public long getChaoticTransformationEndTime() {
        return chaoticTransformationEndTime;
    }

    /**
     * // Retrieves the cooldown end time of the chaotic transformation.
     * @return The game tick when the cooldown will end.
     */
    @Override // Implemented from IPlayerStats
    public long getChaoticTransformationCooldownEndTime() {
        return chaoticTransformationCooldownEndTime;
    }
}
