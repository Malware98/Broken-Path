package com.malware98.brokenpath.capabilities;

import com.malware98.brokenpath.calculation.StatCalculator;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;
import com.malware98.brokenpath.data.ModConfigs;
import com.malware98.brokenpath.network.PacketHandler;
import com.malware98.brokenpath.network.messages.SyncPlayerStatsPacket;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.player.Player;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

public class PlayerStats implements IPlayerStats {

    // Atributos de Combate y Bonificaciones Temporales
    private long lastCombatTick; // El último tick en el que el jugador estuvo en combate
    private long lastCombatExitTick; // El tick en el que el jugador salió de combate
    private float favorBonusMultiplier = 1.0f; // Multiplicador para la suerte (puede venir de equipo/efectos)
    private float regenSpeedBonusTicks = 0.0F; // Bonificación a la velocidad de regeneración (en ticks)

    // Atributos de Progresión y Rol del Jugador
    private int attributePoints = 0; // Puntos disponibles para gastar en atributos principales
    private String race = "HUMAN"; // Raza actual del jugador
    private String playerClass = "NO_CLASS"; // Clase actual del jugador
    private String specialization = ""; // Especialización (subclase) del jugador
    private int skillPoints = 0; // Puntos disponibles para gastar en habilidades/árboles de talentos
    private Map<String, Integer> professions; // Niveles de profesiones del jugador

    // Estadísticas Principales del Jugador
    private float currentHealth; // Salud actual del jugador
    private float maxHealth = 20.0f; // Salud máxima del jugador (valor inicial, se recalcula)
    private float currentProtection; // Protección actual que puede absorber daño
    private float maxProtection = 0.0f; // Protección máxima basada en Fuerza y equipamiento (se recalcula)
    private float currentInnateProtection; // NUEVO: Protección Innata actual
    private float maxInnateProtection = 0.0f; // NUEVO: Protección Innata máxima
    private float currentMana; // Maná actual del jugador
    private float maxMana = 0.0f; // Maná máximo del jugador (se recalcula)
    private float currentVigor; // Vigor actual del jugador
    private float maxVigor = 0.0f; // Vigor máximo del jugador (se recalcula)
    private float favor = -40.0f; // Valor de suerte del jugador

    // Atributos Base (manuales/incremental)
    private int constitution = 0; // Atributo de Constitución
    private int strength = 0; // Atributo de Fuerza
    private int dexterity = 0; // Atributo de Destreza
    private int intelligence = 0; // Atributo de Inteligencia

    // --- Referencia al Jugador ---
    private final Player player; // Referencia al objeto Player al que pertenecen estas estadísticas

    // Campo de Hambre
    private int hungerStage = 0; // 0 = Normal, 1 = Moderada, 2 = Intensa, 3 = Famélico

    // Banderas para habilidades de consumo continuo (se almacenan por UUID del jugador)
    private static final Map<UUID, Boolean> isManaBeingConsumedContinuously = new HashMap<>();
    private static final Map<UUID, Boolean> isVigorBeingConsumedContinuously = new HashMap<>();

    // Constructor para PlayerStats.
    public PlayerStats(Player player) {
        this.player = player;
        this.professions = new HashMap<>();

        // Al crear la instancia, inicializamos las estadísticas con el nivel 1
        // y NO llamamos a sync() aquí. La sincronización inicial se maneja en
        // PlayerStatEventHandler.onPlayerLoggedIn/onPlayerRespawn.
        recalculateStatsInternal(1);

        // Establece las estadísticas actuales a sus valores máximos iniciales
        this.currentHealth = this.maxHealth;
        this.currentProtection = this.maxProtection;
        this.currentInnateProtection = this.maxInnateProtection; // NUEVO
        this.currentMana = this.maxMana;
        this.currentVigor = this.maxVigor;

        // Inicializar las banderas de consumo continuo para este jugador
        isManaBeingConsumedContinuously.put(player.getUUID(), false);
        isVigorBeingConsumedContinuously.put(player.getUUID(), false);
    }

    // Métodos de IPlayerStats (Getters y Setters)

    @Override
    public int getAttributePoints() { return attributePoints; }
    @Override
    public void setAttributePoints(int points) { this.attributePoints = points; sync(); }
    @Override
    public void addAttributePoints(int amount) {
        if (amount > 0) { this.attributePoints += amount; }
        sync();
    }

    @Override
    public boolean spendAttributePoints(String attributeName, int amount) {
        if (amount <= 0 || this.attributePoints < amount) return false;

        int currentManualAttributeValue;
        String lowerCaseAttributeName = attributeName.toLowerCase();

        // Determina el valor actual del atributo antes de aplicar el gasto
        switch (lowerCaseAttributeName) {
            case "constitution": currentManualAttributeValue = this.constitution; break;
            case "strength": currentManualAttributeValue = this.strength; break;
            case "dexterity": currentManualAttributeValue = this.dexterity; break;
            case "intelligence": currentManualAttributeValue = this.intelligence; break;
            default: return false;
        }

        // Aplica el límite máximo configurable para el atributo
        int manualAttributeLimit = ModConfigs.getInstance().getManualAttributeLimit(attributeName);
        int potentialNewManualValue = currentManualAttributeValue + amount;

        if (potentialNewManualValue > manualAttributeLimit) {
            amount = manualAttributeLimit - currentManualAttributeValue;
            if (amount <= 0) return false; // No se pueden añadir puntos si ya está en el límite o lo excede
        }

        // Aplica el gasto al atributo correspondiente
        switch (lowerCaseAttributeName) {
            case "constitution": this.constitution += amount; break;
            case "strength": this.strength += amount; break;
            case "dexterity": this.dexterity += amount; break;
            case "intelligence": this.intelligence += amount; break;
        }

        this.attributePoints -= amount;
        recalculateStats(); // Llama al método público que también sincroniza
        return true;
    }

    @Override public String getRace() { return race; }
    @Override public void setRace(String race) { this.race = race; recalculateStats(); sync(); }

    @Override public String getPlayerClass() { return playerClass; }
    @Override public void setPlayerClass(String playerClass) { this.playerClass = playerClass; recalculateStats(); sync(); }

    @Override public String getSpecialization() { return specialization; }
    @Override public void setSpecialization(String specialization) { this.specialization = specialization; recalculateStats(); sync(); }

    @Override public int getSkillPoints() { return skillPoints; }
    @Override public void addSkillPoints(int amount) { if (amount > 0) { this.skillPoints += amount; } sync(); }
    @Override public void spendSkillPoints(int amount) { if (amount > 0 && this.skillPoints >= amount) { this.skillPoints -= amount; sync(); } }

    @Override public Map<String, Integer> getProfessions() { return professions; }
    @Override public void setProfessions(Map<String, Integer> professions) { this.professions = new HashMap<>(professions); sync(); }
    @Override public int getProfessionLevel(String professionName) { return professions.getOrDefault(professionName, 0); }
    @Override public void setProfessionLevel(String professionName, int level) { if (level < 0) { level = 0; } professions.put(professionName, level); sync(); }
    @Override public void addOrUpdateProfession(String professionName, int level) { setProfessionLevel(professionName, level); }
    @Override public void removeProfession(String professionName) { professions.remove(professionName); sync(); }

    // --- Setters de Salud ---
    @Override
    public float getCurrentHealth() { return currentHealth; }
    @Override
    public void setCurrentHealth(float health) {
        setCurrentHealth(health, true);
    }
    @Override
    public void setCurrentHealth(float health, boolean doSync) {
        this.currentHealth = Math.max(0, Math.min(health, this.maxHealth));
        if (doSync) sync();
    }
    @Override
    public float getMaxHealth() { return this.maxHealth; }
    @Override
    public void setMaxHealth(float maxHealth) {
        setMaxHealth(maxHealth, true);
    }
    @Override
    public void setMaxHealth(float maxHealth, boolean doSync) {
        this.maxHealth = maxHealth;
        // Asegurarse de que la salud actual no exceda la nueva salud máxima
        this.currentHealth = Math.min(this.currentHealth, this.maxHealth);
        if (doSync) sync();
    }

    // --- Setters de Protección ---
    @Override
    public float getCurrentProtection() { return currentProtection; }
    @Override
    public void setCurrentProtection(float protection) {
        setCurrentProtection(protection, true);
    }
    @Override
    public void setCurrentProtection(float protection, boolean doSync) {
        this.currentProtection = Math.max(0, Math.min(protection, this.maxProtection));
        if (doSync) sync();
    }
    @Override
    public float getMaxProtection() { return this.maxProtection; }
    @Override
    public void setMaxProtection(float maxProtection) {
        setMaxProtection(maxProtection, true);
    }
    @Override
    public void setMaxProtection(float maxProtection, boolean doSync) {
        this.maxProtection = maxProtection;
        this.currentProtection = Math.min(this.currentProtection, this.maxProtection);
        if (doSync) sync();
    }

    // --- NUEVO: Setters de Protección Innata ---
    @Override
    public float getCurrentInnateProtection() { return currentInnateProtection; }
    @Override
    public void setCurrentInnateProtection(float innateProtection) {
        setCurrentInnateProtection(innateProtection, true);
    }
    @Override
    public void setCurrentInnateProtection(float innateProtection, boolean doSync) {
        this.currentInnateProtection = Math.max(0, Math.min(innateProtection, this.maxInnateProtection));
        if (doSync) sync();
    }
    @Override
    public float getMaxInnateProtection() { return this.maxInnateProtection; }
    @Override
    public void setMaxInnateProtection(float maxInnateProtection) {
        setMaxInnateProtection(maxInnateProtection, true);
    }
    @Override
    public void setMaxInnateProtection(float maxInnateProtection, boolean doSync) {
        this.maxInnateProtection = maxInnateProtection;
        this.currentInnateProtection = Math.min(this.currentInnateProtection, this.maxInnateProtection);
        if (doSync) sync();
    }

    // --- Setters de Maná ---
    @Override
    public float getCurrentMana() { return currentMana; }
    @Override
    public void setCurrentMana(float mana) {
        setCurrentMana(mana, true);
    }
    @Override
    public void setCurrentMana(float mana, boolean doSync) {
        this.currentMana = Math.max(0, Math.min(mana, this.maxMana));
        if (doSync) sync();
    }
    @Override
    public float getMaxMana() { return this.maxMana; }
    @Override
    public void setMaxMana(float maxMana) {
        setMaxMana(maxMana, true);
    }
    @Override
    public void setMaxMana(float maxMana, boolean doSync) {
        this.maxMana = maxMana;
        this.currentMana = Math.min(this.currentMana, this.maxMana);
        if (doSync) sync();
    }

    // --- Setters de Vigor ---
    @Override
    public float getCurrentVigor() { return currentVigor; }
    @Override
    public void setCurrentVigor(float vigor) {
        setCurrentVigor(vigor, true);
    }
    @Override
    public void setCurrentVigor(float vigor, boolean doSync) {
        this.currentVigor = Math.max(0, Math.min(vigor, this.maxVigor));
        if (doSync) sync();
    }
    @Override
    public float getMaxVigor() { return this.maxVigor; }
    @Override
    public void setMaxVigor(float maxVigor) {
        setMaxVigor(maxVigor, true);
    }
    @Override
    public void setMaxVigor(float maxVigor, boolean doSync) {
        this.maxVigor = maxVigor;
        this.currentVigor = Math.min(this.currentVigor, this.maxVigor);
        if (doSync) sync();
    }

    @Override public float getFavor() { return favor; }
    @Override public void setFavor(float favor) { this.favor = favor; sync(); }
    @Override public void addFavor(float amount) { this.favor += amount; sync(); }

    @Override public int getConstitution() { return constitution; }
    @Override public void setConstitution(int constitution) { this.constitution = constitution; recalculateStats(); }
    @Override public int getStrength() { return strength; }
    @Override public void setStrength(int strength) { this.strength = strength; recalculateStats(); }
    @Override public int getDexterity() { return dexterity; }
    @Override public void setDexterity(int dexterity) { this.dexterity = dexterity; recalculateStats(); }
    @Override public int getIntelligence() { return intelligence; }
    @Override public void setIntelligence(int intelligence) { this.intelligence = intelligence; recalculateStats(); }

    @Override public int getHungerStage() {return hungerStage;}

    @Override public void setHungerStage(int hungerStage) {
        if (this.hungerStage != hungerStage) {
            this.hungerStage = hungerStage;
            sync(); // Sincroniza cuando el estado de hambre cambia
        }
    }

    // Recalcula todas las estadísticas máximas del jugador (Salud, Maná, Vigor, Protección)
    // Este método es público y se encarga de obtener el nivel y luego llamar a la lógica interna y sincronizar.
    @Override
    public void recalculateStats() {
        int currentLevel = 1; // Valor predeterminado
        // Obtener el nivel real del jugador si está en el servidor
        if (player instanceof ServerPlayer serverPlayer) {
            Optional<IPlayerXP> xpCapability = serverPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).resolve();
            if (xpCapability.isPresent()) {
                currentLevel = xpCapability.get().getLevel();
            }
        }
        recalculateStatsInternal(currentLevel); // Llama a la lógica de cálculo sin sincronizar
        sync(); // Sincroniza una única vez después de que todos los cálculos se han completado
    }

    // Lógica interna para recalcular las estadísticas máximas.
    // Este método NO LLAMA A sync() y solo actualiza los campos internos.
    private void recalculateStatsInternal(int currentLevel) {
        String currentRace = this.getRace();
        String currentPlayerClass = this.getPlayerClass();

        // Recalculo de Salud Máxima
        float newMaxHealth = StatCalculator.calculateHealth(currentRace, currentPlayerClass, this.constitution);
        setMaxHealth(newMaxHealth, false); // Usamos el setter interno sin sincronizar

        // Recalculo de Maná Máximo
        float newMaxMana = StatCalculator.calculateMana(currentRace, currentPlayerClass, this.intelligence);
        setMaxMana(newMaxMana, false);

        // Recalculo de Vigor Máximo
        float newMaxVigor = StatCalculator.calculateVigor(currentRace, currentPlayerClass, this.dexterity);
        setMaxVigor(newMaxVigor, false);

        // Recalculo de Protección Máxima (basada en STR)
        float newMaxProtectionSTR = StatCalculator.calculateProtectionFromSTR(currentRace, currentPlayerClass, this.strength);
        setMaxProtection(newMaxProtectionSTR, false);

        // NUEVO: Recalculo de Protección Innata Máxima
        float newMaxInnateProtection = StatCalculator.calculateInnateProtection(currentRace, currentLevel);
        setMaxInnateProtection(newMaxInnateProtection, false); // Usa el nuevo setter sin sincronizar

        // Recalculo de Suerte
        ModConfigs.FavorConfig favorConfig = ModConfigs.getInstance().getRaceFavorConfig(currentRace);
        if (favorConfig != null) {
            float calculatedFavor = favorConfig.baseFavor;
            calculatedFavor = Math.min(calculatedFavor, favorConfig.maxLimit);
            calculatedFavor = Math.max(calculatedFavor, favorConfig.minLimit);
            this.favor = calculatedFavor; // Asignación directa, ya que setFavor llama a sync()
        } else {
            this.favor = 0.0f; // Fallback si no hay configuración de suerte para la raza
        }
    }

    // Métodos de Reseteo de Datos

    // Resetea todas las estadísticas y progresión del jugador a sus valores predeterminados.
    @Override
    public void resetData() {
        this.attributePoints = 0;
        this.race = "HUMAN";
        this.playerClass = "NO_CLASS";
        this.specialization = "";
        this.skillPoints = 0;
        this.professions.clear();

        this.constitution = 0;
        this.strength = 0;
        this.dexterity = 0;
        this.intelligence = 0;

        // Recalcula y luego sincroniza
        recalculateStats();

        // Asegurarse de que las estadísticas actuales también se reinicien a sus máximos
        setCurrentHealth(this.maxHealth, false);
        setCurrentProtection(this.maxProtection, false);
        setCurrentInnateProtection(this.maxInnateProtection, false); // NUEVO
        setCurrentMana(this.maxMana, false);
        setCurrentVigor(this.maxVigor, false);

        sync(); // Sincronización final
    }

    // Resetea solo los datos específicos de la clase del jugador (clase, especialización, puntos de habilidad).
    @Override
    public void resetClassSpecificData() {
        this.playerClass = "NO_CLASS";
        this.specialization = "";
        this.skillPoints = 0;
        recalculateStats(); // Recalcula y sincroniza
    }

    // Métodos de Copia de Datos

    // Copia todas las estadísticas de una fuente IPlayerStats a esta instancia.
    @Override
    public void copyFrom(IPlayerStats source) {
        this.attributePoints = source.getAttributePoints();
        this.race = source.getRace();
        this.playerClass = source.getPlayerClass();
        this.specialization = source.getSpecialization();
        this.skillPoints = source.getSkillPoints();
        this.professions = new HashMap<>(source.getProfessions());

        this.constitution = source.getConstitution();
        this.strength = source.getStrength();
        this.dexterity = source.getDexterity();
        this.intelligence = source.getIntelligence();

        // Recalcular las estadísticas máximas basadas en los datos copiados
        int currentLevel = 1; // Default
        if (player instanceof ServerPlayer serverPlayer) {
            Optional<IPlayerXP> xpCapability = serverPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).resolve();
            if (xpCapability.isPresent()) {
                currentLevel = xpCapability.get().getLevel();
            }
        }
        recalculateStatsInternal(currentLevel); // Sin sincronizar aquí

        // Establecer los valores actuales, usando los setters con doSync=false
        setCurrentHealth(source.getCurrentHealth(), false);
        setCurrentProtection(source.getCurrentProtection(), false);
        setCurrentInnateProtection(source.getCurrentInnateProtection(), false);
        setCurrentMana(source.getCurrentMana(), false);
        setCurrentVigor(source.getCurrentVigor(), false);

        // La suerte y el multiplicador de suerte también se copian
        this.favor = source.getFavor();
        this.favorBonusMultiplier = source.getFavorBonusMultiplier();

        this.lastCombatTick = source.getLastCombatTick();
        this.lastCombatExitTick = source.getLastCombatExitTick();
        this.regenSpeedBonusTicks = source.getRegenSpeedBonusTicks();
        this.hungerStage = source.getHungerStage();

        sync(); // Sincroniza una única vez al final de la copia
    }

    // Aplica un modificador de suerte al valor de suerte del jugador basado en una acción.
    public void applyFavorModifier(String actionKey) {
        Float baseModifier = ModConfigs.getInstance().favorActionModifiers.get(actionKey.toUpperCase());
        if (baseModifier != null) {
            float bonusMultiplier = this.getFavorBonusMultiplier();
            float finalModifier = baseModifier * bonusMultiplier;
            this.favor += finalModifier;

            String playerCurrentRace = this.getRace();
            ModConfigs.FavorConfig currentFavorConfig = ModConfigs.getInstance().getRaceFavorConfig(playerCurrentRace);
            if (currentFavorConfig != null) {
                this.favor = Math.min(this.favor, currentFavorConfig.maxLimit);
                this.favor = Math.max(this.favor, currentFavorConfig.minLimit);
            } else {
                this.favor = Math.min(this.favor, 90.0f);
                this.favor = Math.max(this.favor, -90.0f);
            }

            sync();
        }
    }

    // Recalcula el multiplicador de bonus de suerte del jugador (basado en equipo, efectos, etc.).
    public void recalculateFavorBonusMultiplier() {
        float totalBonus = 1.0f;
        // TODO: Implementar lógica para calcular favorBonusMultiplier
        this.favorBonusMultiplier = totalBonus; // Asegúrate de asignar el resultado
        sync(); // Sincroniza el cambio en el multiplicador
    }

    // Métodos de Serialización y Deserialization (Persistencia)

    // Guarda el estado actual de las estadísticas del jugador en un CompoundTag (NBT) para persistencia en el disco.
    @Override
    public CompoundTag serializeNBT() {
        CompoundTag nbt = new CompoundTag();
        nbt.putInt("AttributePoints", attributePoints);
        nbt.putString("Race", race);
        nbt.putString("PlayerClass", playerClass);
        nbt.putString("Specialization", specialization);
        nbt.putInt("SkillPoints", skillPoints);

        nbt.putInt("HungerStage", hungerStage);

        CompoundTag professionsNBT = new CompoundTag();
        for (Map.Entry<String, Integer> entry : professions.entrySet()) {
            professionsNBT.putInt(entry.getKey(), entry.getValue());
        }
        nbt.put("Professions", professionsNBT);

        nbt.putFloat("CurrentHealth", currentHealth);
        nbt.putFloat("MaxHealth", maxHealth);
        nbt.putFloat("CurrentProtection", currentProtection);
        nbt.putFloat("MaxProtection", maxProtection);
        nbt.putFloat("CurrentInnateProtection", currentInnateProtection); // NUEVO
        nbt.putFloat("MaxInnateProtection", maxInnateProtection); // NUEVO
        nbt.putFloat("CurrentMana", currentMana);
        nbt.putFloat("MaxMana", maxMana);
        nbt.putFloat("CurrentVigor", currentVigor);
        nbt.putFloat("MaxVigor", maxVigor);
        nbt.putFloat("Favor", favor);

        nbt.putInt("Constitution", constitution);
        nbt.putInt("Strength", strength);
        nbt.putInt("Dexterity", dexterity);
        nbt.putInt("Intelligence", intelligence);

        nbt.putFloat("FavorBonusMultiplier", favorBonusMultiplier);

        nbt.putLong("LastCombatTick", this.lastCombatTick);
        nbt.putLong("LastCombatExitTick", this.lastCombatExitTick);
        nbt.putFloat("RegenSpeedBonusTicks", this.regenSpeedBonusTicks);

        // Guardar el estado de consumo continuo
        nbt.putBoolean("IsManaBeingConsumedContinuously", isManaBeingConsumedContinuously.getOrDefault(player.getUUID(), false));
        nbt.putBoolean("IsVigorBeingConsumedContinuously", isVigorBeingConsumedContinuously.getOrDefault(player.getUUID(), false));

        return nbt;
    }

    // Carga las estadísticas del jugador desde un CompoundTag (NBT).
    @Override
    public void deserializeNBT(CompoundTag nbt) {
        attributePoints = nbt.getInt("AttributePoints");
        race = nbt.getString("Race");
        playerClass = nbt.getString("PlayerClass");
        specialization = nbt.getString("Specialization");
        skillPoints = nbt.getInt("SkillPoints");

        hungerStage = nbt.getInt("HungerStage");

        professions.clear();
        CompoundTag professionsNBT = nbt.getCompound("Professions");
        for (String key : professionsNBT.getAllKeys()) {
            professions.put(key, professionsNBT.getInt(key));
        }

        // Cargar atributos base PRIMERO para que recalculateStats los use
        constitution = nbt.getInt("Constitution");
        strength = nbt.getInt("Strength");
        dexterity = nbt.getInt("Dexterity");
        intelligence = nbt.getInt("Intelligence");

        int currentLevel = 1; // Default
        // Solo si es el lado del servidor para obtener el nivel real
        if (player instanceof ServerPlayer serverPlayer) {
            Optional<IPlayerXP> xpCapability = serverPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).resolve();
            if (xpCapability.isPresent()) {
                currentLevel = xpCapability.get().getLevel();
            }
        }
        // Después de cargar los atributos, recalcula todas las estadísticas máximas.
        recalculateStatsInternal(currentLevel); // Llama al método interno sin sync()

        // Cargar los valores actuales, ajustándolos a los máximos recién calculados
        setCurrentHealth(nbt.getFloat("CurrentHealth"), false);
        setCurrentProtection(nbt.getFloat("CurrentProtection"), false);
        setCurrentInnateProtection(nbt.getFloat("CurrentInnateProtection"), false); // NUEVO
        setCurrentMana(nbt.getFloat("CurrentMana"), false);
        setCurrentVigor(nbt.getFloat("CurrentVigor"), false);

        favor = nbt.getFloat("Favor");
        favorBonusMultiplier = nbt.getFloat("FavorBonusMultiplier");

        this.lastCombatTick = nbt.getLong("LastCombatTick");
        this.lastCombatExitTick = nbt.getLong("LastCombatExitTick");
        this.regenSpeedBonusTicks = nbt.contains("RegenSpeedBonusTicks") ? nbt.getFloat("RegenSpeedBonusTicks") : 0.0F;

        // Cargar el estado de consumo continuo
        isManaBeingConsumedContinuously.put(player.getUUID(), nbt.getBoolean("IsManaBeingConsumedContinuously"));
        isVigorBeingConsumedContinuously.put(player.getUUID(), nbt.getBoolean("IsVigorBeingConsumedContinuously"));

        // Si es el lado del servidor, actualizar la salud vanilla del jugador.
        if (!player.level().isClientSide() && player instanceof ServerPlayer serverPlayer) {
            serverPlayer.setHealth(currentHealth);
        }
        // NO llamar a sync() aquí. La primera sincronización la gestiona el PlayerLoggedInEvent.
    }

    // Sincronización con el Cliente
    @Override
    public void sync() {
        if (this.player instanceof ServerPlayer serverPlayer) {
            PacketHandler.sendToPlayer(new SyncPlayerStatsPacket(
                    this.attributePoints,
                    this.constitution, this.strength, this.dexterity, this.intelligence,
                    this.currentHealth, this.maxHealth,
                    this.currentProtection, this.maxProtection,
                    this.currentInnateProtection, this.maxInnateProtection, // NUEVO
                    this.currentMana, this.maxMana,
                    this.currentVigor, this.maxVigor,
                    this.favor,
                    this.race, this.playerClass, this.specialization, this.skillPoints,
                    this.professions,
                    this.hungerStage,
                    this.favorBonusMultiplier
            ), serverPlayer);
        }
    }

    // Getters y Setters Adicionales (específicos de PlayerStats, no en IPlayerStats)

    @Override
    public float getFavorBonusMultiplier() {
        return favorBonusMultiplier;
    }

    @Override
    public void setFavorBonusMultiplier(float multiplier) {
        float maxLimit = ModConfigs.getInstance().maxFavorBonusMultiplier;
        this.favorBonusMultiplier = Math.max(1.0f, Math.min(multiplier, maxLimit));
        sync();
    }

    // Método getInnateProtection() que ahora devuelve maxInnateProtection
    // Si bien la interfaz todavía tiene getInnateProtection(), esta implementación la usa como getter para el máximo.
    // Una vez que se elimine de la interfaz, este método podría desaparecer si no es necesario.
    // Actualmente en IPlayerStats está comentado. En la siguiente iteración se puede eliminar del todo.
    // @Override
    // public float getInnateProtection() {
    //    return this.maxInnateProtection;
    // }

    // Métodos de Estado de Combate

    @Override
    public long getLastCombatTick() {
        return lastCombatTick;
    }

    @Override
    public void setLastCombatTick(long tick) {
        this.lastCombatTick = tick;
    }

    @Override
    public boolean isInCombat(long currentTick) {
        // El jugador está en combate si el último tick de combate fue dentro del umbral de tiempo
        return (currentTick - this.lastCombatTick) < ModConfigs.getInstance().getHealthDelayAfterCombatTicks(); // Usar el mismo delay que para salud
    }

    // Marca al jugador como "en combate"
    @Override
    public void enterCombat(long currentTick) {
        this.lastCombatTick = currentTick;
    }

    @Override
    public void exitCombat() {
        // Reinicia el tick de combate a 0 para asegurar que el jugador no esté en combate.
        this.lastCombatTick = 0; // Esto asegura que isInCombat() sea falso
        this.lastCombatExitTick = player.level().getGameTime(); // Registra el momento de salida
        sync(); // Sincroniza el estado de combate
    }

    @Override
    public long getLastCombatExitTick() {
        return lastCombatExitTick;
    }

    @Override
    public float getRegenSpeedBonusTicks() {
        return this.regenSpeedBonusTicks;
    }

    @Override
    public void restoreProtection(float amount) {
        if (amount > 0) {
            // Asegura que la protección actual no exceda la protección máxima
            setCurrentProtection(this.currentProtection + amount, true); // Usa el setter que sincroniza
        }
    }

    @Override
    public void restoreMana(float amount) {
        if (amount > 0) {
            // Asegura que el maná actual no exceda el maná máximo
            setCurrentMana(this.currentMana + amount, true); // Usa el setter que sincroniza
        }
    }

    @Override
    public void restoreVigor(float amount) {
        if (amount > 0) {
            // Asegura que el vigor actual no exceda el vigor máximo
            setCurrentVigor(this.currentVigor + amount, true); // Usa el setter que sincroniza
        }
    }

    // NUEVO: Restaurar Protección Innata
    @Override
    public void restoreInnateProtection(float amount) {
        if (amount > 0) {
            setCurrentInnateProtection(this.currentInnateProtection + amount, true); // Usa el setter que sincroniza
        }
    }

    @Override
    public void setManaBeingConsumed(boolean consuming) {
        if (isManaBeingConsumedContinuously.getOrDefault(player.getUUID(), false) != consuming) {
            isManaBeingConsumedContinuously.put(player.getUUID(), consuming);
            sync();
        }
    }

    @Override
    public boolean isManaBeingConsumed() {
        return isManaBeingConsumedContinuously.getOrDefault(player.getUUID(), false);
    }

    @Override
    public void setVigorBeingConsumed(boolean consuming) {
        if (isVigorBeingConsumedContinuously.getOrDefault(player.getUUID(), false) != consuming) {
            isVigorBeingConsumedContinuously.put(player.getUUID(), consuming);
            sync();
        }
    }

    @Override
    public boolean isVigorBeingConsumed() {
        return isVigorBeingConsumedContinuously.getOrDefault(player.getUUID(), false);
    }
}
