package com.malware98.brokenpath.capabilities;

import com.malware98.brokenpath.BrokenPath;
import com.malware98.brokenpath.calculation.StatCalculator;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;
import com.malware98.brokenpath.client.PlayerStatsClient;
import com.malware98.brokenpath.data.config.*;
import com.malware98.brokenpath.network.PacketHandler;
import com.malware98.brokenpath.network.messages.SyncPlayerStatsPacket;
import net.minecraft.core.registries.Registries;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.nbt.ListTag;
import net.minecraft.nbt.StringTag;
import net.minecraft.nbt.Tag;
import net.minecraft.resources.ResourceKey;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.biome.Biome;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Implementation of the {@link IPlayerStats} interface.
 * This class manages all detailed player statistics and attributes,
 * including health, mana, vigor, protection, core attributes, race, class,
 * professions, combat state, hunger, luck, and achievement progression.
 * It handles stat calculations, data persistence (NBT), and synchronization
 * between the server and client.
 */
public class PlayerStats implements IPlayerStats {

    // --- Combat and Temporary Bonuses ---
    // The last game tick when the player was engaged in combat. Used to determine combat status.
    private long lastCombatTick;
    // The game tick when the player last exited combat. Used for out-of-combat regeneration delays.
    private long lastCombatExitTick;
    // A multiplier applied to Favor (luck) gains and losses, influenced by equipment or effects.
    private float favorBonusMultiplier = 1.0f;
    // A bonus (in ticks) that reduces health regeneration cooldown.
    private float regenSpeedBonusTicks = 0.0F;

    // --- Sync Cooldown Fields ---
    private long lastHealthSyncTick = 0; // Last game tick when health was synchronized.

    // --- Player Progression and Role Attributes ---
    // Points available for the player to manually allocate to core attributes (Constitution, Strength, etc.).
    private int attributePoints = 0;
    // The player's current race (e.g., "HUMAN", "ELF").
    private String race = "SPIRIT"; // MODIFIED: Default to "SPIRIT"
    // The player's current class (e.g., "WARRIOR", "MAGE").
    private String playerClass = "NO_CLASS";
    // The player's chosen specialization within their class.
    private String specialization = "";
    // Skill points available for abilities or talent trees.
    private int skillPoints = 0;
    // A map storing the player's professions and their respective levels (e.g., "MINING": 5).
    private Map<String, Integer> professions;

    // --- Primary Player Statistics ---
    // Current health of the player.
    private float currentHealth;
    // Maximum health of the player, calculated based on attributes and race/class.
    private float maxHealth = 20.0f;
    // Current Protection (STR-based) that absorbs incoming damage.
    private float currentProtection;
    // Maximum Protection (STR-based), calculated based on Strength and race/class.
    private float maxProtection = 0.0f;
    // Current Innate Protection, a passive damage reduction that regenerates.
    private float currentInnateProtection;
    // Maximum Innate Protection, calculated based on level and race.
    private float maxInnateProtection = 0.0f;
    // Current mana, used for casting spells or abilities.
    private float currentMana;
    // Maximum mana.
    private float maxMana = 0.0f;
    // Current vigor, used for physical abilities or movement.
    private float currentVigor;
    // Maximum vigor.
    private float maxVigor = 0.0f;
    // The player's Favor (luck) value, influencing various in-game events.
    private float favor = 0.0f;

    // --- Core Attributes (Manual Allocation / Incremental) ---
    // Constitution attribute: affects health and resilience.
    private int constitution = 0;
    // Strength attribute: affects physical damage and STR-based protection.
    private int strength = 0;
    // Dexterity attribute: affects speed, evasion, and vigor.
    private int dexterity = 0;
    // Intelligence attribute: affects mana and magical power.
    private int intelligence = 0;

    // --- Player Reference ---
    // Reference to the actual Player entity associated with these stats.
    private final Player player;

    // --- Hunger State ---
    // Current hunger stage of the player (0 = Normal, 1 = Moderate, 2 = Intense, 3 = Starving).
    private int hungerStage = 0;

    // --- Flags for Continuous Resource Consumption (Static per Player) ---
    // Static map to track if mana is being continuously consumed for each player (by UUID).
    // This is static because it represents a transient state that can be set by external systems.
    private static final Map<UUID, Boolean> isManaBeingConsumedContinuously = new HashMap<>();
    // Static map to track if vigor is being continuously consumed for each player (by UUID).
    // This is static because it represents a transient state that can be set by external systems.
    private static final Map<UUID, Boolean> isVigorBeingConsumedContinuously = new HashMap<>();

    // --- Achievement and Exploration Data ---
    // Stores the numerical progress towards each achievement (e.g., "WALK_1000_STEPS": 500 blocks walked).
    private Map<String, Integer> achievementProgress;
    // Stores whether a specific achievement has been completed (e.g., "FIRST_KILL": true).
    private Map<String, Boolean> completedAchievements;
    // Set of unique animal entity IDs that the player has tamed. Used for "Tireless Shepherd".
    private Set<ResourceLocation> tamedAnimals;
    // Set of unique biome ResourceKeys the player has discovered. Used for exploration achievements.
    private Set<ResourceKey<Biome>> discoveredBiomes;
    // Set of unique dimension ResourceKeys the player has visited. Used for dimension-related achievements.
    private Set<ResourceKey<Level>> visitedDimensions;
    // Set of unique item ResourceLocations that the player has crafted. Used for crafting achievements.
    private Set<ResourceLocation> craftedUniqueItems;

    // Cooldown for villager trading favor gain
    private int villagerTradesSinceLastFavor;
    private long lastVillagerFavorGainTick;

    // --- Chimera Chaotic Transformation ---
    private boolean inChaoticTransformation;
    private long chaoticTransformationEndTime;
    private long chaoticTransformationCooldownEndTime;
    private Map<String, Float> chaoticStatAdjustments; // Stores the random percentage adjustments for each stat


    // --- Constructor ---

    /**
     * Constructs a new PlayerStats instance for a given player.
     * Initializes all stats to default values and sets up necessary collections.
     * @param player The player entity for whom these stats are managed.
     */
    public PlayerStats(Player player) {
        this.player = player;
        this.professions = new HashMap<>();
        this.achievementProgress = new HashMap<>();
        this.completedAchievements = new HashMap<>();
        this.tamedAnimals = new HashSet<>();
        this.discoveredBiomes = new HashSet<>();
        this.visitedDimensions = new HashSet<>();
        this.craftedUniqueItems = new HashSet<>();
        this.chaoticStatAdjustments = new HashMap<>();


        // Ensure default race is set before initial stat calculation
        // ModConfigs.getInstance().getRaceFavorConfig(race) will use this default if no NBT is loaded yet.
        this.race = "SPIRIT"; // MODIFIED: Explicitly set default race in constructor to SPIRIT

        // Set initial favor based on the default race.
        // MODIFIED: Use RaceDataConfig directly for favor.
        this.favor = RaceDataConfig.getInstance().getRaceSettings(this.race).getFavor(); //


        // Initialize stats with base values (typically level 1 values).
        // This will calculate max stats based on the default "SPIRIT" race.
        recalculateStatsInternal(1);

        // Set current stats to their initial maximums at creation.
        // This ensures the player starts with full health/mana/vigor/protection.
        this.currentHealth = this.maxHealth;
        this.currentProtection = this.maxProtection;
        this.currentInnateProtection = this.maxInnateProtection;
        this.currentMana = this.maxMana;
        this.currentVigor = this.maxVigor;

        // Initialize continuous consumption flags for this player's UUID.
        isManaBeingConsumedContinuously.put(player.getUUID(), false);
        isVigorBeingConsumedContinuously.put(player.getUUID(), false);

        // Initialize new cooldown fields
        this.villagerTradesSinceLastFavor = 0;
        this.lastVillagerFavorGainTick = 0;

        // Initialize Chimera transformation state
        this.inChaoticTransformation = false;
        this.chaoticTransformationEndTime = 0;
        this.chaoticTransformationCooldownEndTime = 0;
    }

    // --- IPlayerStats Interface Implementation (Getters and Setters) ---

    // --- Attribute Points ---
    @Override
    public int getAttributePoints() { return attributePoints; }
    @Override
    public void setAttributePoints(int points) { this.attributePoints = points; }
    @Override
    public void addAttributePoints(int amount) {
        if (amount > 0) { this.attributePoints += amount; }
    }

    /**
     * Spends a specified amount of attribute points on a given attribute.
     * Applies configurable manual allocation limits to prevent over-allocation.
     * @param attributeName The name of the attribute (e.g., "CONSTITUTION").
     * @param amount The number of points to spend.
     * @return True if points were successfully spent, false otherwise (e.g., insufficient points, hit limit).
     */
    @Override
    public boolean spendAttributePoints(String attributeName, int amount) {
        if (amount <= 0 || this.attributePoints < amount) return false;

        int currentManualAttributeValue;
        String lowerCaseAttributeName = attributeName.toLowerCase();

        switch (lowerCaseAttributeName) {
            case "constitution": currentManualAttributeValue = this.constitution; break;
            case "strength": currentManualAttributeValue = this.strength; break;
            case "dexterity": currentManualAttributeValue = this.dexterity; break;
            case "intelligence": currentManualAttributeValue = this.intelligence; break;
            default: return false; // Atributo no reconocido
        }

        // Apply configurable maximum limit for manual attribute allocation.
        // MODIFIED: Use AttributeConfig directly.
        int manualAttributeLimit = AttributeConfig.getInstance().getManualAllocationLimit(attributeName); //
        int potentialNewManualValue = currentManualAttributeValue + amount;

        // Adjust amount if it exceeds the limit.
        if (potentialNewManualValue > manualAttributeLimit) {
            amount = manualAttributeLimit - currentManualAttributeValue;
            if (amount <= 0) return false;
        }

        // Apply the spent points to the corresponding attribute.
        switch (lowerCaseAttributeName) {
            case "constitution": this.constitution += amount; break;
            case "strength": this.strength += amount; break;
            case "dexterity": this.dexterity += amount; break;
            case "intelligence": this.intelligence += amount; break;
        }

        this.attributePoints -= amount; // Subtract spent points from available pool.
        recalculateStats(); // Recalculate derived stats (health, mana, etc.) and synchronize.
        return true;
    }

    // --- Race, Class, Specialization ---
    @Override public String getRace() { return race; }
    @Override public void setRace(String race) { this.race = race;
        // MODIFIED: Use RaceDataConfig directly for favor.
        this.favor = RaceDataConfig.getInstance().getRaceSettings(race).getFavor(); //
        recalculateStats();
    }
    @Override public String getPlayerClass() { return playerClass; }
    @Override public void setPlayerClass(String playerClass) { this.playerClass = playerClass; recalculateStats(); }
    @Override public String getSpecialization() { return specialization; }
    @Override public void setSpecialization(String specialization) { this.specialization = specialization; recalculateStats(); }

    // --- Skill Points ---
    @Override public int getSkillPoints() { return skillPoints; }
    @Override public void addSkillPoints(int amount) { if (amount > 0) { this.skillPoints += amount; } }
    @Override public void spendSkillPoints(int amount) { if (amount > 0 && this.skillPoints >= amount) { this.skillPoints -= amount; } }

    // --- Professions ---
    /**
     * Returns an unmodifiable view of the player's professions map.
     * This prevents external modification of the internal map.
     * @return An unmodifiable map of professions and their levels.
     */
    @Override public Map<String, Integer> getProfessions() { return Collections.unmodifiableMap(professions); }
    @Override public void setProfessions(Map<String, Integer> professions) { this.professions = new HashMap<>(professions); }
    @Override public int getProfessionLevel(String professionName) { return professions.getOrDefault(professionName, 0); }
    @Override public void setProfessionLevel(String professionName, int level) { if (level < 0) { level = 0; } professions.put(professionName, level); }
    @Override public void addOrUpdateProfession(String professionName, int level) { setProfessionLevel(professionName, level); }
    @Override public void removeProfession(String professionName) { professions.remove(professionName); }

    // --- Setters/Getters de Salud ---

    // --- Health ---
    @Override public float getCurrentHealth() { return currentHealth; }
    @Override public void setCurrentHealth(float health) { setCurrentHealth(health, true); }
    @Override public void setCurrentHealth(float health, boolean doSync) {
        float oldHealth = this.currentHealth; // Store old value before clamping for sync check

        // Clamp health within bounds directly here for clarity in this critical method
        this.currentHealth = Math.max(0, Math.min(health, this.maxHealth));

        // RE-INTEGRADO: Si en el lado del servidor, establece explícitamente la salud de vainilla para que coincida con la salud del mod.
        // Esto es crucial para que la barra de salud de vainilla se actualice inmediatamente (aunque esté oculta, es la "fuente de verdad" de Minecraft).
        // Solo actualiza vainilla si la salud del mod realmente cambió para evitar llamadas redundantes.
        if (!player.level().isClientSide() && player instanceof ServerPlayer serverPlayer && oldHealth != this.currentHealth) {
            serverPlayer.setHealth(this.currentHealth);
        }

        // Solo sincroniza si doSync es true, en el lado del servidor, y si el valor realmente cambió.
        // Esto asegura que el cliente reciba actualizaciones inmediatas de salud para el HUD.
        if (doSync && !player.level().isClientSide() && oldHealth != this.currentHealth) {
            sync();
        }
    }
    @Override public float getMaxHealth() { return this.maxHealth; }
    @Override public void setMaxHealth(float maxHealth) { setMaxHealth(maxHealth, true); }
    @Override public void setMaxHealth(float maxHealth, boolean doSync) {
        this.maxHealth = maxHealth;
        this.currentHealth = Math.min(this.currentHealth, this.maxHealth); // Adjust current health if max decreases.
        if (doSync) sync();
    }

    // --- Protection (STR-based) ---
    @Override public float getCurrentProtection() { return currentProtection; }
    @Override public void setCurrentProtection(float protection) { setCurrentProtection(protection, true); }
    @Override public void setCurrentProtection(float protection, boolean doSync) {
        this.currentProtection = updateAndSyncStat(protection, this.maxProtection, this.currentProtection, doSync);
    }
    @Override public float getMaxProtection() { return this.maxProtection; }
    @Override public void setMaxProtection(float maxProtection) { setMaxProtection(maxProtection, true); }
    @Override public void setMaxProtection(float maxProtection, boolean doSync) {
        this.maxProtection = maxProtection;
        this.currentProtection = Math.min(this.currentProtection, this.maxProtection); // Adjust current protection if max decreases.
        if (doSync) sync();
    }

    // --- Innate Protection ---
    @Override public float getCurrentInnateProtection() { return currentInnateProtection; }
    @Override public void setCurrentInnateProtection(float innateProtection) { setCurrentInnateProtection(innateProtection, true); }
    @Override public void setCurrentInnateProtection(float innateProtection, boolean doSync) {
        this.currentInnateProtection = updateAndSyncStat(innateProtection, this.maxInnateProtection, this.currentInnateProtection, doSync);
    }
    @Override public float getMaxInnateProtection() { return this.maxInnateProtection; }
    @Override public void setMaxInnateProtection(float maxInnateProtection) { setMaxInnateProtection(maxInnateProtection, true); }
    @Override public void setMaxInnateProtection(float maxInnateProtection, boolean doSync) {
        this.maxInnateProtection = maxInnateProtection;
        this.currentInnateProtection = Math.min(this.currentInnateProtection, this.maxInnateProtection); // Adjust current if max decreases.
        if (doSync) sync();
    }

    // --- Mana ---
    @Override public float getCurrentMana() { return currentMana; }
    @Override public void setCurrentMana(float mana) { setCurrentMana(mana, true); }
    @Override public void setCurrentMana(float mana, boolean doSync) {
        this.currentMana = updateAndSyncStat(mana, this.maxMana, this.currentMana, doSync);
    }
    @Override public float getMaxMana() { return this.maxMana; }
    @Override public void setMaxMana(float maxMana) { setMaxMana(maxMana, true); }
    @Override public void setMaxMana(float maxMana, boolean doSync) {
        this.maxMana = maxMana;
        this.currentMana = Math.min(this.currentMana, this.maxMana); // Adjust current mana if max decreases.
        if (doSync) sync();
    }

    // --- Vigor ---
    @Override public float getCurrentVigor() { return currentVigor; }
    @Override public void setCurrentVigor(float vigor) { setCurrentVigor(vigor, true); }
    @Override public void setCurrentVigor(float vigor, boolean doSync) {
        this.currentVigor = updateAndSyncStat(vigor, this.maxVigor, this.currentVigor, doSync);
    }
    @Override public float getMaxVigor() { return this.maxVigor; }
    @Override public void setMaxVigor(float maxVigor) { setMaxVigor(maxVigor, true); }
    @Override public void setMaxVigor(float maxVigor, boolean doSync) {
        this.maxVigor = maxVigor;
        this.currentVigor = Math.min(this.currentVigor, this.maxVigor); // Adjust current vigor if max decreases.
        if (doSync) sync();
    }

    // --- Favor (Luck) ---
    @Override public float getFavor() { return favor; }
    @Override public void setFavor(float favor) { this.favor = favor; }
    @Override public void addFavor(float amount) { this.favor += amount; }

    // --- Core Attributes ---
    @Override public int getConstitution() { return constitution; }
    @Override public void setConstitution(int constitution) { this.constitution = constitution; recalculateStats(); }
    @Override public int getStrength() { return strength; }
    @Override
    public void setStrength(int strength) {
        this.strength = strength;
        recalculateStats();
    }
    @Override public int getDexterity() { return dexterity; }
    @Override
    public void setDexterity(int dexterity) {
        this.dexterity = dexterity;
        recalculateStats();
    }
    @Override public int getIntelligence() { return intelligence; }
    @Override
    public void setIntelligence(int intelligence) {
        this.intelligence = intelligence;
        recalculateStats();
    }

    // --- Hunger State ---
    @Override public int getHungerStage() {return hungerStage;}
    @Override public void setHungerStage(int hungerStage) {
        // Only synchronize if the hunger stage has actually changed to reduce network traffic.
        if (this.hungerStage != hungerStage) {
            this.hungerStage = hungerStage;
        }
    }

    // --- Stat Recalculation ---

    /**
     * Recalculates all maximum primary statistics (Health, Mana, Vigor, Protection, Innate Protection, Favor)
     * based on the player's current attributes, race, and class.
     * This method is the primary entry point for updating a player's derived stats.
     */
    @Override
    public void recalculateStats() {
        int currentLevel = 1; // Default level.
        // Retrieve the player's actual level from their XP capability (server-side only).
        if (player instanceof ServerPlayer serverPlayer) {
            Optional<IPlayerXP> xpCapability = serverPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).resolve(); //
            if (xpCapability.isPresent()) {
                currentLevel = xpCapability.get().getLevel();
            }
        }
        recalculateStatsInternal(currentLevel); // Perform the actual calculations without immediate sync.
        sync(); // Synchronize all changes once after all calculations are complete.
    }

    /**
     * Internal logic for recalculating maximum primary statistics.
     * This method is called by {@link #recalculateStats()} and during initialization/deserialization.
     * It does NOT perform synchronization itself; synchronization is handled by the caller.
     * @param currentLevel The current level of the player.
     */
    private void recalculateStatsInternal(int currentLevel) {
        String currentRace = this.getRace();
        String currentPlayerClass = this.getPlayerClass();
        String currentSpecialization = this.getSpecialization();

        // Recalculate Max Health.
        // MODIFIED: Pass 'this' (PlayerStats instance) to StatCalculator.
        float newMaxHealth = StatCalculator.calculateHealth(this, currentRace, currentPlayerClass, currentSpecialization, this.constitution); //
        setMaxHealth(newMaxHealth, false); // Use setter without syncing here.

        // Recalculate Max Mana.
        // MODIFIED: Pass 'this' (PlayerStats instance) to StatCalculator.
        float newMaxMana = StatCalculator.calculateMana(this, currentRace, currentPlayerClass, currentSpecialization, this.intelligence); //
        setMaxMana(newMaxMana, false);

        // Recalculate Max Vigor.
        // MODIFIED: Pass 'this' (PlayerStats instance) to StatCalculator.
        float newMaxVigor = StatCalculator.calculateVigor(this, currentRace, currentPlayerClass, currentSpecialization, this.dexterity); //
        setMaxVigor(newMaxVigor, false);

        // Recalculate Max STR-based Protection.
        // MODIFIED: Pass 'this' (PlayerStats instance) to StatCalculator.
        float newMaxProtectionSTR = StatCalculator.calculateProtectionFromSTR(this, currentRace, currentPlayerClass, currentSpecialization, this.strength); //
        setMaxProtection(newMaxProtectionSTR, false);

        // Recalculate Max Innate Protection.
        // MODIFIED: Pass 'this' (PlayerStats instance) to StatCalculator.
        float newMaxInnateProtection = StatCalculator.calculateInnateProtection(this, currentRace, currentLevel); //
        setMaxInnateProtection(newMaxInnateProtection, false);

        // Recalculate Favor (Luck) based on race configuration.
        // MODIFIED: Use RaceDataConfig directly for favor limits.
        RaceDataConfig.RaceSettings raceSettings = RaceDataConfig.getInstance().getRaceSettings(currentRace); //
        if (raceSettings != null) {
            this.favor = Math.min(this.favor, raceSettings.getFavor()); // Clamp to max limit
            this.favor = Math.max(this.favor, raceSettings.getFavor() * -1.0f); // Clamp to min limit (assuming symmetric negative)
        } else {
            this.favor = 0.0f; // Default fallback if no config.
        }
    }

    // --- Data Reset Methods ---

    /**
     * Resets all player statistics, attributes, race, class, professions, and achievement progress
     * to their default starting values. This is typically used for character resets or debugging.
     */
    @Override
    public void resetData() {
        this.attributePoints = 0;
        this.playerClass = "NO_CLASS";
        this.specialization = "";
        this.skillPoints = 0;
        this.professions.clear();

        // Reset manual attributes to zero (as they are usually gained via attribute points).
        this.constitution = 0;
        this.strength = 0;
        this.dexterity = 0;
        this.intelligence = 0;

        // Achievements and exploration data are non-racial, so they are reset/cleared.
        this.achievementProgress.clear();
        this.completedAchievements.clear();
        this.discoveredBiomes.clear();
        this.visitedDimensions.clear();
        this.craftedUniqueItems.clear();
        this.tamedAnimals.clear();

        // Reset villager trade cooldowns
        this.villagerTradesSinceLastFavor = 0;
        this.lastVillagerFavorGainTick = 0;

        // Reset Chimera transformation state
        this.inChaoticTransformation = false;
        this.chaoticTransformationEndTime = 0;
        this.chaoticTransformationCooldownEndTime = 0;
        this.chaoticStatAdjustments.clear();


        // Recalculate max stats based on the *current* race and reset attributes (0).
        // This will set maxHealth, maxMana, maxVigor, maxProtection, maxInnateProtection to their base values for the current race.
        recalculateStats();

        // Set current stats to their newly calculated maximums (base values).
        // For current health, we set it to maxHealth to ensure the player is full health after a reset.
        setCurrentHealth(this.maxHealth, false);
        setCurrentProtection(this.maxProtection, false);
        setCurrentInnateProtection(this.maxInnateProtection, false);
        setCurrentMana(this.maxMana, false);
        setCurrentVigor(this.maxVigor, false);

        // Reset Favor to its base value for the current race.
        // MODIFIED: Use RaceDataConfig directly for favor.
        this.favor = RaceDataConfig.getInstance().getRaceSettings(this.race).getFavor(); //


        // Reset combat state flags.
        this.lastCombatTick = 0;
        this.lastCombatExitTick = 0;
        this.regenSpeedBonusTicks = 0.0F;
        this.hungerStage = 0;
        this.favorBonusMultiplier = 1.0f;

        // Clean up static consumption states for this player.
        PlayerStats.removePlayerConsumptionState(player.getUUID());

        sync();
    }

    /**
     * Resets only the player's class-specific data (class, specialization, skill points)
     * to defaults. This is used for class changes without affecting other core stats.
     */
    @Override
    public void resetClassSpecificData() {
        this.playerClass = "NO_CLASS";
        this.specialization = "";
        this.skillPoints = 0;
        recalculateStats(); // Recalculate stats as class can affect derived values.
    }

    // --- Data Copy Method ---

    /**
     * Copies all player statistics and data from a source {@link IPlayerStats} instance to this one.
     * This is crucial for handling player clones (e.g., respawning after death, dimension changes)
     * to ensure data persistence.
     * @param source The source IPlayerStats instance to copy data from.
     */
    @Override
    public void copyFrom(IPlayerStats source) {
        this.attributePoints = source.getAttributePoints();
        this.race = source.getRace();
        this.playerClass = source.getPlayerClass();
        this.specialization = source.getSpecialization();
        this.skillPoints = source.getSkillPoints();
        // Create a new map instance to ensure a deep copy, preventing shared references.
        this.professions = new HashMap<>(source.getProfessions());

        this.constitution = source.getConstitution();
        this.strength = source.getStrength();
        this.dexterity = source.getDexterity();
        this.intelligence = source.getIntelligence();

        // Recalculate maximum stats based on copied attributes before setting current values.
        int currentLevel = 1;
        if (player instanceof ServerPlayer serverPlayer) {
            Optional<IPlayerXP> xpCapability = serverPlayer.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).resolve(); //
            if (xpCapability.isPresent()) {
                currentLevel = xpCapability.get().getLevel();
            }
        }
        recalculateStatsInternal(currentLevel); // Calculate without syncing here.

        // Set current values using setters with no sync, as a final sync will happen.
        setCurrentHealth(source.getCurrentHealth(), false);
        setCurrentProtection(source.getCurrentProtection(), false);
        setCurrentInnateProtection(source.getCurrentInnateProtection(), false);
        setCurrentMana(source.getCurrentMana(), false);
        setCurrentVigor(source.getCurrentVigor(), false);

        this.favor = source.getFavor();
        this.favorBonusMultiplier = source.getFavorBonusMultiplier();

        this.lastCombatTick = source.getLastCombatTick();
        this.lastCombatExitTick = source.getLastCombatExitTick();
        this.regenSpeedBonusTicks = source.getRegenSpeedBonusTicks();
        this.hungerStage = source.getHungerStage();

        // Copy the state of continuous consumption flags.
        isManaBeingConsumedContinuously.put(player.getUUID(), source.isManaBeingConsumed());
        isVigorBeingConsumedContinuously.put(player.getUUID(), source.isVigorBeingConsumed());

        // Deep copy achievement data.
        this.achievementProgress = new HashMap<>(source.getAchievementProgress());
        this.completedAchievements = new HashMap<>(source.getCompletedAchievements());

        // Deep copy exploration and crafting data.
        this.discoveredBiomes = new HashSet<>(source.getDiscoveredBiomes());
        this.visitedDimensions = new HashSet<>(source.getVisitedDimensions());
        this.craftedUniqueItems = new HashSet<>(source.getCraftedUniqueItems());
        this.tamedAnimals = new HashSet<>(source.getTamedAnimals());

        this.villagerTradesSinceLastFavor = source.getVillagerTradesSinceLastFavor();
        this.lastVillagerFavorGainTick = source.getLastVillagerFavorGainTick();

        // Copy Chimera transformation state
        this.inChaoticTransformation = source.isInChaoticTransformation();
        this.chaoticTransformationEndTime = source.getChaoticTransformationEndTime();
        this.chaoticTransformationCooldownEndTime = source.getChaoticTransformationCooldownEndTime();
        this.chaoticStatAdjustments = new HashMap<>(source.getChaoticStatAdjustments()); // Deep copy


        sync(); // Perform a single synchronization after all data has been copied.
    }

    // --- Favor (Luck) Methods ---

    /**
     * Applies a configurable Favor modifier to the player's current Favor value.
     * This method incorporates the `favorBonusMultiplier` and clamps the result
     * within the race-specific Favor limits.
     * @param actionKey The key identifying the action that modifies Favor (e.g., "TAME_WOLF").
     */
    public void applyFavorModifier(String actionKey) {
        // MODIFIED: Use FavorActionDataConfig directly.
        Float baseModifier = FavorActionDataConfig.getInstance().getFavorModifier(actionKey.toUpperCase()); //
        if (baseModifier != null) {
            float bonusMultiplier = this.getFavorBonusMultiplier();
            float finalModifier = baseModifier * bonusMultiplier;
            this.favor += finalModifier;

            // Clamp Favor within race-specific limits.
            String playerCurrentRace = this.getRace();
            // MODIFIED: Use RaceDataConfig directly for favor limits.
            RaceDataConfig.RaceSettings currentRaceSettings = RaceDataConfig.getInstance().getRaceSettings(playerCurrentRace); //
            if (currentRaceSettings != null) {
                this.favor = Math.min(this.favor, currentRaceSettings.getFavor()); //
                this.favor = Math.max(this.favor, currentRaceSettings.getFavor() * -1.0f); // Assuming symmetric negative limit
            } else {
                // Default limits if no specific race config is found.
                this.favor = Math.min(this.favor, 90.0f);
                this.favor = Math.max(this.favor, -90.0f);
            }
        }
    }

    /**
     * Recalculates the `favorBonusMultiplier` based on various in-game factors
     * (e.g., equipped items, active potion effects).
     * Currently, this method is a placeholder and should be implemented with actual game logic.
     */
    public void recalculateFavorBonusMultiplier() {
        float totalBonus = 1.0f;
        // TODO: Implement logic to calculate favorBonusMultiplier (e.g., based on equipment, effects, etc.)
        this.favorBonusMultiplier = totalBonus;
    }


    // --- NBT Serialization and Deserialization (Data Persistence) ---

    /**
     * Serializes the player's current statistics and progression data to a {@link CompoundTag}.
     * This method is called by Forge when the player's data needs to be saved (e.g., world save, player logout).
     * @return A CompoundTag containing all serialized player data.
     */
    @Override
    public CompoundTag serializeNBT() {
        CompoundTag nbt = new CompoundTag();
        nbt.putInt("AttributePoints", attributePoints);
        nbt.putString("Race", race);
        nbt.putString("PlayerClass", playerClass);
        nbt.putString("Specialization", specialization);
        nbt.putInt("SkillPoints", skillPoints);
        nbt.putInt("HungerStage", hungerStage);

        // Serialize professions map.
        CompoundTag professionsNBT = new CompoundTag();
        for (Map.Entry<String, Integer> entry : professions.entrySet()) {
            professionsNBT.putInt(entry.getKey(), entry.getValue());
        }
        nbt.put("Professions", professionsNBT);

        // Ensure current and max stat values are non-negative before saving to prevent issues.
        nbt.putFloat("CurrentHealth", Math.max(0, currentHealth));
        nbt.putFloat("MaxHealth", Math.max(0, maxHealth));
        nbt.putFloat("CurrentProtection", Math.max(0, currentProtection));
        nbt.putFloat("MaxProtection", Math.max(0, maxProtection));
        nbt.putFloat("CurrentInnateProtection", Math.max(0, currentInnateProtection));
        nbt.putFloat("MaxInnateProtection", Math.max(0, maxInnateProtection));
        nbt.putFloat("CurrentMana", Math.max(0, currentMana));
        nbt.putFloat("MaxMana", Math.max(0, maxMana));
        nbt.putFloat("CurrentVigor", Math.max(0, currentVigor));
        nbt.putFloat("MaxVigor", Math.max(0, maxVigor));
        nbt.putFloat("Favor", favor);

        nbt.putInt("Constitution", constitution);
        nbt.putInt("Strength", strength);
        nbt.putInt("Dexterity", dexterity);
        nbt.putInt("Intelligence", intelligence);

        nbt.putFloat("FavorBonusMultiplier", favorBonusMultiplier);

        nbt.putLong("LastCombatTick", this.lastCombatTick);
        nbt.putLong("LastCombatExitTick", this.lastCombatExitTick);
        nbt.putFloat("RegenSpeedBonusTicks", this.regenSpeedBonusTicks);

        // Save the state of continuous consumption flags for this player.
        nbt.putBoolean("IsManaBeingConsumedContinuously", isManaBeingConsumedContinuously.getOrDefault(player.getUUID(), false));
        nbt.putBoolean("IsVigorBeingConsumedContinuously", isVigorBeingConsumedContinuously.getOrDefault(player.getUUID(), false));

        // Serialize achievement progress (Map<String, Integer>).
        CompoundTag achievementProgressNBT = new CompoundTag();
        for (Map.Entry<String, Integer> entry : achievementProgress.entrySet()) {
            achievementProgressNBT.putInt(entry.getKey(), entry.getValue());
        }
        nbt.put("AchievementProgress", achievementProgressNBT);

        // Serialize completed achievements (Map<String, Boolean>).
        CompoundTag completedAchievementsNBT = new CompoundTag();
        for (Map.Entry<String, Boolean> entry : completedAchievements.entrySet()) {
            completedAchievementsNBT.putBoolean(entry.getKey(), entry.getValue());
        }
        nbt.put("CompletedAchievements", completedAchievementsNBT);

        // Serialize Set of discovered biomes to a ListTag of StringTags.
        ListTag biomesListNBT = new ListTag();
        for (ResourceKey<Biome> biome : discoveredBiomes) {
            biomesListNBT.add(StringTag.valueOf(biome.location().toString()));
        }
        nbt.put("DiscoveredBiomes", biomesListNBT);

        // Serialize Set of visited dimensions to a ListTag of StringTags.
        ListTag dimensionsListNBT = new ListTag();
        for (ResourceKey<net.minecraft.world.level.Level> dimension : visitedDimensions) {
            dimensionsListNBT.add(StringTag.valueOf(dimension.location().toString()));
        }
        nbt.put("VisitedDimensions", dimensionsListNBT);

        // Serialize Set of crafted unique items to a ListTag of StringTags.
        ListTag craftedItemsListNBT = new ListTag();
        for (ResourceLocation item : craftedUniqueItems) {
            craftedItemsListNBT.add(StringTag.valueOf(item.toString()));
        }
        nbt.put("CraftedUniqueItems", craftedItemsListNBT);

        // Serialize Set of tamed unique animals to a ListTag of StringTags.
        ListTag tamedAnimalsListNBT = new ListTag();
        for (ResourceLocation animal : tamedAnimals) {
            tamedAnimalsListNBT.add(StringTag.valueOf(animal.toString()));
        }
        nbt.put("TamedAnimals", tamedAnimalsListNBT);

        nbt.putInt("VillagerTradesSinceLastFavor", villagerTradesSinceLastFavor);
        nbt.putLong("LastVillagerFavorGainTick", lastVillagerFavorGainTick);

        // Serialize Chimera transformation data
        nbt.putBoolean("InChaoticTransformation", inChaoticTransformation);
        nbt.putLong("ChaoticTransformationEndTime", chaoticTransformationEndTime);
        nbt.putLong("ChaoticTransformationCooldownEndTime", chaoticTransformationCooldownEndTime);
        CompoundTag chaoticAdjustmentsNBT = new CompoundTag();
        for (Map.Entry<String, Float> entry : chaoticStatAdjustments.entrySet()) {
            chaoticAdjustmentsNBT.putFloat(entry.getKey(), entry.getValue());
        }
        nbt.put("ChaoticStatAdjustments", chaoticAdjustmentsNBT);


        return nbt;
    }

    /**
     * Loads the player's statistics and progression data from a {@link CompoundTag}.
     * This method is called by Forge when the player's data is loaded (e.g., world load, player login).
     * Includes robust error handling and backward compatibility checks for missing NBT tags.
     * @param nbt The CompoundTag containing the serialized player data.
     */
    @Override
    public void deserializeNBT(CompoundTag nbt) {
        // Wrap deserialization in a try-catch for robustness against corrupted or old NBT data.
        try {
            // Load basic attributes first, using .getOrDefault() or .contains() for safety.
            attributePoints = nbt.getInt("AttributePoints");
            race = nbt.getString("Race");
            playerClass = nbt.getString("PlayerClass");
            specialization = nbt.contains("Specialization") ? nbt.getString("Specialization") : "";
            skillPoints = nbt.getInt("SkillPoints");
            hungerStage = nbt.getInt("HungerStage");

            professions.clear();
            // Check if "Professions" tag exists and is of the correct type (CompoundTag) before loading.
            if (nbt.contains("Professions", Tag.TAG_COMPOUND)) { //
                CompoundTag professionsNBT = nbt.getCompound("Professions"); //
                for (String key : professionsNBT.getAllKeys()) {
                    professions.put(key, professionsNBT.getInt(key));
                }
            } else {
                BrokenPath.LOGGER.warn("NBT 'Professions' tag not found or is not a CompoundTag for player {}. Initializing empty professions map.", player.getName().getString()); //
                professions = new HashMap<>(); // Ensure the map is empty if tag is missing/incorrect.
            }

            // Load core attributes. These are critical for subsequent stat calculations.
            constitution = nbt.getInt("Constitution");
            strength = nbt.getInt("Strength");
            dexterity = nbt.getInt("Dexterity");
            intelligence = nbt.getInt("Intelligence");

            final int[] currentLevelHolder = {1}; // Use an array to modify value within lambda.
            // Retrieve player's XP level (server-side only) to accurately recalculate stats.
            if (player instanceof ServerPlayer serverPlayer) {
                player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).resolve().ifPresent(xpCapability -> { //
                    currentLevelHolder[0] = xpCapability.getLevel();
                });
            }
            // Recalculate maximum stats based on loaded attributes and level.
            // This ensures that max stats are correct even if configs changed or data was from older versions.
            recalculateStatsInternal(currentLevelHolder[0]);

            // Load current stat values. .getFloat() returns 0.0f if tag is not found.
            float loadedCurrentHealth = nbt.getFloat("CurrentHealth");
            float loadedCurrentProtection = nbt.getFloat("CurrentProtection");
            float loadedCurrentInnateProtection = nbt.getFloat("CurrentInnateProtection");
            float loadedCurrentMana = nbt.getFloat("CurrentMana");
            float loadedCurrentVigor = nbt.getFloat("CurrentVigor");

            // Set current values using setters with no sync, as the setters themselves apply clamping.
            // The overall sync will happen later if triggered by PlayerStatEventHandler.
            setCurrentHealth(loadedCurrentHealth, false);
            setCurrentProtection(loadedCurrentProtection, false);
            setCurrentInnateProtection(loadedCurrentInnateProtection, false);
            setCurrentMana(loadedCurrentMana, false);
            setCurrentVigor(loadedCurrentVigor, false);
            favor = nbt.getFloat("Favor");
            favorBonusMultiplier = nbt.contains("FavorBonusMultiplier") ? nbt.getFloat("FavorBonusMultiplier") : 1.0f;

            this.lastCombatTick = nbt.getLong("LastCombatTick");
            this.lastCombatExitTick = nbt.getLong("LastCombatExitTick");
            this.regenSpeedBonusTicks = nbt.contains("RegenSpeedBonusTicks") ? nbt.getFloat("RegenSpeedBonusTicks") : 0.0F;

            // Load continuous consumption states.
            isManaBeingConsumedContinuously.put(player.getUUID(), nbt.contains("IsManaBeingConsumedContinuously") ? nbt.getBoolean("IsManaBeingConsumedContinuously") : false);
            isVigorBeingConsumedContinuously.put(player.getUUID(), nbt.contains("IsVigorBeingConsumedContinuously") ? nbt.getBoolean("IsVigorBeingConsumedContinuously") : false);

            // Load achievement progress.
            achievementProgress.clear();
            if (nbt.contains("AchievementProgress", Tag.TAG_COMPOUND)) { //
                CompoundTag achievementProgressNBT = nbt.getCompound("AchievementProgress"); //
                for (String key : achievementProgressNBT.getAllKeys()) {
                    achievementProgress.put(key, achievementProgressNBT.getInt(key));
                }
            }

            // Load completed achievements.
            completedAchievements.clear();
            if (nbt.contains("CompletedAchievements", Tag.TAG_COMPOUND)) { //
                CompoundTag completedAchievementsNBT = nbt.getCompound("CompletedAchievements"); //
                for (String key : completedAchievementsNBT.getAllKeys()) {
                    completedAchievements.put(key, completedAchievementsNBT.getBoolean(key));
                }
            }

            // Load discovered biomes.
            discoveredBiomes.clear();
            if (nbt.contains("DiscoveredBiomes", Tag.TAG_LIST)) { //
                ListTag biomesListNBT = nbt.getList("DiscoveredBiomes", Tag.TAG_STRING); //
                for (Tag tag : biomesListNBT) {
                    discoveredBiomes.add(ResourceKey.create(Registries.BIOME, new ResourceLocation(tag.getAsString()))); //
                }
            }

            // Load visited dimensions.
            visitedDimensions.clear();
            if (nbt.contains("VisitedDimensions", Tag.TAG_LIST)) { //
                ListTag dimensionsListNBT = nbt.getList("VisitedDimensions", Tag.TAG_STRING); //
                for (Tag tag : dimensionsListNBT) {
                    visitedDimensions.add(ResourceKey.create(Registries.DIMENSION, new ResourceLocation(tag.getAsString()))); //
                }
            }

            // Load crafted unique items.
            craftedUniqueItems.clear();
            if (nbt.contains("CraftedUniqueItems", Tag.TAG_LIST)) { //
                ListTag craftedItemsListNBT = nbt.getList("CraftedUniqueItems", Tag.TAG_STRING); //
                for (Tag tag : craftedItemsListNBT) {
                    craftedUniqueItems.add(new ResourceLocation(tag.getAsString()));
                }
            }

            // Load tamed unique animals.
            tamedAnimals.clear();
            if (nbt.contains("TamedAnimals", Tag.TAG_LIST)) {
                ListTag tamedAnimalsListNBT = nbt.getList("TamedAnimals", Tag.TAG_STRING);
                for (Tag tag : tamedAnimalsListNBT) {
                    tamedAnimals.add(new ResourceLocation(tag.getAsString()));
                }
            }

            this.villagerTradesSinceLastFavor = nbt.getInt("VillagerTradesSinceLastFavor");
            this.lastVillagerFavorGainTick = nbt.getLong("LastVillagerFavorGainTick");

            // Load Chimera transformation data
            this.inChaoticTransformation = nbt.getBoolean("InChaoticTransformation");
            this.chaoticTransformationEndTime = nbt.getLong("ChaoticTransformationEndTime");
            this.chaoticTransformationCooldownEndTime = nbt.getLong("ChaoticTransformationCooldownEndTime");
            this.chaoticStatAdjustments.clear();
            if (nbt.contains("ChaoticStatAdjustments", Tag.TAG_COMPOUND)) {
                CompoundTag chaoticAdjustmentsNBT = nbt.getCompound("ChaoticStatAdjustments");
                for (String key : chaoticAdjustmentsNBT.getAllKeys()) {
                    this.chaoticStatAdjustments.put(key, chaoticAdjustmentsNBT.getFloat(key));
                }
            }

        } catch (Exception e) {
            // If any error occurs during deserialization, log it and reset data to prevent corrupted states.
            BrokenPath.LOGGER.error("Error deserializing PlayerStats for player {}. Resetting data. Stack trace: ", player.getName().getString(), e); //
            this.resetData();
        }
    }

    // --- Data Synchronization with Client ---

    /**
     * Synchronizes all player statistics data from the server to the client.
     * This method is essential for keeping the client-side UI and gameplay elements
     * updated with the most current server-side player data.
     * Only runs on the server side to prevent client-side desynchronization.
     */
    @Override
    public void sync() {
        if (this.player instanceof ServerPlayer serverPlayer) {
            // Call updateClientData directly with the current server-side stats.
            // This ensures all client-side clamping and deep copying logic is applied.
            // We pass the raw collection types here as updateClientData handles the conversion to List<String> for the packet.
            PlayerStatsClient.setAllStats( //
                    this.attributePoints,
                    this.constitution, this.strength, this.dexterity, this.intelligence,
                    this.currentHealth, this.maxHealth,
                    this.currentProtection, this.maxProtection,
                    this.currentInnateProtection, this.maxInnateProtection,
                    this.currentMana, this.maxMana,
                    this.currentVigor, this.maxVigor,
                    this.favor,
                    this.race,
                    this.playerClass,
                    this.specialization,
                    this.skillPoints,
                    this.professions,
                    this.hungerStage,
                    this.favorBonusMultiplier,
                    this.achievementProgress,
                    this.completedAchievements,
                    this.discoveredBiomes.stream().map(biome -> biome.location().toString()).collect(Collectors.toList()),
                    this.visitedDimensions.stream().map(dim -> dim.location().toString()).collect(Collectors.toList()),
                    this.craftedUniqueItems.stream().map(ResourceLocation::toString).collect(Collectors.toList()),
                    this.tamedAnimals.stream().map(ResourceLocation::toString).collect(Collectors.toList())
            );

            // Now send the packet to the client for actual network synchronization
            PacketHandler.sendToPlayer(new SyncPlayerStatsPacket( //
                    this.attributePoints,
                    this.constitution, this.strength, this.dexterity, this.intelligence,
                    this.currentHealth, this.maxHealth,
                    this.currentProtection, this.maxProtection,
                    this.currentInnateProtection, this.maxInnateProtection,
                    this.currentMana, this.maxMana,
                    this.currentVigor, this.maxVigor,
                    this.favor,
                    this.race, this.playerClass, this.specialization, this.skillPoints,
                    this.professions,
                    this.hungerStage,
                    this.favorBonusMultiplier,
                    this.achievementProgress,
                    this.completedAchievements,
                    this.discoveredBiomes,
                    this.visitedDimensions,
                    this.craftedUniqueItems,
                    this.tamedAnimals
            ), serverPlayer);
            this.lastHealthSyncTick = serverPlayer.level().getGameTime();
        }
    }

    // --- Additional Getters and Setters (Specific to PlayerStats) ---

    @Override
    public float getFavorBonusMultiplier() {
        return favorBonusMultiplier;
    }

    @Override
    public void setFavorBonusMultiplier(float multiplier) {
        // MODIFIED: Use MainModConfigManager directly.
        float maxLimit = MainModConfigManager.getInstance().maxFavorBonusMultiplier;
        this.favorBonusMultiplier = Math.max(1.0f, Math.min(multiplier, maxLimit)); // Clamp between 1.0f and max limit.
    }

    // --- Combat State Management ---

    @Override
    public long getLastCombatTick() { return lastCombatTick; }
    @Override
    public void setLastCombatTick(long tick) { this.lastCombatTick = tick; }

    /**
     * Checks if the player is currently considered "in combat."
     * Combat status is determined by the time elapsed since the last combat action.
     * @param currentTick The current game tick.
     * @return True if the player is in combat, false otherwise.
     */
    @Override
    public boolean isInCombat(long currentTick) {
        // Use RegenDataConfig directly for combat delay.
        return (currentTick - this.lastCombatTick) < RegenDataConfig.getInstance().getHealthDelayAfterCombatTicks();
    }

    /**
     * Marks the player as having entered combat.
     * Updates the `lastCombatTick` to the current game time.
     * @param currentTick The current game tick.
     */
    @Override
    public void enterCombat(long currentTick) {
        this.lastCombatTick = currentTick;
    }

    /**
     * Marks the player as having exited combat.
     * Resets `lastCombatTick` and records `lastCombatExitTick` to manage regen delays.
     */
    @Override
    public void exitCombat() {
        this.lastCombatTick = 0; // Ensures isInCombat() returns false immediately.
        this.lastCombatExitTick = player.level().getGameTime(); // Record exit time for regen delays.
    }

    @Override
    public long getLastCombatExitTick() { return lastCombatExitTick; }
    @Override
    public float getRegenSpeedBonusTicks() { return this.regenSpeedBonusTicks; }

    // --- Resource Restoration Methods ---

    @Override public void restoreProtection(float amount) { if (amount > 0) { setCurrentProtection(this.currentProtection + amount, true); } }
    @Override public void restoreMana(float amount) { if (amount > 0) { setCurrentMana(this.currentMana + amount, true); } }
    @Override public void restoreVigor(float amount) { if (amount > 0) { setCurrentVigor(this.currentVigor + amount, true); } }
    @Override public void restoreInnateProtection(float amount) { if (amount > 0) { setCurrentInnateProtection(this.currentInnateProtection + amount, true); } }


    // --- Continuous Consumption Flags ---

    /**
     * Sets whether mana is currently being consumed continuously for this player.
     * Used by abilities that drain mana over time.
     * @param consuming True if mana is being consumed, false otherwise.
     */
    @Override
    public void setManaBeingConsumed(boolean consuming) {
        // Only update and sync if the state has actually changed.
        if (isManaBeingConsumedContinuously.getOrDefault(player.getUUID(), false) != consuming) {
            isManaBeingConsumedContinuously.put(player.getUUID(), consuming);
        }
    }

    /**
     * Checks if mana is currently being consumed continuously for this player.
     * @return True if mana is being consumed, false otherwise.
     */
    @Override
    public boolean isManaBeingConsumed() {
        return isManaBeingConsumedContinuously.getOrDefault(player.getUUID(), false);
    }

    /**
     * Sets whether vigor is currently being consumed continuously for this player.
     * Used by abilities that drain vigor over time.
     * @param consuming True if vigor is being consumed, false otherwise.
     */
    @Override
    public void setVigorBeingConsumed(boolean consuming) {
        // Only update and sync if the state has actually changed.
        if (isVigorBeingConsumedContinuously.getOrDefault(player.getUUID(), false) != consuming) {
            isVigorBeingConsumedContinuously.put(player.getUUID(), consuming);
        }
    }

    /**
     * Checks if vigor is currently being consumed continuously for this player.
     * @return True if vigor is being consumed, false otherwise.
     */
    @Override
    public boolean isVigorBeingConsumed() {
        return isVigorBeingConsumedContinuously.getOrDefault(player.getUUID(), false);
    }

    // --- Achievement Progress Methods ---
    /**
     * Returns an unmodifiable map of achievement progress.
     * @return A map where keys are achievement IDs and values are current progress.
     */
    @Override
    public Map<String, Integer> getAchievementProgress() {
        return Collections.unmodifiableMap(achievementProgress);
    }
    @Override
    public void setAchievementProgress(String achievementKey, int progress) {
        this.achievementProgress.put(achievementKey, progress);
    }
    @Override
    public int getAchievementProgress(String achievementKey) {
        return achievementProgress.getOrDefault(achievementKey, 0);
    }

    /**
     * Returns an unmodifiable map of completed achievements.
     * @return A map where keys are achievement IDs and values are boolean completion status.
     */
    @Override
    public Map<String, Boolean> getCompletedAchievements() {
        return Collections.unmodifiableMap(completedAchievements);
    }
    @Override
    public void setAchievementCompleted(String achievementKey, boolean completed) {
        this.completedAchievements.put(achievementKey, completed);
    }
    @Override
    public boolean isAchievementCompleted(String achievementKey) {
        return completedAchievements.getOrDefault(achievementKey, false);
    }

    // --- Exploration and Crafting Tracking Methods ---

    /**
     * Returns an unmodifiable set of discovered biomes.
     * @return A set of ResourceKeys representing discovered biomes.
     */
    @Override
    public Set<ResourceKey<Biome>> getDiscoveredBiomes() {
        return Collections.unmodifiableSet(this.discoveredBiomes);
    }
    @Override
    public void addDiscoveredBiome(ResourceKey<Biome> biome) {
        if (this.discoveredBiomes.add(biome)) {
            sync(); // Sync only if a new biome was added.
        }
    }

    /**
     * Returns an unmodifiable set of visited dimensions.
     * @return A set of ResourceKeys representing visited dimensions.
     */
    @Override
    public Set<ResourceKey<net.minecraft.world.level.Level>> getVisitedDimensions() {
        return Collections.unmodifiableSet(this.visitedDimensions);
    }
    @Override
    public void addVisitedDimension(ResourceKey<net.minecraft.world.level.Level> dimension) {
        if (this.visitedDimensions.add(dimension)) {
            sync(); // Sync only if a new dimension was added.
        }
    }

    /**
     * Returns an unmodifiable set of unique crafted items.
     * @return A set of ResourceLocations representing unique crafted items.
     */
    @Override
    public Set<ResourceLocation> getCraftedUniqueItems() {
        return Collections.unmodifiableSet(this.craftedUniqueItems);
    }
    @Override
    public void addCraftedUniqueItem(ResourceLocation item) {
        if (this.craftedUniqueItems.add(item)) {
            sync(); // Sync only if a new unique item was added.
        }
    }

    /**
     * Returns an unmodifiable set of unique tamed animals.
     * @return A set of ResourceLocations representing unique tamed animals.
     */
    @Override
    public Set<ResourceLocation> getTamedAnimals() {
        return Collections.unmodifiableSet(this.tamedAnimals);
    }
    @Override
    public void addTamedAnimal(ResourceLocation entityId) {
        if (this.tamedAnimals.add(entityId)) {
            sync(); // Sync only if a new unique animal was added.
        }
    }

    /**
     * Removes the continuous mana and vigor consumption state for a specific player.
     * This static method is called upon player logout to clean up transient data.
     * @param playerUUID The UUID of the player to remove state for.
     */
    public static void removePlayerConsumptionState(UUID playerUUID) {
        isManaBeingConsumedContinuously.remove(playerUUID);
        isVigorBeingConsumedContinuously.remove(playerUUID);
    }

    // --- Update Client-Side Data from Sync Packet ---
    @Override
    public void updateClientData(int attributePoints,
                                 int constitution, int strength, int dexterity, int intelligence,
                                 float currentHealth, float maxHealth,
                                 float currentProtection, float maxProtection,
                                 float currentInnateProtection, float maxInnateProtection,
                                 float currentMana, float maxMana,
                                 float currentVigor, float maxVigor,
                                 float favor,
                                 String race, String playerClass, String specialization, int skillPoints,
                                 Map<String, Integer> professions,
                                 int hungerStage,
                                 float favorBonusMultiplier,
                                 Map<String, Integer> achievementProgress,
                                 Map<String, Boolean> completedAchievements,
                                 List<String> discoveredBiomesLocations,
                                 List<String> visitedDimensionsLocations,
                                 List<String> craftedUniqueItemsLocations,
                                 List<String> tamedAnimalsLocations) {
        this.attributePoints = attributePoints;
        this.constitution = constitution;
        this.strength = strength;
        this.dexterity = dexterity;
        this.intelligence = intelligence;

        this.maxHealth = maxHealth;
        this.currentHealth = Math.min(Math.max(0, currentHealth), this.maxHealth); // Clamp
        this.maxProtection = maxProtection;
        this.currentProtection = Math.min(Math.max(0, currentProtection), this.maxProtection); // Clamp
        this.maxInnateProtection = maxInnateProtection;
        this.currentInnateProtection = Math.min(Math.max(0, currentInnateProtection), this.maxInnateProtection); // Clamp
        this.maxMana = maxMana;
        this.currentMana = Math.min(Math.max(0, currentMana), this.maxMana); // Clamp
        this.maxVigor = maxVigor;
        this.currentVigor = Math.min(Math.max(0, currentVigor), this.maxVigor); // Clamp

        this.favor = favor;
        this.race = race;
        this.playerClass = playerClass;
        this.specialization = specialization;
        this.skillPoints = skillPoints;
        this.professions = new HashMap<>(professions); // Deep copy
        this.hungerStage = hungerStage;
        this.favorBonusMultiplier = favorBonusMultiplier;

        this.achievementProgress = new HashMap<>(achievementProgress); // Deep copy
        this.completedAchievements = new HashMap<>(completedAchievements); // Deep copy

        // Clear and re-add to sets
        this.discoveredBiomes.clear();
        discoveredBiomesLocations.stream()
                .map(loc -> ResourceKey.create(Registries.BIOME, new ResourceLocation(loc)))
                .forEach(this.discoveredBiomes::add);

        this.visitedDimensions.clear();
        visitedDimensionsLocations.stream()
                .map(loc -> ResourceKey.create(Registries.DIMENSION, new ResourceLocation(loc)))
                .forEach(this.visitedDimensions::add);

        this.craftedUniqueItems.clear();
        craftedUniqueItemsLocations.stream()
                .map(ResourceLocation::new)
                .forEach(this.craftedUniqueItems::add);

        this.tamedAnimals.clear();
        tamedAnimalsLocations.stream()
                .map(ResourceLocation::new)
                .forEach(this.tamedAnimals::add);
    }

    // --- Villager Trade Favor Cooldown Methods ---
    @Override
    public int getVillagerTradesSinceLastFavor() {
        return villagerTradesSinceLastFavor;
    }

    @Override
    public void setVillagerTradesSinceLastFavor(int count) {
        this.villagerTradesSinceLastFavor = count;
    }

    @Override
    public long getLastVillagerFavorGainTick() {
        return lastVillagerFavorGainTick;
    }

    @Override
    public void setLastVillagerFavorGainTick(long tick) {
        this.lastVillagerFavorGainTick = tick;
    }

    // --- Chimera Chaotic Transformation Methods ---

    /**
     * Initiates the Chimera's chaotic transformation if possible.
     * Applies random stat adjustments for the duration of the transformation.
     * @param currentTick The current game tick.
     * @return True if transformation started, false otherwise (e.g., on cooldown).
     */
    @Override
    public boolean startChaoticTransformation(long currentTick) {
        // Check if the player is a Chimera and not already transforming or on cooldown
        if (!"CHIMERA".equalsIgnoreCase(this.race) || this.inChaoticTransformation || currentTick < this.chaoticTransformationCooldownEndTime) {
            return false;
        }

        ChimeraFormDataConfig.ChaoticTransformationSettings settings = ChimeraFormDataConfig.getInstance().getTransformationSettings("CHAOTIC_TRANSFORMATION"); //
        if (settings.getDurationTicks() <= 0) {
            BrokenPath.LOGGER.warn("Chaotic Transformation duration is not set or is zero in config."); //
            return false; // Cannot transform if duration is zero or less
        }

        this.inChaoticTransformation = true;
        this.chaoticTransformationEndTime = currentTick + settings.getDurationTicks(); //

        // Apply random adjustments to each relevant stat
        this.chaoticStatAdjustments.clear();
        float minChange = settings.getRandomChangePercentageMin(); //
        float maxChange = settings.getRandomChangePercentageMax(); //

        this.chaoticStatAdjustments.put("HEALTH", StatCalculator.RANDOM.nextFloat() * (maxChange - minChange) + minChange); //
        this.chaoticStatAdjustments.put("PROTECTION", StatCalculator.RANDOM.nextFloat() * (maxChange - minChange) + minChange); //
        this.chaoticStatAdjustments.put("INNATE_PROTECTION", StatCalculator.RANDOM.nextFloat() * (maxChange - minChange) + minChange); //
        this.chaoticStatAdjustments.put("MANA", StatCalculator.RANDOM.nextFloat() * (maxChange - minChange) + minChange); //
        this.chaoticStatAdjustments.put("VIGOR", StatCalculator.RANDOM.nextFloat() * (maxChange - minChange) + minChange); //

        recalculateStats(); // Recalculate all stats with the new adjustments
        sync();
        return true;
    }

    /**
     * Handles the tick-based logic for chaotic transformation.
     * Ends the transformation and starts cooldown when duration expires.
     * @param currentTick The current game tick.
     */
    @Override
    public void handleChaoticTransformationTick(long currentTick) {
        if (this.inChaoticTransformation && currentTick >= this.chaoticTransformationEndTime) {
            endChaoticTransformation(currentTick);
        }
    }

    /**
     * Ends the chaotic transformation and initiates the cooldown.
     * Resets stat adjustments and recalculates stats to normal.
     * @param currentTick The current game tick.
     */
    private void endChaoticTransformation(long currentTick) {
        this.inChaoticTransformation = false;
        this.chaoticStatAdjustments.clear(); // Clear all adjustments

        ChimeraFormDataConfig.ChaoticTransformationSettings settings = ChimeraFormDataConfig.getInstance().getTransformationSettings("CHAOTIC_TRANSFORMATION"); //
        this.chaoticTransformationCooldownEndTime = currentTick + settings.getCooldownTicks(); //

        recalculateStats(); // Recalculate stats back to normal
        sync();
    }

    @Override
    public boolean isInChaoticTransformation() {
        return inChaoticTransformation;
    }

    @Override
    public long getChaoticTransformationEndTime() {
        return chaoticTransformationEndTime;
    }

    @Override
    public long getChaoticTransformationCooldownEndTime() {
        return chaoticTransformationCooldownEndTime;
    }

    @Override
    public Map<String, Float> getChaoticStatAdjustments() {
        return Collections.unmodifiableMap(chaoticStatAdjustments);
    }

    @Override
    public float getChaoticStatAdjustment(String statName) {
        return chaoticStatAdjustments.getOrDefault(statName.toUpperCase(), 0.0f);
    }

    // Generic helper method to handle setting a stat value with clamping and optional sync.
    // It returns the clamped value. The caller is responsible for assigning it to the correct field.
    private float updateAndSyncStat(float newValue, float maxValue, float currentValue, boolean doSync) {
        float clampedValue = Math.max(0, Math.min(newValue, maxValue));
        // Only sync if requested, on server side, and if the value actually changed.
        if (doSync && !player.level().isClientSide() && clampedValue != currentValue) {
            sync();
        }
        return clampedValue;
    }
}