package com.malware98.brokenpath.commands;

import com.malware98.brokenpath.BrokenPath;
import com.malware98.brokenpath.capabilities.IPlayerStats;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;
import com.malware98.brokenpath.commands.suggestions.RaceSuggestions;
import com.malware98.brokenpath.commands.suggestions.AttributeSuggestions;
import com.malware98.brokenpath.data.config.AttributeConfig;
import com.malware98.brokenpath.data.config.RaceDataConfig;
import com.malware98.brokenpath.data.config.ClassDataConfig;
import com.malware98.brokenpath.data.config.SpecializationDataConfig;
import com.malware98.brokenpath.data.config.ChimeraFormDataConfig;
import com.malware98.brokenpath.events.PlayerStatEventHandler;
import com.malware98.brokenpath.util.CapabilityUtils;
import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.arguments.IntegerArgumentType;
import com.mojang.brigadier.arguments.StringArgumentType;
import com.mojang.brigadier.context.CommandContext;
import com.mojang.brigadier.exceptions.CommandSyntaxException;
import net.minecraft.commands.Commands;
import net.minecraft.network.chat.Component;
import net.minecraft.world.entity.player.Player;
import net.minecraftforge.event.RegisterCommandsEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Registers and implements custom commands for the "BrokenPath" mod.
 * Provides administrative and debugging tools for player stats and progression.
 */
@Mod.EventBusSubscriber(modid = BrokenPath.MOD_ID)
public class ModCommands {

    /**
     * Event handler for registering mod commands.
     * @param event The command registration event.
     */
    @SubscribeEvent // Subscribes to RegisterCommandsEvent
    public static void onRegisterCommands(RegisterCommandsEvent event) {
        CommandDispatcher<net.minecraft.commands.CommandSourceStack> dispatcher = event.getDispatcher();
        register(dispatcher);
    }

    /**
     * Registers all custom commands for the "BrokenPath" mod.
     * @param dispatcher The command dispatcher.
     */
    public static void register(CommandDispatcher<net.minecraft.commands.CommandSourceStack> dispatcher) {
        dispatcher.register(
                Commands.literal("bp") // Base command: /bp
                        .then(Commands.literal("setrace") // Subcommand: /bp setrace <race_name>
                                .then(Commands.argument("race_name", StringArgumentType.string())
                                        .suggests(RaceSuggestions.INSTANCE)
                                        .executes(context -> setRace(context, StringArgumentType.getString(context, "race_name")))
                                )
                        )
                        .then(Commands.literal("setclass") // Subcommand: /bp setclass <class_name>
                                .then(Commands.argument("class_name", StringArgumentType.string())
                                        .suggests((context, builder) -> {
                                            ClassDataConfig.getInstance().classSettings.keySet().forEach(builder::suggest);
                                            return builder.buildFuture();
                                        })
                                        .executes(context -> setClass(context, StringArgumentType.getString(context, "class_name")))
                                )
                        )
                        .then(Commands.literal("setspecialization") // Subcommand: /bp setspecialization <specialization_name>
                                .then(Commands.argument("specialization_name", StringArgumentType.string())
                                        .suggests((context, builder) -> {
                                            SpecializationDataConfig.getInstance().specializationSettings.keySet().forEach(builder::suggest);
                                            return builder.buildFuture();
                                        })
                                        .executes(context -> setSpecialization(context, StringArgumentType.getString(context, "specialization_name")))
                                )
                        )
                        .then(Commands.literal("addxp") // Subcommand: /bp addxp <amount>
                                .then(Commands.argument("amount", IntegerArgumentType.integer(1))
                                        .executes(context -> addExperience(context, IntegerArgumentType.getInteger(context, "amount")))
                                )
                        )
                        .then(Commands.literal("resetdata") // Subcommand: /bp resetdata
                                .executes(ModCommands::resetExperience)
                        )
                        .then(Commands.literal("getdata") // Subcommand: /bp getdata
                                .executes(ModCommands::getPlayerData)
                        )
                        .then(Commands.literal("spendattribute") // Subcommand: /bp spendattribute <attribute_name> <amount>
                                .then(Commands.argument("attribute_name", StringArgumentType.string())
                                        .suggests(AttributeSuggestions.INSTANCE)
                                        .then(Commands.argument("amount", IntegerArgumentType.integer(1))
                                                .executes(context -> spendAttributePoints(context, StringArgumentType.getString(context, "attribute_name"), IntegerArgumentType.getInteger(context, "amount")))
                                        )
                                )
                        )
                        .then(Commands.literal("startchaotic") // Subcommand: /bp startchaotic
                                .executes(ModCommands::startChaoticTransformation)
                        )
        );
    }

    // --- Command Implementations ---

    /**
     * Sets the player's race.
     * @param context The command context.
     * @param raceName The desired race name.
     * @return 1 if successful, 0 if invalid.
     */
    private static int setRace(CommandContext<net.minecraft.commands.CommandSourceStack> context, String raceName) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();
        String normalizedRaceName = raceName.toUpperCase(Locale.ROOT);

        if (!RaceDataConfig.getInstance().raceSettings.containsKey(normalizedRaceName)) {
            String validRaces = RaceDataConfig.getInstance().raceSettings.keySet().stream()
                    .map(String::toLowerCase)
                    .collect(Collectors.joining(", "));
            context.getSource().sendFailure(Component.translatable("message.brokenpath.error.race_not_found", raceName, validRaces));
            return 0;
        }

        CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
            playerStats.setRace(normalizedRaceName);
            context.getSource().sendSuccess(() -> Component.literal("Tu raza ha sido establecida a: " + normalizedRaceName), false);
            PlayerStatEventHandler.recalculateAndApplyStats(player);
        });

        return 1;
    }

    /**
     * Sets the player's class.
     * @param context The command context.
     * @param className The desired class name.
     * @return 1 if successful, 0 if invalid.
     */
    private static int setClass(CommandContext<net.minecraft.commands.CommandSourceStack> context, String className) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();
        String normalizedClassName = className.toUpperCase(Locale.ROOT);

        if (!ClassDataConfig.getInstance().classSettings.containsKey(normalizedClassName)) {
            String validClasses = ClassDataConfig.getInstance().classSettings.keySet().stream()
                    .map(String::toLowerCase)
                    .collect(Collectors.joining(", "));
            context.getSource().sendFailure(Component.literal("Clase inválida. Clases válidas: " + validClasses));
            return 0;
        }

        CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
            playerStats.setPlayerClass(normalizedClassName);
            context.getSource().sendSuccess(() -> Component.literal("Tu clase ha sido establecida a: " + normalizedClassName), false);
            PlayerStatEventHandler.recalculateAndApplyStats(player);
        });

        return 1;
    }

    /**
     * Sets the player's specialization.
     * @param context The command context.
     * @param specializationName The desired specialization name.
     * @return 1 if successful, 0 if invalid.
     */
    private static int setSpecialization(CommandContext<net.minecraft.commands.CommandSourceStack> context, String specializationName) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();
        String normalizedSpecializationName = specializationName.toUpperCase(Locale.ROOT);

        if (!SpecializationDataConfig.getInstance().specializationSettings.containsKey(normalizedSpecializationName)) {
            String validSpecializations = SpecializationDataConfig.getInstance().specializationSettings.keySet().stream()
                    .map(String::toLowerCase)
                    .collect(Collectors.joining(", "));
            context.getSource().sendFailure(Component.literal("Especialización inválida. Especializaciones válidas: " + validSpecializations));
            return 0;
        }

        CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
            playerStats.setSpecialization(normalizedSpecializationName);
            context.getSource().sendSuccess(() -> Component.literal("Tu especialización ha sido establecida a: " + normalizedSpecializationName), false);
            PlayerStatEventHandler.recalculateAndApplyStats(player);
        });

        return 1;
    }

    /**
     * Adds a specified amount of experience to the player.
     * @param context The command context.
     * @param amount The amount of experience to add.
     * @return 1 if successful.
     */
    private static int addExperience(CommandContext<net.minecraft.commands.CommandSourceStack> context, int amount) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();

        player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(playerXP -> {
            playerXP.addExperience(amount);
            context.getSource().sendSuccess(() -> Component.literal("Se añadieron " + amount + " de experiencia. XP Actual: " + playerXP.getExperience() + ", Nivel: " + playerXP.getLevel()), false);
        });

        return 1;
    }

    /**
     * Resets the player's custom experience and all mod-specific stats to default.
     * @param context The command context.
     * @return 1 if successful.
     */
    private static int resetExperience(CommandContext<net.minecraft.commands.CommandSourceStack> context) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();

        player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(playerXP -> {
            playerXP.resetXP();
            context.getSource().sendSuccess(() -> Component.literal("Tu XP ha sido reiniciada. XP Actual: " + playerXP.getExperience() + ", Nivel: " + playerXP.getLevel()), false);
        });

        CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
            playerStats.resetData();
            context.getSource().sendSuccess(() -> Component.literal("Tus estadísticas también han sido reiniciadas a los valores por defecto de tu raza."), false);
        });

        return 1;
    }

    /**
     * Displays a comprehensive summary of the player's custom stats.
     * @param context The command context.
     * @return 1 if successful.
     */
    private static int getPlayerData(CommandContext<net.minecraft.commands.CommandSourceStack> context) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();

        CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
            StringBuilder messageBuilder = new StringBuilder();

            messageBuilder.append("--- Datos del Jugador ---\n");
            player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(playerXP -> {
                messageBuilder.append("Nivel de XP: ").append(playerXP.getLevel()).append("\n");
                messageBuilder.append("XP Actual: ").append(playerXP.getExperience()).append("\n");
                messageBuilder.append("Deuda de XP: ").append(playerXP.getXPDebt()).append("\n");
            });

            messageBuilder.append("Puntos de Atributo: ").append(playerStats.getAttributePoints()).append("\n");
            messageBuilder.append("Raza: ").append(playerStats.getRace()).append("\n");
            messageBuilder.append("Clase: ").append(playerStats.getPlayerClass()).append("\n");
            messageBuilder.append("Especialización: ").append(playerStats.getSpecialization()).append("\n");
            messageBuilder.append("Puntos de Habilidad: ").append(playerStats.getSkillPoints()).append("\n");

            if (!playerStats.getProfessions().isEmpty()) {
                messageBuilder.append("Profesiones:\n");
                playerStats.getProfessions().forEach((name, level) ->
                        messageBuilder.append("  - ").append(name).append(": Nivel ").append(level).append("\n")
                );
            } else {
                messageBuilder.append("Sin profesiones.\n");
            }

            messageBuilder.append("--- Atributos Principales (Manual) ---\n");
            messageBuilder.append("Constitución: ").append(playerStats.getConstitution()).append("\n");
            messageBuilder.append("Fuerza: ").append(playerStats.getStrength()).append("\n");
            messageBuilder.append("Destreza: ").append(playerStats.getDexterity()).append("\n");
            messageBuilder.append("Inteligencia: ").append(playerStats.getIntelligence()).append("\n");

            messageBuilder.append("--- Estadísticas Primarias (Calculadas) ---\n");

            messageBuilder.append("Salud: ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getCurrentHealth()))
                    .append(" / ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getMaxHealth()))
                    .append("\n");

            messageBuilder.append("Protección (basada en Fuerza): ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getCurrentProtection()))
                    .append(" / ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getMaxProtection()))
                    .append("\n");

            messageBuilder.append("Protección Innata: ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getCurrentInnateProtection()))
                    .append(" / ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getMaxInnateProtection()))
                    .append("\n");

            messageBuilder.append("Maná: ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getCurrentMana()))
                    .append(" / ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getMaxMana()))
                    .append("\n");

            messageBuilder.append("Vigor: ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getCurrentVigor()))
                    .append(" / ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getMaxVigor()))
                    .append("\n");

            messageBuilder.append("Favor: ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getFavor()))
                    .append("\n");
            messageBuilder.append("Multiplicador de Bonificación de Favor: ")
                    .append(String.format(Locale.US, "%.2f", playerStats.getFavorBonusMultiplier()))
                    .append("\n");

            messageBuilder.append("Etapa de Hambre: ").append(playerStats.getHungerStage()).append("\n");

            // Chaotic Transformation Status.
            if ("CHIMERA".equalsIgnoreCase(playerStats.getRace())) {
                messageBuilder.append("--- Transformación Caótica ---\n");
                messageBuilder.append("Activa: ").append(playerStats.isInChaoticTransformation() ? "Sí" : "No").append("\n");
                if (playerStats.isInChaoticTransformation()) {
                    messageBuilder.append("Fin en el tick: ").append(playerStats.getChaoticTransformationEndTime()).append("\n");
                } else if (player.level().getGameTime() < playerStats.getChaoticTransformationCooldownEndTime()) {
                    long remainingCooldown = (playerStats.getChaoticTransformationCooldownEndTime() - player.level().getGameTime()) / 20;
                    messageBuilder.append("En enfriamiento: ").append(remainingCooldown).append(" segundos restantes\n");
                }
                // Display current chaotic adjustments for debugging
                if (!playerStats.getChaoticStatAdjustments().isEmpty()) {
                    messageBuilder.append("Ajustes Caóticos Actuales:\n");
                    playerStats.getChaoticStatAdjustments().forEach((stat, adjustment) ->
                            messageBuilder.append("  - ").append(stat).append(": ").append(String.format(Locale.US, "%.2f", adjustment * 100)).append("%\n")
                    );
                }
            }

            messageBuilder.append("-------------------------");

            context.getSource().sendSuccess(() -> Component.literal(messageBuilder.toString()), false);
        });

        return 1;
    }

    /**
     * Allows a player to spend available attribute points on a core attribute.
     * @param context The command context.
     * @param attributeName The attribute to increase.
     * @param amount The number of points to spend.
     * @return 1 if successful, 0 if unable to spend points.
     */
    private static int spendAttributePoints(CommandContext<net.minecraft.commands.CommandSourceStack> context, String attributeName, int amount) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();

        Map<String, String> attributeNameMap = new HashMap<>();
        attributeNameMap.put("CON", "CONSTITUTION");
        attributeNameMap.put("STR", "STRENGTH");
        attributeNameMap.put("DEX", "DEXTERITY");
        attributeNameMap.put("INT", "INTELLIGENCE");

        String shortAttributeNameUpper = attributeName.toUpperCase(Locale.ROOT);
        String fullAttributeName = attributeNameMap.get(shortAttributeNameUpper);

        if (fullAttributeName == null) {
            context.getSource().sendFailure(Component.literal("Nombre de atributo inválido. Abreviaturas válidas: CON, STR, DEX, INT."));
            return 0;
        }

        CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
            int currentAttributePoints = playerStats.getAttributePoints();
            if (currentAttributePoints < amount) {
                context.getSource().sendFailure(Component.literal("Solo tienes " + currentAttributePoints + " puntos de atributo."));
                return;
            }

            boolean success = playerStats.spendAttributePoints(fullAttributeName, amount);

            if (success) {
                context.getSource().sendSuccess(() -> Component.literal("Se gastaron " + amount + " puntos en " + shortAttributeNameUpper + ". Puntos restantes: " + playerStats.getAttributePoints()), false);
            } else {
                int manualLimit = AttributeConfig.getInstance().getManualAllocationLimit(fullAttributeName);
                int currentAttributeValue;
                switch (fullAttributeName) {
                    case "CONSTITUTION":
                        currentAttributeValue = playerStats.getConstitution();
                        break;
                    case "STRENGTH":
                        currentAttributeValue = playerStats.getStrength();
                        break;
                    case "DEXTERITY":
                        currentAttributeValue = playerStats.getDexterity();
                        break;
                    case "INTELLIGENCE":
                        currentAttributeValue = playerStats.getIntelligence();
                        break;
                    default:
                        currentAttributeValue = 0;
                }

                PlayerStatEventHandler.recalculateAndApplyStats(player);

                if (currentAttributeValue >= manualLimit) {
                    context.getSource().sendFailure(Component.literal("Has alcanzado el límite máximo de asignación (" + manualLimit + ") para " + shortAttributeNameUpper + "."));
                } else {
                    context.getSource().sendFailure(Component.literal("No se pudieron gastar puntos en " + shortAttributeNameUpper + ". Verifica tus puntos disponibles o límites de atributo."));
                }
            }
        });

        return 1;
    }

    /**
     * Starts the Chimera's Chaotic Transformation.
     * @param context The command context.
     * @return 1 if successful, 0 otherwise.
     */
    private static int startChaoticTransformation(CommandContext<net.minecraft.commands.CommandSourceStack> context) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();

        CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
            if ("CHIMERA".equalsIgnoreCase(playerStats.getRace())) {
                if (playerStats.startChaoticTransformation(player.level().getGameTime())) {
                    context.getSource().sendSuccess(() -> Component.literal("¡La Quimera ha iniciado su Transformación Caótica!"), false);
                } else {
                    context.getSource().sendFailure(Component.literal("No se pudo iniciar la Transformación Caótica. Asegúrate de que no esté en enfriamiento o que la duración esté configurada."));
                }
            } else {
                context.getSource().sendFailure(Component.literal("Solo los jugadores Quimera pueden usar la Transformación Caótica."));
            }
        });

        return 1;
    }
}