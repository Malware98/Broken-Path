package com.malware98.brokenpath.commands;

import com.malware98.brokenpath.BrokenPath;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;
import com.malware98.brokenpath.commands.suggestions.RaceSuggestions;
import com.malware98.brokenpath.data.ModConfigs;
import com.malware98.brokenpath.events.PlayerStatEventHandler;
import com.malware98.brokenpath.util.CapabilityUtils;
import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.arguments.IntegerArgumentType;
import com.mojang.brigadier.arguments.StringArgumentType;
import com.mojang.brigadier.context.CommandContext;
import com.mojang.brigadier.exceptions.CommandSyntaxException;
import net.minecraft.commands.CommandSourceStack;
import net.minecraft.commands.Commands;
import net.minecraft.network.chat.Component;
import net.minecraft.world.entity.player.Player;
import net.minecraftforge.event.RegisterCommandsEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

import java.util.Locale;

/**
 * Registers and implements custom commands for the "BrokenPath" mod.
 * These commands provide administrative and debugging tools for managing player stats and progression.
 */
@Mod.EventBusSubscriber(modid = BrokenPath.MOD_ID)
public class ModCommands {

    /**
     * Event handler for registering mod commands.
     * Subscribes to {@link RegisterCommandsEvent} to add custom commands to the game.
     * @param event The command registration event.
     */
    @SubscribeEvent
    public static void onRegisterCommands(RegisterCommandsEvent event) {
        CommandDispatcher<CommandSourceStack> dispatcher = event.getDispatcher();
        register(dispatcher);
    }

    /**
     * Registers all custom commands for the "BrokenPath" mod.
     * Defines the command structure and links them to their respective execution methods.
     * @param dispatcher The command dispatcher to register commands with.
     */
    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
        dispatcher.register(
                Commands.literal("bp") // Base command: /bp
                        .then(Commands.literal("setrace") // Subcommand: /bp setrace <race_name>
                                .then(Commands.argument("race_name", StringArgumentType.string())
                                        .suggests(RaceSuggestions.INSTANCE) // Provides autocomplete suggestions for race names.
                                        .executes(context -> setRace(context, StringArgumentType.getString(context, "race_name")))
                                )
                        )
                        .then(Commands.literal("addxp") // Subcommand: /bp addxp <amount>
                                .then(Commands.argument("amount", IntegerArgumentType.integer(1))
                                        .executes(context -> addExperience(context, IntegerArgumentType.getInteger(context, "amount")))
                                )
                        )
                        .then(Commands.literal("resetdata") // Subcommand: /bp resetdata
                                .executes(ModCommands::resetExperience)
                        )
                        .then(Commands.literal("getdata") // Subcommand: /bp getdata
                                .executes(ModCommands::getPlayerData)
                        )
        );
    }

    // --- Command Implementations ---

    /**
     * Sets the player's race.
     * Validates the provided race name against configured races and updates player stats accordingly.
     * @param context The command context.
     * @param raceName The desired race name.
     * @return 1 if successful, 0 if the race name is invalid.
     * @throws CommandSyntaxException If the command sender is not a player.
     */
    private static int setRace(CommandContext<CommandSourceStack> context, String raceName) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();
        String normalizedRaceName = raceName.toUpperCase(Locale.ROOT);

        // Validate if the provided race name exists in the mod's configurations.
        // This is crucial to prevent setting an invalid race.
        if (!ModConfigs.getInstance().raceSettings.containsKey(normalizedRaceName)) {
            StringBuilder validRaces = new StringBuilder();
            boolean first = true;
            for (String r : ModConfigs.getInstance().raceSettings.keySet()) {
                if (!first) {
                    validRaces.append(", ");
                }
                validRaces.append(r.toLowerCase(Locale.ROOT));
                first = false;
            }
            context.getSource().sendFailure(Component.translatable("message.brokenpath.error.race_not_found", raceName, validRaces.toString()));
            return 0;
        }

        CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
            playerStats.setRace(normalizedRaceName);
            context.getSource().sendSuccess(() -> Component.literal("Your race has been set to: " + normalizedRaceName), false);
            // Recalculate and apply stats immediately after changing race to update derived stats.
            PlayerStatEventHandler.recalculateAndApplyStats(player);
        });

        return 1;
    }

    /**
     * Adds a specified amount of experience to the player.
     * Uses the mod's custom XP system, which handles leveling up and XP debt.
     * @param context The command context.
     * @param amount The amount of experience to add.
     * @return 1 if successful.
     * @throws CommandSyntaxException If the command sender is not a player.
     */
    private static int addExperience(CommandContext<CommandSourceStack> context, int amount) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();

        player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(playerXP -> {
            playerXP.addExperience(amount);
            context.getSource().sendSuccess(() -> Component.literal("Added " + amount + " experience. Current XP: " + playerXP.getExperience() + ", Level: " + playerXP.getLevel()), false);
        });

        return 1;
    }

    /**
     * Resets the player's custom experience and all mod-specific stats to default values.
     * This is useful for debugging or restarting progression for a player.
     * @param context The command context.
     * @return 1 if successful.
     * @throws CommandSyntaxException If the command sender is not a player.
     */
    private static int resetExperience(CommandContext<CommandSourceStack> context) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();

        player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(playerXP -> {
            playerXP.resetXP();
            context.getSource().sendSuccess(() -> Component.literal("Your XP has been reset. Current XP: " + playerXP.getExperience() + ", Level: " + playerXP.getLevel()), false);
        });

        CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
            playerStats.resetData();
            context.getSource().sendSuccess(() -> Component.literal("Your stats have also been reset to default values."), false);
        });

        return 1;
    }

    /**
     * Displays a comprehensive summary of the player's custom stats.
     * Includes XP, attribute points, race, class, professions, and all primary calculated stats.
     * This command is essential for debugging and verifying player data.
     * @param context The command context.
     * @return 1 if successful.
     * @throws CommandSyntaxException If the command sender is not a player.
     */
    private static int getPlayerData(CommandContext<CommandSourceStack> context) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();

        CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
            StringBuilder messageBuilder = new StringBuilder();

            messageBuilder.append("--- Player Data ---\n");
            player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(playerXP -> {
                messageBuilder.append("XP Level: ").append(playerXP.getLevel()).append("\n");
                messageBuilder.append("Current XP: ").append(playerXP.getExperience()).append("\n");
                messageBuilder.append("XP Debt: ").append(playerXP.getXPDebt()).append("\n");
            });

            messageBuilder.append("Attribute Points: ").append(playerStats.getAttributePoints()).append("\n");
            messageBuilder.append("Race: ").append(playerStats.getRace()).append("\n");
            messageBuilder.append("Class: ").append(playerStats.getPlayerClass()).append("\n");
            messageBuilder.append("Specialization: ").append(playerStats.getSpecialization()).append("\n");
            messageBuilder.append("Skill Points: ").append(playerStats.getSkillPoints()).append("\n");

            if (!playerStats.getProfessions().isEmpty()) {
                messageBuilder.append("Professions:\n");
                playerStats.getProfessions().forEach((name, level) ->
                        messageBuilder.append("  - ").append(name).append(": Level ").append(level).append("\n")
                );
            } else {
                messageBuilder.append("No professions.\n");
            }

            messageBuilder.append("--- Core Attributes (Manual) ---\n");
            messageBuilder.append("Constitution: ").append(playerStats.getConstitution()).append("\n");
            messageBuilder.append("Strength: ").append(playerStats.getStrength()).append("\n");
            messageBuilder.append("Dexterity: ").append(playerStats.getDexterity()).append("\n");
            messageBuilder.append("Intelligence: ").append(playerStats.getIntelligence()).append("\n");

            messageBuilder.append("--- Primary Stats (Calculated) ---\n");

            messageBuilder.append("Health: ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getCurrentHealth()))
                    .append(" / ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getMaxHealth()))
                    .append("\n");

            messageBuilder.append("Protection (STR-based): ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getCurrentProtection()))
                    .append(" / ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getMaxProtection()))
                    .append("\n");

            messageBuilder.append("Innate Protection: ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getCurrentInnateProtection()))
                    .append(" / ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getMaxInnateProtection()))
                    .append("\n");

            messageBuilder.append("Mana: ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getCurrentMana()))
                    .append(" / ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getMaxMana()))
                    .append("\n");

            messageBuilder.append("Vigor: ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getCurrentVigor()))
                    .append(" / ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getMaxVigor()))
                    .append("\n");

            messageBuilder.append("Favor: ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getFavor()))
                    .append("\n");
            messageBuilder.append("Favor Bonus Multiplier: ")
                    .append(String.format(Locale.US, "%.2f", playerStats.getFavorBonusMultiplier()))
                    .append("\n");

            messageBuilder.append("Hunger Stage: ").append(playerStats.getHungerStage()).append("\n");

            messageBuilder.append("-------------------------");

            context.getSource().sendSuccess(() -> Component.literal(messageBuilder.toString()), false);
        });

        return 1;
    }
}