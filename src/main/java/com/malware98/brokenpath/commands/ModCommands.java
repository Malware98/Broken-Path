package com.malware98.brokenpath.commands;

import com.malware98.brokenpath.BrokenPath;
import com.malware98.brokenpath.capabilities.registries.ModCapabilities;
import com.malware98.brokenpath.commands.suggestions.RaceSuggestions;
import com.malware98.brokenpath.commands.suggestions.AttributeSuggestions; // NEW: Import AttributeSuggestions
import com.malware98.brokenpath.data.ModConfigs;
import com.malware98.brokenpath.events.PlayerStatEventHandler;
import com.malware98.brokenpath.util.CapabilityUtils;
import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.arguments.IntegerArgumentType;
import com.mojang.brigadier.arguments.StringArgumentType;
import com.mojang.brigadier.context.CommandContext;
import com.mojang.brigadier.exceptions.CommandSyntaxException;
import net.minecraft.commands.CommandSourceStack;
import net.minecraft.commands.Commands;
import net.minecraft.network.chat.Component;
import net.minecraft.world.entity.player.Player;
import net.minecraftforge.event.RegisterCommandsEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

/**
 * Registers and implements custom commands for the "BrokenPath" mod.
 * These commands provide administrative and debugging tools for managing player stats and progression.
 */
@Mod.EventBusSubscriber(modid = BrokenPath.MOD_ID)
public class ModCommands {

    /**
     * Event handler for registering mod commands.
     * Subscribes to {@link RegisterCommandsEvent} to add custom commands to the game.
     *
     * @param event The command registration event.
     */
    @SubscribeEvent
    public static void onRegisterCommands(RegisterCommandsEvent event) {
        CommandDispatcher<CommandSourceStack> dispatcher = event.getDispatcher();
        register(dispatcher);
    }

    /**
     * Registers all custom commands for the "BrokenPath" mod.
     * Defines the command structure and links them to their respective execution methods.
     *
     * @param dispatcher The command dispatcher to register commands with.
     */
    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
        dispatcher.register(
                Commands.literal("bp") // Base command: /bp
                        .then(Commands.literal("setrace") // Subcommand: /bp setrace <race_name>
                                .then(Commands.argument("race_name", StringArgumentType.string())
                                        .suggests(RaceSuggestions.INSTANCE) // Provides autocomplete suggestions for race names.
                                        .executes(context -> setRace(context, StringArgumentType.getString(context, "race_name")))
                                )
                        )
                        .then(Commands.literal("addxp") // Subcommand: /bp addxp <amount>
                                .then(Commands.argument("amount", IntegerArgumentType.integer(1))
                                        .executes(context -> addExperience(context, IntegerArgumentType.getInteger(context, "amount")))
                                )
                        )
                        .then(Commands.literal("resetdata") // Subcommand: /bp resetdata
                                .executes(ModCommands::resetExperience)
                        )
                        .then(Commands.literal("getdata") // Subcommand: /bp getdata
                                .executes(ModCommands::getPlayerData)
                        )
                        .then(Commands.literal("spendattribute") // NEW: Subcommand for spending attribute points
                                .then(Commands.argument("attribute_name", StringArgumentType.string())
                                        .suggests(AttributeSuggestions.INSTANCE) // Provides autocomplete for attribute names
                                        .then(Commands.argument("amount", IntegerArgumentType.integer(1))
                                                .executes(context -> spendAttributePoints(context, StringArgumentType.getString(context, "attribute_name"), IntegerArgumentType.getInteger(context, "amount")))
                                        )
                                )
                        )
        );
    }

    // --- Command Implementations ---

    /**
     * Sets the player's race.
     * Validates the provided race name against configured races and updates player stats accordingly.
     *
     * @param context  The command context.
     * @param raceName The desired race name.
     * @return 1 if successful, 0 if the race name is invalid.
     * @throws CommandSyntaxException If the command sender is not a player.
     */
    private static int setRace(CommandContext<CommandSourceStack> context, String raceName) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();
        String normalizedRaceName = raceName.toUpperCase(Locale.ROOT);

        // Validate if the provided race name exists in the mod's configurations.
        // This is crucial to prevent setting an invalid race.
        if (!ModConfigs.getInstance().raceSettings.containsKey(normalizedRaceName)) {
            StringBuilder validRaces = new StringBuilder();
            boolean first = true;
            for (String r : ModConfigs.getInstance().raceSettings.keySet()) {
                if (!first) {
                    validRaces.append(", ");
                }
                validRaces.append(r.toLowerCase(Locale.ROOT));
                first = false;
            }
            context.getSource().sendFailure(Component.translatable("message.brokenpath.error.race_not_found", raceName, validRaces.toString()));
            return 0;
        }

        CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
            playerStats.setRace(normalizedRaceName);
            context.getSource().sendSuccess(() -> Component.literal("Your race has been set to: " + normalizedRaceName), false);
            // Recalculate and apply stats immediately after changing race to update derived stats.
            PlayerStatEventHandler.recalculateAndApplyStats(player);
        });

        return 1;
    }

    /**
     * Adds a specified amount of experience to the player.
     * Uses the mod's custom XP system, which handles leveling up and XP debt.
     *
     * @param context The command context.
     * @param amount  The amount of experience to add.
     * @return 1 if successful.
     * @throws CommandSyntaxException If the command sender is not a player.
     */
    private static int addExperience(CommandContext<CommandSourceStack> context, int amount) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();

        player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(playerXP -> {
            playerXP.addExperience(amount);
            context.getSource().sendSuccess(() -> Component.literal("Added " + amount + " experience. Current XP: " + playerXP.getExperience() + ", Level: " + playerXP.getLevel()), false);
        });

        return 1;
    }

    /**
     * Resets the player's custom experience and all mod-specific stats to default values based on current race.
     * This is useful for debugging or restarting progression for a player within their chosen race.
     *
     * @param context The command context.
     * @return 1 if successful.
     * @throws CommandSyntaxException If the command sender is not a player.
     */
    private static int resetExperience(CommandContext<CommandSourceStack> context) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();

        player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(playerXP -> {
            playerXP.resetXP();
            context.getSource().sendSuccess(() -> Component.literal("Your XP has been reset. Current XP: " + playerXP.getExperience() + ", Level: " + playerXP.getLevel()), false);
        });

        CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
            playerStats.resetData(); // Now behaves as reset to race defaults
            context.getSource().sendSuccess(() -> Component.literal("Your stats have also been reset to your race's default values."), false);
        });

        return 1;
    }

    /**
     * Displays a comprehensive summary of the player's custom stats.
     * Includes XP, attribute points, race, class, professions, and all primary calculated stats.
     * This command is essential for debugging and verifying player data.
     *
     * @param context The command context.
     * @return 1 if successful.
     * @throws CommandSyntaxException If the command sender is not a player.
     */
    private static int getPlayerData(CommandContext<CommandSourceStack> context) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();

        CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
            StringBuilder messageBuilder = new StringBuilder();

            messageBuilder.append("--- Player Data ---\n");
            player.getCapability(ModCapabilities.PLAYER_XP_CAPABILITY).ifPresent(playerXP -> {
                messageBuilder.append("XP Level: ").append(playerXP.getLevel()).append("\n");
                messageBuilder.append("Current XP: ").append(playerXP.getExperience()).append("\n");
                messageBuilder.append("XP Debt: ").append(playerXP.getXPDebt()).append("\n");
            });

            messageBuilder.append("Attribute Points: ").append(playerStats.getAttributePoints()).append("\n");
            messageBuilder.append("Race: ").append(playerStats.getRace()).append("\n");
            messageBuilder.append("Class: ").append(playerStats.getPlayerClass()).append("\n");
            messageBuilder.append("Specialization: ").append(playerStats.getSpecialization()).append("\n");
            messageBuilder.append("Skill Points: ").append(playerStats.getSkillPoints()).append("\n");

            if (!playerStats.getProfessions().isEmpty()) {
                messageBuilder.append("Professions:\n");
                playerStats.getProfessions().forEach((name, level) ->
                        messageBuilder.append("  - ").append(name).append(": Level ").append(level).append("\n")
                );
            } else {
                messageBuilder.append("No professions.\n");
            }

            messageBuilder.append("--- Core Attributes (Manual) ---\n");
            messageBuilder.append("Constitution: ").append(playerStats.getConstitution()).append("\n");
            messageBuilder.append("Strength: ").append(playerStats.getStrength()).append("\n");
            messageBuilder.append("Dexterity: ").append(playerStats.getDexterity()).append("\n");
            messageBuilder.append("Intelligence: ").append(playerStats.getIntelligence()).append("\n");

            messageBuilder.append("--- Primary Stats (Calculated) ---\n");

            messageBuilder.append("Health: ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getCurrentHealth()))
                    .append(" / ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getMaxHealth()))
                    .append("\n");

            messageBuilder.append("Protection (STR-based): ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getCurrentProtection()))
                    .append(" / ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getMaxProtection()))
                    .append("\n");

            messageBuilder.append("Innate Protection: ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getCurrentInnateProtection()))
                    .append(" / ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getMaxInnateProtection()))
                    .append("\n");

            messageBuilder.append("Mana: ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getCurrentMana()))
                    .append(" / ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getMaxMana()))
                    .append("\n");

            messageBuilder.append("Vigor: ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getCurrentVigor()))
                    .append(" / ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getMaxVigor()))
                    .append("\n");

            messageBuilder.append("Favor: ")
                    .append(String.format(Locale.US, "%.1f", playerStats.getFavor()))
                    .append("\n");
            messageBuilder.append("Favor Bonus Multiplier: ")
                    .append(String.format(Locale.US, "%.2f", playerStats.getFavorBonusMultiplier()))
                    .append("\n");

            messageBuilder.append("Hunger Stage: ").append(playerStats.getHungerStage()).append("\n");

            messageBuilder.append("-------------------------");

            context.getSource().sendSuccess(() -> Component.literal(messageBuilder.toString()), false);
        });

        return 1;
    }

    /**
     * Allows a player to spend available attribute points on a core attribute.
     *
     * @param context       The command context.
     * @param attributeName The name of the attribute to increase (e.g., "constitution").
     * @param amount        The number of points to spend.
     * @return 1 if successful, 0 if unable to spend points (e.g., not enough points, invalid attribute, hit limit).
     * @throws CommandSyntaxException If the command sender is not a player.
     */
    private static int spendAttributePoints(CommandContext<CommandSourceStack> context, String attributeName, int amount) throws CommandSyntaxException {
        Player player = context.getSource().getPlayerOrException();

        // NEW: Map for short to long attribute name transformation
        Map<String, String> attributeNameMap = new HashMap<>();
        attributeNameMap.put("CON", "CONSTITUTION");
        attributeNameMap.put("STR", "STRENGTH");
        attributeNameMap.put("DEX", "DEXTERITY");
        attributeNameMap.put("INT", "INTELLIGENCE");

        String shortAttributeNameUpper = attributeName.toUpperCase(Locale.ROOT); // Get input as uppercase short form
        String fullAttributeName = attributeNameMap.get(shortAttributeNameUpper); // Transform to full name

        // NEW: Validate if the short name is recognized
        if (fullAttributeName == null) {
            context.getSource().sendFailure(Component.literal("Invalid attribute name. Valid abbreviations are: CON, STR, DEX, INT."));
            return 0;
        }

        // Use fullAttributeName for subsequent logic that expects the full name
        // (This replaces all uses of normalizedAttributeName that used the upper-cased input directly)

        CapabilityUtils.ifPlayerStatsPresent(player, playerStats -> {
            int currentAttributePoints = playerStats.getAttributePoints();
            if (currentAttributePoints < amount) {
                context.getSource().sendFailure(Component.literal("You only have " + currentAttributePoints + " attribute points."));
                return;
            }

            // Attempt to spend points using the PlayerStats capability method.
            // Pass the FULL attribute name to the PlayerStats method.
            boolean success = playerStats.spendAttributePoints(fullAttributeName, amount); // USE fullAttributeName HERE

            if (success) {
                context.getSource().sendSuccess(() -> Component.literal("Spent " + amount + " points on " + shortAttributeNameUpper + ". Remaining points: " + playerStats.getAttributePoints()), false); // Display short name in success message
            } else {
                // This could be due to hitting the max limit for the attribute, or an internal error.
                int manualLimit = ModConfigs.getInstance().getManualAttributeLimit(fullAttributeName); // USE fullAttributeName HERE
                int currentAttributeValue;
                switch (fullAttributeName) { // USE fullAttributeName HERE
                    case "CONSTITUTION":
                        currentAttributeValue = playerStats.getConstitution();
                        break;
                    case "STRENGTH":
                        currentAttributeValue = playerStats.getStrength();
                        break;
                    case "DEXTERITY":
                        currentAttributeValue = playerStats.getDexterity();
                        break;
                    case "INTELLIGENCE":
                        currentAttributeValue = playerStats.getIntelligence();
                        break;
                    default:
                        currentAttributeValue = 0; // Should not happen due to prior check and valid full names
                }

                PlayerStatEventHandler.recalculateAndApplyStats(player);

                if (currentAttributeValue >= manualLimit) {
                    context.getSource().sendFailure(Component.literal("You have reached the maximum allocation limit (" + manualLimit + ") for " + shortAttributeNameUpper + ".")); // Display short name in failure message
                } else {
                    context.getSource().sendFailure(Component.literal("Failed to spend points on " + shortAttributeNameUpper + ". Check your available points or attribute limits.")); // Display short name in failure message
                }
            }
        });

        return 1;
    }
}