package com.malware98.brokenpath.calculation;

import com.malware98.brokenpath.data.ModConfigs;
import com.malware98.brokenpath.data.ModConfigs.*;

/**
 * Utility class for calculating the player's final statistics
 * based on attributes, mod configuration, race, and class.
 * Includes calculations for health, mana, vigor, protection, and regeneration.
 */
public class StatCalculator {

    // --- Core Stat Calculations ---

    /**
     * Calculates maximum health based on Constitution, race, and class.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param conPoints The player's Constitution attribute points.
     * @return The calculated maximum health.
     */
    public static float calculateHealth(String raceName, String className, int conPoints) {
        ModConfigs configs = ModConfigs.getInstance();
        // Retrieve the health configuration for the given race.
        // Casting is necessary as getRaceStatConfig returns a more general StatConfigBase.
        HealthStatConfig healthConfig = (HealthStatConfig) configs.getRaceStatConfig(raceName, "HEALTH");

        // Return 0.0f if configuration is missing to prevent NullPointerExceptions.
        if (healthConfig == null || healthConfig.affinityLimits == null) {
            return 0.0f;
        }

        float calculatedHealth = healthConfig.baseInitialValue;
        // Apply Constitution multiplier directly. This scales health based on CON points.
        calculatedHealth += conPoints * healthConfig.conMultiplierPerPoint;
        AffinityLimit activeAffinity = healthConfig.affinityLimits.get("BASE");

        boolean classBoostsAttribute = configs.doesClassBoostAttribute(className, "CONSTITUTION");
        boolean hasRacialAffinity = configs.isClassAffinToStat(raceName, className, "HEALTH");

        // Prioritize racial affinity over class bonus for stat scaling.
        // This allows for deeper customization and unique race-class combinations.
        if (hasRacialAffinity) {
            activeAffinity = healthConfig.affinityLimits.get("RACIAL_AFFINITY");
        } else if (classBoostsAttribute) {
            activeAffinity = healthConfig.affinityLimits.get("CLASS_BONUS");
        }

        // Fallback to a safe default affinity if no specific one is found.
        if (activeAffinity == null) {
            activeAffinity = new AffinityLimit(1.0f, Float.MAX_VALUE);
        }

        calculatedHealth *= activeAffinity.multiplier;
        calculatedHealth = Math.min(calculatedHealth, activeAffinity.limit); // Clamp to affinity limit.

        return calculatedHealth;
    }

    /**
     * Calculates maximum mana based on Intelligence, race, and class.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param intPoints The player's Intelligence attribute points.
     * @return The calculated maximum mana.
     */
    public static float calculateMana(String raceName, String className, int intPoints) {
        ModConfigs configs = ModConfigs.getInstance();
        ManaStatConfig manaConfig = (ManaStatConfig) configs.getRaceStatConfig(raceName, "MANA");

        if (manaConfig == null || manaConfig.affinityLimits == null) {
            return 0.0f;
        }

        float calculatedMana = manaConfig.baseInitialValue;
        // Apply Intelligence multiplier directly.
        calculatedMana += intPoints * manaConfig.intMultiplierPerPoint;

        AffinityLimit activeAffinity = manaConfig.affinityLimits.get("BASE");
        boolean classBoostsAttribute = configs.doesClassBoostAttribute(className, "INTELLIGENCE");
        boolean hasRacialAffinity = configs.isClassAffinToStat(raceName, className, "MANA");

        if (hasRacialAffinity) {
            activeAffinity = manaConfig.affinityLimits.get("RACIAL_AFFINITY");
        } else if (classBoostsAttribute) {
            activeAffinity = manaConfig.affinityLimits.get("CLASS_BONUS");
        }

        if (activeAffinity == null) {
            activeAffinity = new AffinityLimit(1.0f, Float.MAX_VALUE);
        }

        calculatedMana *= activeAffinity.multiplier;
        calculatedMana = Math.min(calculatedMana, activeAffinity.limit);

        return calculatedMana;
    }

    /**
     * Calculates maximum vigor based on Dexterity, race, and class.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param dexPoints The player's Dexterity attribute points.
     * @return The calculated maximum vigor.
     */
    public static float calculateVigor(String raceName, String className, int dexPoints) {
        ModConfigs configs = ModConfigs.getInstance();
        VigorStatConfig vigorConfig = (VigorStatConfig) configs.getRaceStatConfig(raceName, "VIGOR");

        if (vigorConfig == null || vigorConfig.affinityLimits == null) {
            return 0.0f;
        }

        float calculatedVigor = vigorConfig.baseInitialValue;
        // Apply Dexterity multiplier directly.
        calculatedVigor += dexPoints * vigorConfig.dexMultiplierPerPoint;

        AffinityLimit activeAffinity = vigorConfig.affinityLimits.get("BASE");
        boolean classBoostsAttribute = configs.doesClassBoostAttribute(className, "DEXTERITY");
        boolean hasRacialAffinity = configs.isClassAffinToStat(raceName, className, "VIGOR");

        if (hasRacialAffinity) {
            activeAffinity = vigorConfig.affinityLimits.get("RACIAL_AFFINITY");
        } else if (classBoostsAttribute) {
            activeAffinity = vigorConfig.affinityLimits.get("CLASS_BONUS");
        }

        if (activeAffinity == null) {
            activeAffinity = new AffinityLimit(1.0f, Float.MAX_VALUE);
        }

        calculatedVigor *= activeAffinity.multiplier;
        calculatedVigor = Math.min(calculatedVigor, activeAffinity.limit);

        return calculatedVigor;
    }

    /**
     * Calculates the protection value based on Strength, race, and class.
     * This represents the amount of damage that can be absorbed by physical defense.
     * @param raceName The name of the player's race.
     * @param className The name of the player's class.
     * @param strPoints The player's Strength attribute points.
     * @return The calculated protection value.
     */
    public static float calculateProtectionFromSTR(String raceName, String className, int strPoints) {
        ModConfigs configs = ModConfigs.getInstance();
        ProtectionStatConfig protectionConfig = configs.getRaceProtectionConfig(raceName);

        if (protectionConfig == null || protectionConfig.affinityLimits == null) {
            return 0.0f;
        }

        // Apply Strength efficacy multiplier directly. This scales protection based on STR points.
        float strBasedProtection = strPoints * protectionConfig.strEfficacyMultiplierPerPoint;

        AffinityLimit activeAffinity = protectionConfig.affinityLimits.get("BASE");
        boolean classBoostsAttribute = configs.doesClassBoostAttribute(className, "STRENGTH");
        boolean hasRacialAffinity = configs.isClassAffinToStat(raceName, className, "PROTECTION");

        if (hasRacialAffinity) {
            activeAffinity = protectionConfig.affinityLimits.get("RACIAL_AFFINITY");
        } else if (classBoostsAttribute) {
            activeAffinity = protectionConfig.affinityLimits.get("CLASS_BONUS");
        }

        if (activeAffinity == null) {
            activeAffinity = new AffinityLimit(1.0f, Float.MAX_VALUE);
        }

        strBasedProtection *= activeAffinity.multiplier;
        strBasedProtection = Math.min(strBasedProtection, activeAffinity.limit);

        return strBasedProtection;
    }

    /**
     * Calculates innate protection based on player level and race.
     * Innate protection is a passive damage reduction that scales with level.
     * @param raceName The name of the player's race.
     * @param currentLevel The player's current level.
     * @return The calculated innate protection value.
     */
    public static float calculateInnateProtection(String raceName, int currentLevel) {
        ModConfigs configs = ModConfigs.getInstance();
        ModConfigs.ProtectionInnateConfig innateConfig = configs.getRaceProtectionInnateConfig(raceName);

        if (innateConfig == null) {
            return 0.0f;
        }

        float innateProtection = innateConfig.baseValue;
        // Innate protection increases per level (beyond level 1).
        innateProtection += innateConfig.perLevelIncrease * (currentLevel - 1);
        return innateProtection;
    }

    // --- Regeneration Calculations ---

    /**
     * Calculates the cooldown ticks for health regeneration.
     * This cooldown is influenced by Constitution, regeneration speed bonuses, and combat status.
     * A lower cooldown means faster regeneration.
     * @param constitution The player's Constitution attribute points.
     * @param regenSpeedBonusTicks Bonus ticks to reduce cooldown (e.g., from effects or gear).
     * @param inCombat True if the player is currently in combat.
     * @param lastCombatExitTick The game tick when the player last exited combat.
     * @param currentTick The current game tick.
     * @return The effective health regeneration cooldown in ticks.
     */
    public static int calculateHealthRegenCooldown(int constitution, float regenSpeedBonusTicks, boolean inCombat, long lastCombatExitTick, long currentTick) {
        ModConfigs configs = ModConfigs.getInstance();

        // Regeneration is significantly slowed if in combat or recently exited combat.
        // The base cooldown is modified by bonuses and CON.
        if (inCombat || (currentTick - lastCombatExitTick < configs.getHealthDelayAfterCombatTicks())) {
            // No specific action here, allowing the calculation to proceed with base values, as intended.
        }
        float conBonus = constitution * configs.getHealthRegenBonusPerConTicks();
        int effectiveCooldown = (int) (configs.getHealthRegenCooldownTicksBase() - regenSpeedBonusTicks - conBonus);
        // Ensure cooldown does not go below the minimum configured value to prevent excessively fast regen.
        return Math.max(effectiveCooldown, configs.getHealthMinEffectiveCooldownTicks());
    }

    /**
     * Calculates the amount of mana regenerated per tick.
     * Regeneration rate differs between in-combat and out-of-combat states.
     * @param intelligence The player's Intelligence attribute points.
     * @param inCombat True if the player is currently in combat.
     * @return The amount of mana regenerated per tick.
     */
    public static float calculateManaRegenPerTick(int intelligence, boolean inCombat) {
        ModConfigs configs = ModConfigs.getInstance();
        // Use different base regeneration rates depending on combat status.
        float baseRegen = inCombat ? configs.getManaRegenInCombatBase() : configs.getManaRegenOutOfCombatBase();
        return baseRegen + (intelligence * configs.getManaRegenBonusPerInt());
    }

    /**
     * Calculates the amount of vigor regenerated per tick.
     * Regeneration rate differs between in-combat and out-of-combat states.
     * @param dexterity The player's Dexterity attribute points.
     * @param inCombat True if the player is currently in combat.
     * @return The amount of vigor regenerated per tick.
     */
    public static float calculateVigorRegenPerTick(int dexterity, boolean inCombat) {
        ModConfigs configs = ModConfigs.getInstance();
        // Use different base regeneration rates depending on combat status.
        float baseRegen = inCombat ? configs.getVigorRegenInCombatBase() : configs.getVigorRegenOutOfCombatBase();
        return baseRegen + (dexterity * configs.getVigorRegenBonusPerDex());
    }
}