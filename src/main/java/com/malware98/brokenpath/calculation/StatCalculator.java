package com.malware98.brokenpath.calculation;

import com.malware98.brokenpath.capabilities.PlayerStats;
import com.malware98.brokenpath.data.config.*;

import java.util.Random;

/**
 * Utility class for calculating the player's final statistics
 * based on attributes, mod configuration, race, and class.
 */
public class StatCalculator {

    // --- Random instance for chaotic transformations ---
    public static final Random RANDOM = new Random();

    /**
     * Calculates a generic player statistic (e.g., Health, Mana, Vigor, Protection)
     * based on race, class, specialization, and an associated attribute.
     * @param playerStats The PlayerStats instance.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param attributePoints The player's attribute points.
     * @param attributeMultiplier The multiplier applied per attribute point.
     * @param statName The name of the statistic being calculated.
     * @return The calculated value for the specified generic statistic.
     */
    private static float calculateGenericStat(PlayerStats playerStats, String raceName, String className, String specializationName,
                                              int attributePoints, float attributeMultiplier, String statName) {

        float calculatedStat = 0.0f;
        RaceDataConfig.RaceSettings raceSettings = RaceDataConfig.getInstance().getRaceSettings(raceName);
        ClassDataConfig.ClassSettings classSettings = ClassDataConfig.getInstance().getClassSettings(className);
        SpecializationDataConfig.SpecializationSettings specializationSettings = SpecializationDataConfig.getInstance().getSpecializationSettings(specializationName);

        // Get Base Racial Stat.
        switch (statName.toUpperCase()) {
            case "HEALTH": calculatedStat = raceSettings.getHealth(); break;
            case "PROTECTION": calculatedStat = raceSettings.getProtection(); break;
            case "MANA": calculatedStat = raceSettings.getMana(); break;
            case "VIGOR": calculatedStat = raceSettings.getVigor(); break;
            default: calculatedStat = 0.0f; break;
        }

        // Apply attribute multiplier.
        calculatedStat += attributePoints * attributeMultiplier;

        // Apply Class Fixed Bonus.
        if (statName.equalsIgnoreCase(classSettings.getClassBonusStatName())) {
            calculatedStat += classSettings.getClassBonusStatValue();
        }

        // Apply Specialization Fixed Bonus.
        if (statName.equalsIgnoreCase(specializationSettings.getStatBonusName())) {
            if (!statName.equalsIgnoreCase(classSettings.getAffinityStatName())) {
                calculatedStat += specializationSettings.getStatBonusValue();
            }
        }

        // Apply Affinity Tier Bonus (from Class selection).
        if (statName.equalsIgnoreCase(classSettings.getAffinityStatName())) {
            String affinityTier = AffinityMappingConfig.getInstance().getAffinityTier(raceName, className);
            float affinityBonus = 0.0f;
            switch (affinityTier) {
                case "IDEAL": affinityBonus = AffinityTierDataConfig.getInstance().getIdealTierBonusClass(); break;
                case "EFFICIENT": affinityBonus = AffinityTierDataConfig.getInstance().getEfficientTierBonusClass(); break;
                case "ACCEPTABLE": affinityBonus = AffinityTierDataConfig.getInstance().getAcceptableTierBonusClass(); break;
                case "DEFICIENT": affinityBonus = AffinityTierDataConfig.getInstance().getDeficientTierBonusClass(); break;
                default: affinityBonus = 0.0f; break;
            }
            calculatedStat += affinityBonus;
        }

        // Apply Affinity Tier Bonus (from Specialization selection).
        if (statName.equalsIgnoreCase(classSettings.getAffinityStatName())) {
            if (!specializationName.isEmpty() && !specializationName.equalsIgnoreCase("NO_SPECIALIZATION")) {
                String affinityTier = AffinityMappingConfig.getInstance().getAffinityTier(raceName, className);
                float affinityBonus = 0.0f;
                switch (affinityTier) {
                    case "IDEAL": affinityBonus = AffinityTierDataConfig.getInstance().getIdealTierBonusSpecialization(); break;
                    case "EFFICIENT": affinityBonus = AffinityTierDataConfig.getInstance().getEfficientTierBonusSpecialization(); break;
                    case "ACCEPTABLE": affinityBonus = AffinityTierDataConfig.getInstance().getAcceptableTierBonusSpecialization(); break;
                    case "DEFICIENT": affinityBonus = AffinityTierDataConfig.getInstance().getDeficientTierBonusSpecialization(); break;
                    default: affinityBonus = 0.0f; break;
                }
                calculatedStat += affinityBonus;
            }
        }

        // Apply Chaotic Transformation Percentage (if active for Chimera).
        if ("CHIMERA".equalsIgnoreCase(raceName) && playerStats.isInChaoticTransformation()) {
            float adjustmentPercentage = playerStats.getChaoticStatAdjustment(statName);
            calculatedStat *= (1.0f + adjustmentPercentage);
        }

        return calculatedStat;
    }

    // --- Core Stat Calculations ---
    /**
     * Calculates the player's maximum health.
     * @param playerStats The PlayerStats instance.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param conPoints The player's Constitution attribute points.
     * @return The calculated maximum health.
     */
    public static float calculateHealth(PlayerStats playerStats, String raceName, String className, String specializationName, int conPoints) {
        float multiplier = AttributeConfig.getInstance().getConMultiplier();
        return calculateGenericStat(playerStats, raceName, className, specializationName,
                conPoints, multiplier, "HEALTH");
    }

    /**
     * Calculates the player's maximum mana.
     * @param playerStats The PlayerStats instance.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param intPoints The player's Intelligence attribute points.
     * @return The calculated maximum mana.
     */
    public static float calculateMana(PlayerStats playerStats, String raceName, String className, String specializationName, int intPoints) {
        float multiplier = AttributeConfig.getInstance().getIntMultiplier();
        return calculateGenericStat(playerStats, raceName, className, specializationName,
                intPoints, multiplier, "MANA");
    }

    /**
     * Calculates the player's maximum vigor.
     * @param playerStats The PlayerStats instance.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param dexPoints The player's Dexterity attribute points.
     * @return The calculated maximum vigor.
     */
    public static float calculateVigor(PlayerStats playerStats, String raceName, String className, String specializationName, int dexPoints) {
        float multiplier = AttributeConfig.getInstance().getDexMultiplier();
        return calculateGenericStat(playerStats, raceName, className, specializationName,
                dexPoints, multiplier, "VIGOR");
    }

    /**
     * Calculates the player's protection value from Strength.
     * @param playerStats The PlayerStats instance.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param strPoints The player's Strength attribute points.
     * @return The calculated protection value.
     */
    public static float calculateProtectionFromSTR(PlayerStats playerStats, String raceName, String className, String specializationName, int strPoints) {
        float multiplier = AttributeConfig.getInstance().getStrMultiplier();
        return calculateGenericStat(playerStats, raceName, className, specializationName,
                strPoints, multiplier, "PROTECTION");
    }

    /**
     * Calculates innate protection based on player level and race.
     * @param playerStats The PlayerStats instance.
     * @param raceName The player's race name.
     * @param currentLevel The player's current level.
     * @return The calculated innate protection value.
     */
    public static float calculateInnateProtection(PlayerStats playerStats, String raceName, int currentLevel) {
        float innateProtectionPerLevelIncrease = AttributeConfig.getInstance().getInnateProtectionPerLevelIncrease();
        RaceDataConfig.RaceSettings raceSettings = RaceDataConfig.getInstance().getRaceSettings(raceName);
        float innateBaseValue = raceSettings.getProtectionInnate();

        if (innateBaseValue > 0) {
            innateBaseValue += innateProtectionPerLevelIncrease * (currentLevel - 1);
        }

        if ("CHIMERA".equalsIgnoreCase(raceName) && playerStats.isInChaoticTransformation()) {
            float adjustmentPercentage = playerStats.getChaoticStatAdjustment("INNATE_PROTECTION");
            innateBaseValue *= (1.0f + adjustmentPercentage);
        }

        return (float) Math.round(innateBaseValue);
    }

    // --- Regeneration Calculations ---
    /**
     * Calculates the cooldown ticks for health regeneration.
     * @param constitution The player's Constitution attribute points.
     * @param regenSpeedBonusTicks Bonus ticks to reduce cooldown.
     * @param inCombat True if the player is currently in combat.
     * @param lastCombatExitTick The game tick when the player last exited combat.
     * @param currentTick The current game tick.
     * @return The effective health regeneration cooldown in ticks.
     */
    public static int calculateHealthRegenCooldown(int constitution, float regenSpeedBonusTicks, boolean inCombat, long lastCombatExitTick, long currentTick) {
        int baseRegenPulseCooldownTicks = RegenDataConfig.getInstance().getBaseRegenPulseCooldownTicks();
        int healthDelayAfterCombatTicks = RegenDataConfig.getInstance().getHealthDelayAfterCombatTicks();

        if (inCombat || (currentTick - lastCombatExitTick < healthDelayAfterCombatTicks)) {
        }
        return baseRegenPulseCooldownTicks;
    }

    /**
     * Calculates the amount of mana regenerated per tick.
     * @param intelligence The player's Intelligence attribute points.
     * @param inCombat True if the player is currently in combat.
     * @return The amount of mana regenerated per tick.
     */
    public static float calculateManaRegenPerTick(int intelligence, boolean inCombat) {
        float manaRegenOutOfCombatBase = RegenDataConfig.getInstance().getManaRegenOutOfCombatBase();
        float manaRegenInCombatBase = RegenDataConfig.getInstance().getManaRegenInCombatBase();
        float manaRegenBonusPerInt = RegenDataConfig.getInstance().getManaRegenBonusPerInt();
        int baseRegenPulseCooldownTicks = RegenDataConfig.getInstance().getBaseRegenPulseCooldownTicks();

        float baseRegen = inCombat ? manaRegenInCombatBase : manaRegenOutOfCombatBase;
        return baseRegen + ((intelligence * manaRegenBonusPerInt) / baseRegenPulseCooldownTicks);
    }

    /**
     * Calculates the amount of vigor regenerated per tick.
     * @param dexterity The player's Dexterity attribute points.
     * @param inCombat True if the player is currently in combat.
     * @return The amount of vigor regenerated per tick.
     */
    public static float calculateVigorRegenPerTick(int dexterity, boolean inCombat) {
        float vigorRegenOutOfCombatBase = RegenDataConfig.getInstance().getVigorRegenOutOfCombatBase();
        float vigorRegenInCombatBase = RegenDataConfig.getInstance().getVigorRegenInCombatBase();
        float vigorRegenBonusPerDex = RegenDataConfig.getInstance().getVigorRegenBonusPerDex();
        int baseRegenPulseCooldownTicks = RegenDataConfig.getInstance().getBaseRegenPulseCooldownTicks();

        float baseRegen = inCombat ? vigorRegenInCombatBase : vigorRegenOutOfCombatBase;
        return baseRegen + ((dexterity * vigorRegenBonusPerDex) / baseRegenPulseCooldownTicks);
    }

    /**
     * Applies chaotic transformation effects to a base stat value.
     * @param baseStatValue The stat value before chaotic modification.
     * @param randomChangeMin The minimum percentage change.
     * @param randomChangeMax The maximum percentage change.
     * @return The modified stat value after applying a random percentage change.
     */
    public static float applyChaoticTransformationToStat(float baseStatValue, float randomChangeMin, float randomChangeMax) {
        float randomPercentage = randomChangeMin + (randomChangeMax - randomChangeMin) * RANDOM.nextFloat();
        return baseStatValue * (1.0f + randomPercentage);
    }
}