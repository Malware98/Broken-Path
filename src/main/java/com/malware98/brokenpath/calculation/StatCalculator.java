package com.malware98.brokenpath.calculation;

import com.malware98.brokenpath.data.ModConfigs;
import com.malware98.brokenpath.data.ModConfigs.AffinityLimit;
import com.malware98.brokenpath.data.ModConfigs.ProtectionConfig;
import com.malware98.brokenpath.data.ModConfigs.StatConfig;

/*
 * Clase utilitaria para calcular las estadísticas finales del jugador
 * basándose en atributos, configuración del mod, raza y clase.
 * Incluye cálculos para salud, maná, vigor, protección y regeneración.
 */
public class StatCalculator {

    // CÁLCULOS PARA ESTADÍSTICAS FINALES

    // Calcula la salud máxima basada en la Constitución, raza y clase.
    public static float calculateHealth(String raceName, String className, int conPoints) {
        ModConfigs configs = ModConfigs.getInstance();
        StatConfig healthConfig = configs.getRaceStatConfig(raceName, "HEALTH");

        if (healthConfig == null) {
            return 0.0f;
        }

        float calculatedHealth = healthConfig.baseInitialValue;
        calculatedHealth += conPoints * healthConfig.conMultiplierPerPoint;
        AffinityLimit activeAffinity = healthConfig.affinityLimits.get("BASE");

        boolean classBoostsAttribute = configs.doesClassBoostAttribute(className, "CONSTITUTION");
        boolean hasRacialAffinity = configs.isClassAffinToStat(raceName, className, "HEALTH");

        if (hasRacialAffinity) {
            activeAffinity = healthConfig.affinityLimits.get("RACIAL_AFFINITY");
        } else if (classBoostsAttribute) {
            activeAffinity = healthConfig.affinityLimits.get("CLASS_BONUS");
        }

        calculatedHealth *= activeAffinity.multiplier;
        calculatedHealth = Math.min(calculatedHealth, activeAffinity.limit);

        return calculatedHealth;
    }

    // Calcula el maná máximo basado en la Inteligencia, raza y clase.
    public static float calculateMana(String raceName, String className, int intPoints) {
        ModConfigs configs = ModConfigs.getInstance();
        StatConfig manaConfig = configs.getRaceStatConfig(raceName, "MANA");

        if (manaConfig == null) {
            return 0.0f;
        }

        float calculatedMana = manaConfig.baseInitialValue;
        calculatedMana += intPoints * manaConfig.intMultiplierPerPoint;

        AffinityLimit activeAffinity = manaConfig.affinityLimits.get("BASE");
        boolean classBoostsAttribute = configs.doesClassBoostAttribute(className, "INTELLIGENCE");
        boolean hasRacialAffinity = configs.isClassAffinToStat(raceName, className, "MANA");

        if (hasRacialAffinity) {
            activeAffinity = manaConfig.affinityLimits.get("RACIAL_AFFINITY");
        } else if (classBoostsAttribute) {
            activeAffinity = manaConfig.affinityLimits.get("CLASS_BONUS");
        }

        calculatedMana *= activeAffinity.multiplier;
        calculatedMana = Math.min(calculatedMana, activeAffinity.limit);

        return calculatedMana;
    }

    // Calcula el vigor máximo basado en la Destreza, raza y clase.
    public static float calculateVigor(String raceName, String className, int dexPoints) {
        ModConfigs configs = ModConfigs.getInstance();
        StatConfig vigorConfig = configs.getRaceStatConfig(raceName, "VIGOR");

        if (vigorConfig == null) {
            return 0.0f;
        }

        float calculatedVigor = vigorConfig.baseInitialValue;
        calculatedVigor += dexPoints * vigorConfig.dexMultiplierPerPoint;

        AffinityLimit activeAffinity = vigorConfig.affinityLimits.get("BASE");
        boolean classBoostsAttribute = configs.doesClassBoostAttribute(className, "DEXTERITY");
        boolean hasRacialAffinity = configs.isClassAffinToStat(raceName, className, "VIGOR");

        if (hasRacialAffinity) {
            activeAffinity = vigorConfig.affinityLimits.get("RACIAL_AFFINITY");
        } else if (classBoostsAttribute) {
            activeAffinity = vigorConfig.affinityLimits.get("CLASS_BONUS");
        }

        calculatedVigor *= activeAffinity.multiplier;
        calculatedVigor = Math.min(calculatedVigor, activeAffinity.limit);

        return calculatedVigor;
    }

    // Calcula la protección basada en la Fuerza, raza y clase.
    public static float calculateProtectionFromSTR(String raceName, String className, int strPoints) {
        ModConfigs configs = ModConfigs.getInstance();
        ProtectionConfig protectionConfig = configs.getRaceProtectionConfig(raceName);

        if (protectionConfig == null) {
            return 0.0f;
        }

        float strBasedProtection = strPoints * protectionConfig.strEfficacyMultiplierPerPoint;

        AffinityLimit activeAffinity = protectionConfig.affinityLimits.get("BASE");
        boolean classBoostsAttribute = configs.doesClassBoostAttribute(className, "STRENGTH");
        boolean hasRacialAffinity = configs.isClassAffinToStat(raceName, className, "PROTECTION");

        if (hasRacialAffinity) {
            activeAffinity = protectionConfig.affinityLimits.get("RACIAL_AFFINITY");
        } else if (classBoostsAttribute) {
            activeAffinity = protectionConfig.affinityLimits.get("CLASS_BONUS");
        }

        strBasedProtection *= activeAffinity.multiplier;
        strBasedProtection = Math.min(strBasedProtection, activeAffinity.limit);

        return strBasedProtection;
    }

    // Calcula la protección innata basada en el nivel del jugador y la raza.
    public static float calculateInnateProtection(String raceName, int currentLevel) {
        ModConfigs configs = ModConfigs.getInstance();
        ModConfigs.ProtectionInnateConfig innateConfig = configs.getRaceProtectionInnateConfig(raceName);

        if (innateConfig == null) {
            return 0.0f;
        }

        float innateProtection = innateConfig.baseValue;
        innateProtection += innateConfig.perLevelIncrease * (currentLevel - 1);
        return innateProtection;
    }

    // CÁLCULOS DE REGENERACIÓN

    // Calcula el tiempo de reutilización (cooldown) para la regeneración de salud.
    public static int calculateHealthRegenCooldown(int constitution, float regenSpeedBonusTicks, boolean inCombat, long lastCombatExitTick, long currentTick) {
        ModConfigs configs = ModConfigs.getInstance();

        // Si el jugador está en combate o el delay post-combate aún no ha terminado, la regeneración es extremadamente lenta (cooldown muy alto)
        if (inCombat || (currentTick - lastCombatExitTick < configs.getHealthDelayAfterCombatTicks())) {
            // Nota: Aquí no hay ninguna acción dentro del bloque if, lo que significa que el cálculo continuará con los valores base si las condiciones se cumplen, lo que se espera.
        }
        float conBonus = constitution * configs.getHealthRegenBonusPerConTicks();
        int effectiveCooldown = (int) (configs.getHealthRegenCooldownTicksBase() - regenSpeedBonusTicks - conBonus);
        return Math.max(effectiveCooldown, configs.getHealthMinEffectiveCooldownTicks());
    }

    // Calcula la cantidad de maná que se regenera por tick.
    public static float calculateManaRegenPerTick(int intelligence, boolean inCombat) {
        ModConfigs configs = ModConfigs.getInstance();
        float baseRegen = inCombat ? configs.getManaRegenInCombatBase() : configs.getManaRegenOutOfCombatBase();
        return baseRegen + (intelligence * configs.getManaRegenBonusPerInt());
    }

    // Calcula la cantidad de vigor que se regenera por tick.
    public static float calculateVigorRegenPerTick(int dexterity, boolean inCombat) {
        ModConfigs configs = ModConfigs.getInstance();
        float baseRegen = inCombat ? configs.getVigorRegenInCombatBase() : configs.getVigorRegenOutOfCombatBase();
        return baseRegen + (dexterity * configs.getVigorRegenBonusPerDex());
    }
}