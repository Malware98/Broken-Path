package com.malware98.brokenpath.calculation;

import com.malware98.brokenpath.capabilities.PlayerStats;
import com.malware98.brokenpath.data.config.*;

import java.util.Random;

/**
 * Utility class for calculating the player's final statistics
 * based on attributes, mod configuration, race, and class.
 */
public class StatCalculator {

    // --- Random instance for chaotic transformations ---
    public static final Random RANDOM = new Random();

    /**
     * Calculates a generic player statistic (e.g., Health, Mana, Vigor, etc.)
     * based on race, class, specialization, and an associated attribute.
     * Protection is handled separately as it's armor-based.
     * @param playerStats The PlayerStats instance.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param attributePoints The player's attribute points.
     * @param attributeMultiplier The multiplier applied per attribute point.
     * @param statName The name of the statistic being calculated.
     * @return The calculated value for the specified generic statistic.
     */
    private static float calculateGenericStat(PlayerStats playerStats, String raceName, String className, String specializationName,
                                              int attributePoints, float attributeMultiplier, String statName) {

        float calculatedStat = 0.0f;
        RaceDataConfig.RaceSettings raceSettings = RaceDataConfig.getInstance().getRaceSettings(raceName);
        ClassDataConfig.ClassSettings classSettings = ClassDataConfig.getInstance().getClassSettings(className);
        SpecializationDataConfig.SpecializationSettings specializationSettings = SpecializationDataConfig.getInstance().getSpecializationSettings(specializationName);

        // --- Section: Get Base Racial Stat using enhanced switch ---
        calculatedStat = switch (statName.toUpperCase()) {
            case "HEALTH" -> raceSettings.getHealth();
            case "MANA" -> raceSettings.getMana();
            case "VIGOR" -> raceSettings.getVigor();
            default -> 0.0f;
        };

        // Apply attribute multiplier.
        calculatedStat += attributePoints * attributeMultiplier;

        // Apply Class Fixed Bonus.
        if (statName.equalsIgnoreCase(classSettings.getClassBonusStatName())) {
            calculatedStat += classSettings.getClassBonusStatValue();
        }

        // Apply Specialization Fixed Bonus.
        if (statName.equalsIgnoreCase(specializationSettings.getStatBonusName())) {
            if (!statName.equalsIgnoreCase(classSettings.getAffinityStatName())) {
                calculatedStat += specializationSettings.getStatBonusValue();
            }
        }

        // Apply Affinity Tier Bonus (from Class selection).
        if (statName.equalsIgnoreCase(classSettings.getAffinityStatName())) {
            String affinityTier = AffinityMappingConfig.getInstance().getAffinityTier(raceName, className);
            float affinityBonus = switch (affinityTier) {
                case "IDEAL" -> AffinityTierDataConfig.getInstance().getIdealTierBonusClass();
                case "EFFICIENT" -> AffinityTierDataConfig.getInstance().getEfficientTierBonusClass();
                case "ACCEPTABLE" -> AffinityTierDataConfig.getInstance().getAcceptableTierBonusClass();
                case "DEFICIENT" -> AffinityTierDataConfig.getInstance().getDeficientTierBonusClass();
                default -> 0.0f;
            };
            calculatedStat += affinityBonus;
        }

        // Apply Affinity Tier Bonus (from Specialization selection).
        if (statName.equalsIgnoreCase(classSettings.getAffinityStatName())) {
            if (!specializationName.isEmpty() && !specializationName.equalsIgnoreCase("NO_SPECIALIZATION")) {
                String affinityTier = AffinityMappingConfig.getInstance().getAffinityTier(raceName, className);
                float affinityBonus = switch (affinityTier) {
                    case "IDEAL" -> AffinityTierDataConfig.getInstance().getIdealTierBonusSpecialization();
                    case "EFFICIENT" -> AffinityTierDataConfig.getInstance().getEfficientTierBonusSpecialization();
                    case "ACCEPTABLE" -> AffinityTierDataConfig.getInstance().getAcceptableTierBonusSpecialization();
                    case "DEFICIENT" -> AffinityTierDataConfig.getInstance().getDeficientTierBonusSpecialization();
                    default -> 0.0f;
                };
                calculatedStat += affinityBonus;
            }
        }

        // Store the value before chaotic transformation to calculate the rounded change.
        float statBeforeChaoticTransformation = calculatedStat;

        if ("CHIMERA".equalsIgnoreCase(raceName) && playerStats.isInChaoticTransformation()) {
            float adjustmentPercentage = playerStats.getChaoticStatAdjustment(statName);
            // Calculate the raw change amount
            float rawChangeAmount = statBeforeChaoticTransformation * adjustmentPercentage;
            // Round this change amount to the nearest whole number
            int roundedChangeAmount = Math.round(rawChangeAmount);
            // Apply the rounded change amount to the stat.
            calculatedStat = statBeforeChaoticTransformation + roundedChangeAmount;
        }

        // Round the final calculated stat to a whole number, as per previous requirement.
        return (float) Math.round(calculatedStat);
    }

    // --- Core Stat Calculations ---
    /**
     * Calculates the player's maximum health.
     * @param playerStats The PlayerStats instance.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param conPoints The player's Constitution attribute points.
     * @return The calculated maximum health.
     */
    public static float calculateHealth(PlayerStats playerStats, String raceName, String className, String specializationName, int conPoints) {
        float multiplier = AttributeConfig.getInstance().getConMultiplier();
        return calculateGenericStat(playerStats, raceName, className, specializationName,
                conPoints, multiplier, "HEALTH");
    }

    /**
     * Calculates the player's maximum mana.
     * @param playerStats The PlayerStats instance.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param intPoints The player's Intelligence attribute points.
     * @return The calculated maximum mana.
     */
    public static float calculateMana(PlayerStats playerStats, String raceName, String className, String specializationName, int intPoints) {
        float multiplier = AttributeConfig.getInstance().getIntMultiplier();
        return calculateGenericStat(playerStats, raceName, className, specializationName,
                intPoints, multiplier, "MANA");
    }

    /**
     * Calculates the player's maximum vigor.
     * @param playerStats The PlayerStats instance.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param dexPoints The player's Dexterity attribute points.
     * @return The calculated maximum vigor.
     */
    public static float calculateVigor(PlayerStats playerStats, String raceName, String className, String specializationName, int dexPoints) {
        float multiplier = AttributeConfig.getInstance().getDexMultiplier();
        return calculateGenericStat(playerStats, raceName, className, specializationName,
                dexPoints, multiplier, "VIGOR");
    }


    /**
     * Calculates innate protection based on player level and race.
     * @param playerStats The PlayerStats instance.
     * @param raceName The player's race name.
     * @param currentLevel The player's current level.
     * @return The calculated innate protection value.
     */
    public static float calculateInnateProtection(PlayerStats playerStats, String raceName, int currentLevel) {
        float innateProtectionPerLevelIncrease = AttributeConfig.getInstance().getInnateProtectionPerLevelIncrease();
        RaceDataConfig.RaceSettings raceSettings = RaceDataConfig.getInstance().getRaceSettings(raceName);
        float innateBaseValue = raceSettings.getProtectionInnate();

        if (innateBaseValue > 0) {
            innateBaseValue += innateProtectionPerLevelIncrease * (currentLevel - 1);
        }

        if ("CHIMERA".equalsIgnoreCase(raceName) && playerStats.isInChaoticTransformation()) {
            float adjustmentPercentage = playerStats.getChaoticStatAdjustment("INNATE_PROTECTION");
            innateBaseValue *= (1.0f + adjustmentPercentage);
        }

        return (float) Math.round(innateBaseValue);
    }

    /**
     * Calculates the base Protection value derived from Race, Class, and Specialization.
     * This value contributes to the overall maxProtection (Armor-based).
     * @param playerStats The PlayerStats instance.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @return The calculated base protection value from race/class/spec.
     */
    public static float calculateBaseProtectionFromRaceClass(PlayerStats playerStats, String raceName, String className, String specializationName) {
        float baseProtection = 0.0f;
        // RaceDataConfig.RaceSettings raceSettings = RaceDataConfig.getInstance().getRaceSettings(raceName); // No longer needed for 'protection' field
        ClassDataConfig.ClassSettings classSettings = ClassDataConfig.getInstance().getClassSettings(className);
        SpecializationDataConfig.SpecializationSettings specializationSettings = SpecializationDataConfig.getInstance().getSpecializationSettings(specializationName);

        // --- Removed: Add base protection from RaceDataConfig (as 'protection' field no longer exists there) ---

        // Add Class Fixed Bonus if it's for "PROTECTION"
        if ("PROTECTION".equalsIgnoreCase(classSettings.getClassBonusStatName())) {
            baseProtection += classSettings.getClassBonusStatValue();
        }

        // Add Specialization Fixed Bonus if it's for "PROTECTION" and not already covered by affinity
        if ("PROTECTION".equalsIgnoreCase(specializationSettings.getStatBonusName())) {
            // Avoid double-dipping if specialization bonus is also the affinity stat, but here protection is not an affinity.
            baseProtection += specializationSettings.getStatBonusValue();
        }

        // Apply Affinity Tier Bonus (from Class selection) if "PROTECTION" is the affinity stat
        if ("PROTECTION".equalsIgnoreCase(classSettings.getAffinityStatName())) {
            String affinityTier = AffinityMappingConfig.getInstance().getAffinityTier(raceName, className);
            float affinityBonus = switch (affinityTier) {
                case "IDEAL" -> AffinityTierDataConfig.getInstance().getIdealTierBonusClass();
                case "EFFICIENT" -> AffinityTierDataConfig.getInstance().getEfficientTierBonusClass();
                case "ACCEPTABLE" -> AffinityTierDataConfig.getInstance().getAcceptableTierBonusClass();
                case "DEFICIENT" -> AffinityTierDataConfig.getInstance().getDeficientTierBonusClass();
                default -> 0.0f;
            };
            baseProtection += affinityBonus;
        }

        // Apply Affinity Tier Bonus (from Specialization selection) if "PROTECTION" is the affinity stat
        if ("PROTECTION".equalsIgnoreCase(classSettings.getAffinityStatName())) {
            if (!specializationName.isEmpty() && !specializationName.equalsIgnoreCase("NO_SPECIALIZATION")) {
                String affinityTier = AffinityMappingConfig.getInstance().getAffinityTier(raceName, className);
                float affinityBonus = switch (affinityTier) {
                    case "IDEAL" -> AffinityTierDataConfig.getInstance().getIdealTierBonusSpecialization();
                    case "EFFICIENT" -> AffinityTierDataConfig.getInstance().getEfficientTierBonusSpecialization();
                    case "ACCEPTABLE" -> AffinityTierDataConfig.getInstance().getAcceptableTierBonusSpecialization();
                    case "DEFICIENT" -> AffinityTierDataConfig.getInstance().getDeficientTierBonusSpecialization();
                    default -> 0.0f;
                };
                baseProtection += affinityBonus;
            }
        }

        // Apply chaotic transformation if player is Chimera and it's active
        if ("CHIMERA".equalsIgnoreCase(raceName) && playerStats.isInChaoticTransformation()) {
            float adjustmentPercentage = playerStats.getChaoticStatAdjustment("PROTECTION");
            baseProtection *= (1.0f + adjustmentPercentage);
        }

        return (float) Math.round(baseProtection);
    }

    // --- Regeneration Calculations ---
    /**
     * Calculates the amount of mana regenerated per tick.
     * @param intelligence The player's Intelligence attribute points.
     * @param inCombat True if the player is currently in combat.
     * @return The amount of mana regenerated per tick.
     */
    public static float calculateManaRegenPerTick(int intelligence, boolean inCombat) {
        float manaRegenOutOfCombatBase = RegenDataConfig.getInstance().getManaRegenOutOfCombatBase();
        float manaRegenInCombatBase = RegenDataConfig.getInstance().getManaRegenInCombatBase();
        float manaRegenBonusPerInt = RegenDataConfig.getInstance().getManaRegenBonusPerInt();
        int baseRegenPulseCooldownTicks = RegenDataConfig.getInstance().getBaseRegenPulseCooldownTicks();

        float baseRegen = inCombat ? manaRegenInCombatBase : manaRegenOutOfCombatBase;
        return baseRegen + ((intelligence * manaRegenBonusPerInt) / baseRegenPulseCooldownTicks);
    }

    /**
     * Calculates the amount of vigor regenerated per tick.
     * @param dexterity The player's Dexterity attribute points.
     * @param inCombat True if the player is currently in combat.
     * @return The amount of vigor regenerated per tick.
     */
    public static float calculateVigorRegenPerTick(int dexterity, boolean inCombat) {
        float vigorRegenOutOfCombatBase = RegenDataConfig.getInstance().getVigorRegenOutOfCombatBase();
        float vigorRegenInCombatBase = RegenDataConfig.getInstance().getVigorRegenInCombatBase();
        float vigorRegenBonusPerDex = RegenDataConfig.getInstance().getVigorRegenBonusPerDex();
        int baseRegenPulseCooldownTicks = RegenDataConfig.getInstance().getBaseRegenPulseCooldownTicks();

        float baseRegen = inCombat ? vigorRegenInCombatBase : vigorRegenOutOfCombatBase;
        return baseRegen + ((dexterity * vigorRegenBonusPerDex) / baseRegenPulseCooldownTicks);
    }

    /**
     * Calculates the amount of Protection regenerated per tick.
     * This mirrors the health regeneration logic but uses its own config values and scales with CON.
     * Protection does not regenerate while in combat.
     * @param constitution The player's Constitution attribute points.
     * @param inCombat True if the player is currently in combat.
     * @return The amount of Protection regenerated per tick.
     */
    public static float calculateProtectionRegenPerTick(int constitution, boolean inCombat) {
        RegenDataConfig regenConfigs = RegenDataConfig.getInstance();
        int baseRegenPulseCooldownTicks = regenConfigs.getBaseRegenPulseCooldownTicks();
        float protectionAmountToHealPerPulse = regenConfigs.getProtectionAmountPerPulse(); // Specific config for Protection
        float protectionRegenBonusPerCon = regenConfigs.getProtectionRegenBonusPerCon(); // Specific config for Protection CON bonus

        // Protection only regenerates out of combat. If in combat, base regen is 0.
        float baseRegen = inCombat ? 0.0f : protectionAmountToHealPerPulse;

        // Apply CON bonus. The bonus is per CON point per tick, divided by the cooldown to scale it per pulse.
        return baseRegen + ((constitution * protectionRegenBonusPerCon) / baseRegenPulseCooldownTicks);
    }

    /**
     * Applies chaotic transformation effects to a base stat value.
     * @param baseStatValue The stat value before chaotic modification.
     * @param randomChangeMin The minimum percentage change.
     * @param randomChangeMax The maximum percentage change.
     * @return The modified stat value after applying a random percentage change.
     */
    public static float applyChaoticTransformationToStat(float baseStatValue, float randomChangeMin, float randomChangeMax) {
        float randomPercentage = randomChangeMin + (randomChangeMax - randomChangeMin) * RANDOM.nextFloat();
        return baseStatValue * (1.0f + randomPercentage);
    }
}