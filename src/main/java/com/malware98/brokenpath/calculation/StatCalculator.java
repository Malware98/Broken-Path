package com.malware98.brokenpath.calculation;

import com.malware98.brokenpath.data.ModConfigs;
import com.malware98.brokenpath.data.ModConfigs.StatConfigBase;

import java.util.function.Function;

/**
 * Utility class for calculating the player's final statistics
 * based on attributes, mod configuration, race, and class.
 * Includes calculations for health, mana, vigor, protection, and regeneration.
 */
public class StatCalculator {

    /**
     * Calculates a generic player statistic (e.g., Health, Mana, Vigor, Protection)
     * based on race, class, specialization, and an associated attribute.
     * This method unifies the calculation logic for various stats that share similar
     * contributing factors.
     *
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param attributePoints The player's attribute points (e.g., Constitution for Health).
     * @param attributeMultiplier The multiplier applied per attribute point for this specific stat.
     * @param statName The name of the statistic being calculated (e.g., "HEALTH", "MANA").
     * @param getRaceStatConfig A function that retrieves the base configuration for the given stat
     * and race. This allows for flexible retrieval of race-specific
     * initial values for different stats.
     * @return The calculated value for the specified generic statistic.
     */
    private static float calculateGenericStat(String raceName, String className, String specializationName,
                                              int attributePoints, float attributeMultiplier, String statName,
                                              Function<String, StatConfigBase> getRaceStatConfig) {

        ModConfigs configs = ModConfigs.getInstance();
        float calculatedStat = 0.0f;

        // Simplified base initial value retrieval
        StatConfigBase genericStatConfig = getRaceStatConfig.apply(raceName);
        if (genericStatConfig != null) {
            calculatedStat = genericStatConfig.baseInitialValue;
        }

        // Apply attribute multiplier (global)
        calculatedStat += attributePoints * attributeMultiplier;

        // Apply racial affinity multiplier if applicable
        if (configs.isClassAffinToStat(raceName, className, statName)) {
            calculatedStat *= configs.getRacialAffinityMultiplier();
        }

        // Apply flat class bonus
        calculatedStat += configs.getClassStatBonus(className, statName);

        // Apply flat specialization bonus
        calculatedStat += configs.getSpecializationStatBonus(specializationName, statName);

        return calculatedStat;
    }

    // --- Core Stat Calculations ---

    /**
     * Calculates the player's maximum **health** based on their Constitution attribute,
     * race, class, and specialization.
     * It uses the generic calculation logic, specifically configured for health.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param conPoints The player's Constitution attribute points.
     * @return The calculated maximum health.
     */
    public static float calculateHealth(String raceName, String className, String specializationName, int conPoints) {
        ModConfigs configs = ModConfigs.getInstance();
        return calculateGenericStat(raceName, className, specializationName,
                conPoints, configs.getConMultiplier(), "HEALTH",
                s -> configs.getRaceStatConfig(s, "HEALTH"));
    }

    /**
     * Calculates the player's maximum **mana** based on their Intelligence attribute,
     * race, class, and specialization.
     * It uses the generic calculation logic, specifically configured for mana.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param intPoints The player's Intelligence attribute points.
     * @return The calculated maximum mana.
     */
    public static float calculateMana(String raceName, String className, String specializationName, int intPoints) {
        ModConfigs configs = ModConfigs.getInstance();
        return calculateGenericStat(raceName, className, specializationName,
                intPoints, configs.getIntMultiplier(), "MANA",
                s -> configs.getRaceStatConfig(s, "MANA"));
    }

    /**
     * Calculates the player's maximum **vigor** based on their Dexterity attribute,
     * race, class, and specialization.
     * It uses the generic calculation logic, specifically configured for vigor.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param dexPoints The player's Dexterity attribute points.
     * @return The calculated maximum vigor.
     */
    public static float calculateVigor(String raceName, String className, String specializationName, int dexPoints) {
        ModConfigs configs = ModConfigs.getInstance();
        return calculateGenericStat(raceName, className, specializationName,
                dexPoints, configs.getDexMultiplier(), "VIGOR",
                s -> configs.getRaceStatConfig(s, "VIGOR"));
    }

    /**
     * Calculates the player's **protection value** from Strength, based on their Strength attribute,
     * race, class, and specialization. This value represents the amount of damage that can be absorbed.
     * It uses the generic calculation logic, specifically configured for protection.
     * @param raceName The name of the player's race.
     * @param className The name of the player's class.
     * @param specializationName The player's specialization name.
     * @param strPoints The player's Strength attribute points.
     * @return The calculated protection value.
     */
    public static float calculateProtectionFromSTR(String raceName, String className, String specializationName, int strPoints) {
        ModConfigs configs = ModConfigs.getInstance();
        return calculateGenericStat(raceName, className, specializationName,
                strPoints, configs.getStrMultiplier(), "PROTECTION",
                s -> configs.getRaceStatConfig(s, "PROTECTION")); // Pass the unified getter, now for PROTECTION
    }

    /**
     * Calculates innate protection based on player level and race.
     * Innate protection is a passive damage reduction that scales with level.
     * @param raceName The name of the player's race.
     * @param currentLevel The player's current level.
     * @return The calculated innate protection value.
     */
    public static float calculateInnateProtection(String raceName, int currentLevel) {
        ModConfigs configs = ModConfigs.getInstance();
        ModConfigs.ProtectionInnateConfig innateConfig = configs.getRaceProtectionInnateConfig(raceName);

        if (innateConfig == null) {
            return 0.0f;
        }

        float innateProtection = innateConfig.baseValue;

        // Only apply per-level increase if the base value is greater than 0.
        if (innateProtection > 0) {
            innateProtection += configs.getInnateProtectionPerLevelIncrease() * (currentLevel - 1);
        }
        return (float) Math.round(innateProtection);
    }

    // --- Regeneration Calculations ---

    /**
     * Calculates the cooldown ticks for health regeneration.
     * A lower cooldown means faster regeneration.
     * The cooldown is primarily determined by configuration, as Constitution now scales the
     * amount of healing rather than its frequency.
     *
     * @param constitution The player's Constitution attribute points (used for healing amount, not cooldown here).
     * @param regenSpeedBonusTicks Bonus ticks to reduce cooldown (e.g., from effects or gear).
     * @param inCombat True if the player is currently in combat.
     * @param lastCombatExitTick The game tick when the player last exited combat.
     * @param currentTick The current game tick.
     * @return The effective health regeneration cooldown in ticks.
     */
    public static int calculateHealthRegenCooldown(int constitution, float regenSpeedBonusTicks, boolean inCombat, long lastCombatExitTick, long currentTick) {
        ModConfigs configs = ModConfigs.getInstance();

        // The combat delay check (inCombat / currentTick - lastCombatExitTick) is relevant for 'canRegenHealth' in PlayerStatEventHandler,
        // but it doesn't modify the effectiveCooldown here directly.
        // No change needed for this 'if' block itself.
        if (inCombat || (currentTick - lastCombatExitTick < configs.getHealthDelayAfterCombatTicks())) {
            // Logic handled by canRegenHealth condition in PlayerStatEventHandler.
        }

        // Health regeneration cooldown is now fixed based on the unified base cooldown.
        // CONSTITUTION will scale the AMOUNT of healing (handled in PlayerStatEventHandler), not the frequency.
        int effectiveCooldown = configs.getBaseRegenPulseCooldownTicks(); // Use the unified base cooldown

        // Ensure cooldown does not go below the minimum configured value to prevent excessively fast regen.
        return Math.max(effectiveCooldown, configs.getHealthMinEffectiveCooldownTicks());
    }

    /**
     * Calculates the amount of mana regenerated per tick.
     * Regeneration rate differs between in-combat and out-of-combat states,
     * and is influenced by Intelligence.
     * @param intelligence The player's Intelligence attribute points.
     * @param inCombat True if the player is currently in combat.
     * @return The amount of mana regenerated per tick.
     */
    public static float calculateManaRegenPerTick(int intelligence, boolean inCombat) {
        ModConfigs configs = ModConfigs.getInstance();
        // Use different base regeneration rates depending on combat status.
        float baseRegen = inCombat ? configs.getManaRegenInCombatBase() : configs.getManaRegenOutOfCombatBase();
        return baseRegen + (intelligence * configs.getManaRegenBonusPerInt());
    }

    /**
     * Calculates the amount of vigor regenerated per tick.
     * Regeneration rate differs between in-combat and out-of-combat states,
     * and is influenced by Dexterity.
     * @param dexterity The player's Dexterity attribute points.
     * @param inCombat True if the player is currently in combat.
     * @return The amount of vigor regenerated per tick.
     */
    public static float calculateVigorRegenPerTick(int dexterity, boolean inCombat) {
        ModConfigs configs = ModConfigs.getInstance();
        // Use different base regeneration rates depending on combat status.
        float baseRegen = inCombat ? configs.getVigorRegenInCombatBase() : configs.getVigorRegenOutOfCombatBase();
        return baseRegen + (dexterity * configs.getVigorRegenBonusPerDex());
    }
}