// StatCalculator.java
package com.malware98.brokenpath.calculation;

import com.malware98.brokenpath.BrokenPath;
import com.malware98.brokenpath.capabilities.PlayerStats;
import com.malware98.brokenpath.data.config.*;

import java.util.Random;

/**
 * // Utility class for calculating the player's final statistics
 * // based on attributes, mod configuration, race, and class.
 * // Includes calculations for health, mana, vigor, protection, and regeneration.
 */
public class StatCalculator {

    // // --- Random instance for chaotic transformations ---
    public static final Random RANDOM = new Random();


    /**
     * // Calculates a generic player statistic (e.g., Health, Mana, Vigor, Protection)
     * // based on race, class, specialization, and an associated attribute.
     * // This method unifies the calculation logic for various stats that share similar
     * // contributing factors.
     *
     * @param playerStats The PlayerStats instance, needed to check chaotic transformation state and adjustments.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param attributePoints The player's attribute points (e.g., Constitution for Health).
     * @param attributeMultiplier The multiplier applied per attribute point for this specific stat.
     * @param statName The name of the statistic being calculated (e.g., "HEALTH", "MANA").
     * @return The calculated value for the specified generic statistic.
     */
    private static float calculateGenericStat(PlayerStats playerStats, String raceName, String className, String specializationName,
                                              int attributePoints, float attributeMultiplier, String statName) {

        float calculatedStat = 0.0f;
        // Retrieve race, class, and specialization settings from their respective configs
        RaceDataConfig.RaceSettings raceSettings = RaceDataConfig.getInstance().getRaceSettings(raceName);
        ClassDataConfig.ClassSettings classSettings = ClassDataConfig.getInstance().getClassSettings(className);
        SpecializationDataConfig.SpecializationSettings specializationSettings = SpecializationDataConfig.getInstance().getSpecializationSettings(specializationName);

        BrokenPath.LOGGER.debug("StatCalc Debug: Calculating {} for Race: {}, Class: {}, Spec: {}. AttrPoints: {}. AttrMultiplier: {}.", statName, raceName, className, specializationName, attributePoints, attributeMultiplier);

        // // --- Get Base Racial Stat ---
        switch (statName.toUpperCase()) {
            case "HEALTH": calculatedStat = raceSettings.getHealth(); break;
            case "PROTECTION": calculatedStat = raceSettings.getProtection(); break;
            case "MANA": calculatedStat = raceSettings.getMana(); break;
            case "VIGOR": calculatedStat = raceSettings.getVigor(); break;
            default: calculatedStat = 0.0f; break; // Should not happen for primary stats
        }
        BrokenPath.LOGGER.debug("StatCalc Debug: Base {} for {}: {}.", statName, raceName, calculatedStat);


        // Apply attribute multiplier
        calculatedStat += attributePoints * attributeMultiplier;
        BrokenPath.LOGGER.debug("StatCalc Debug: After attributes {} ({} * {}): {}.", statName, attributePoints, attributeMultiplier, calculatedStat);


        // // --- Apply Class Fixed Bonus ---
        // If the current stat is the one that receives a fixed bonus from the class.
        if (statName.equalsIgnoreCase(classSettings.getClassBonusStatName())) {
            calculatedStat += classSettings.getClassBonusStatValue();
            BrokenPath.LOGGER.debug("StatCalc Debug: Applying Class Bonus {} to {}. New value: {}.", classSettings.getClassBonusStatValue(), statName, calculatedStat);
        }

        // // --- Apply Specialization Fixed Bonus ---
        // If the current stat is the one that receives a fixed bonus from the specialization.
        if (statName.equalsIgnoreCase(specializationSettings.getStatBonusName())) {
            // Rule: Specialization bonus cannot be the same as the stat boosted by Affinity (which is now direct)
            if (!statName.equalsIgnoreCase(classSettings.getAffinityStatName())) {
                calculatedStat += specializationSettings.getStatBonusValue();
                BrokenPath.LOGGER.debug("StatCalc Debug: Applying Specialization Bonus {} to {}. New value: {}.", specializationSettings.getStatBonusValue(), statName, calculatedStat);
            } else {
                BrokenPath.LOGGER.debug("StatCalc Debug: Specialization bonus for {} skipped as it conflicts with Affinity Stat {}.", statName, classSettings.getAffinityStatName());
            }
        }


        // // --- Apply Affinity Tier Bonus (from Class selection) ---
        // This bonus is applied when the stat name matches the class's designated affinity stat.
        // It's the first part of the total affinity bonus.
        if (statName.equalsIgnoreCase(classSettings.getAffinityStatName())) {
            // Retrieve affinity tier directly from AffinityMappingConfig
            String affinityTier = AffinityMappingConfig.getInstance().getAffinityTier(raceName, className);

            BrokenPath.LOGGER.debug("StatCalc Debug: Direct Affinity Tier determined for {} (Race: {}, Class: {}): {}.", statName, raceName, className, affinityTier);

            float affinityBonus = 0.0f;
            switch (affinityTier) {
                case "IDEAL": affinityBonus = AffinityTierDataConfig.getInstance().getIdealTierBonusClass(); break;
                case "EFFICIENT": affinityBonus = AffinityTierDataConfig.getInstance().getEfficientTierBonusClass(); break;
                case "ACCEPTABLE": affinityBonus = AffinityTierDataConfig.getInstance().getAcceptableTierBonusClass(); break;
                case "DEFICIENT": affinityBonus = AffinityTierDataConfig.getInstance().getDeficientTierBonusClass(); break;
                default: affinityBonus = 0.0f; break; // Fallback
            }
            calculatedStat += affinityBonus;
            BrokenPath.LOGGER.debug("StatCalc Debug: Applying Class Selection Affinity Bonus {} to {}. New value: {}.", affinityBonus, statName, calculatedStat);
        }

        // // --- Apply Affinity Tier Bonus (from Specialization selection) ---
        // This is the part of the affinity bonus applied on specialization selection.
        if (statName.equalsIgnoreCase(classSettings.getAffinityStatName())) { // Affinity stat is determined by class, so same check as above
            // This part is applied only if a specialization is actually chosen.
            if (!specializationName.isEmpty() && !specializationName.equalsIgnoreCase("NO_SPECIALIZATION")) {
                String affinityTier = AffinityMappingConfig.getInstance().getAffinityTier(raceName, className);
                float affinityBonus = 0.0f;
                switch (affinityTier) {
                    case "IDEAL": affinityBonus = AffinityTierDataConfig.getInstance().getIdealTierBonusSpecialization(); break;
                    case "EFFICIENT": affinityBonus = AffinityTierDataConfig.getInstance().getEfficientTierBonusSpecialization(); break;
                    case "ACCEPTABLE": affinityBonus = AffinityTierDataConfig.getInstance().getAcceptableTierBonusSpecialization(); break;
                    case "DEFICIENT": affinityBonus = AffinityTierDataConfig.getInstance().getDeficientTierBonusSpecialization(); break;
                    default: affinityBonus = 0.0f; break;
                }
                calculatedStat += affinityBonus;
                BrokenPath.LOGGER.debug("StatCalc Debug: Applying Specialization Selection Affinity Bonus {} to {}. New value: {}.", affinityBonus, statName, calculatedStat);
            }
        }


        // // --- Apply Chaotic Transformation Percentage (if active for Chimera) ---
        // This is applied AFTER all base stats, attribute scaling, and fixed bonuses.
        // It uses the PlayerStats instance to get the specific random adjustment for this stat.
        if ("CHIMERA".equalsIgnoreCase(raceName) && playerStats.isInChaoticTransformation()) {
            float adjustmentPercentage = playerStats.getChaoticStatAdjustment(statName);
            calculatedStat *= (1.0f + adjustmentPercentage);
            BrokenPath.LOGGER.debug("StatCalc Debug: Applying Chaotic Transformation adjustment {}% to {}. New value: {}.", adjustmentPercentage * 100, statName, calculatedStat);
        }

        BrokenPath.LOGGER.debug("StatCalc Debug: Final calculated {} for {}: {}.", statName, raceName, calculatedStat);
        return calculatedStat;
    }

    // // --- Helper to count matching tags between race and class ---
    // // NOTE: This method is now solely for debugging and informational logging.
    // // The affinity tier is determined directly by AffinityMappingConfig, not by tag count.
    // // This method can be removed entirely if tag-based logging is no longer desired.
    /*
    public static int countMatchingTags(List<String> raceTags, List<String> classTags) {
        if (raceTags == null || classTags == null || raceTags.isEmpty() || classTags.isEmpty()) {
            BrokenPath.LOGGER.debug("StatCalc Debug: One of the tag lists is null or empty. Race Tags: {}, Class Tags: {}.", raceTags, classTags);
            return 0;
        }

        int matchingCount = 0;

        // Converts class tags to a normalized set for efficient lookup
        Set<String> normalizedClassTags = classTags.stream()
                .map(tag -> tag.trim().toLowerCase()) // Normalizes class tags (trim whitespace, lowercase)
                .collect(Collectors.toSet());

        // Iterate through race tags and check if each exists in the normalized class tag set
        for (String raceTag : raceTags) {
            String normalizedRaceTag = raceTag.trim().toLowerCase(); // Normalizes race tag
            if (normalizedClassTags.contains(normalizedRaceTag)) {
                matchingCount++;
                BrokenPath.LOGGER.debug("Matching tag: '{}'", raceTag);
            } else {
                BrokenPath.LOGGER.debug("No match for tag: '{}'", raceTag);
            }
        }

        BrokenPath.LOGGER.debug("StatCalc Debug: Race Tags: {}, Class Tags: {}. Matching Tags Count: {}.",
                raceTags, classTags, matchingCount);

        return matchingCount;
    }
    */ // End of countMatchingTags method (commented out)


    // --- Core Stat Calculations (Updated to pass PlayerStats instance) ---

    /**
     * // Calculates the player's maximum **health** based on their Constitution attribute,
     * // race, class, and specialization.
     * // It uses the generic calculation logic, specifically configured for health.
     * @param playerStats The PlayerStats instance for transformation data.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param conPoints The player's Constitution attribute points.
     * @return The calculated maximum health.
     */
    public static float calculateHealth(PlayerStats playerStats, String raceName, String className, String specializationName, int conPoints) {
        float multiplier = AttributeConfig.getInstance().getConMultiplier();
        return calculateGenericStat(playerStats, raceName, className, specializationName,
                conPoints, multiplier, "HEALTH");
    }

    /**
     * // Calculates the player's maximum **mana** based on their Intelligence attribute,
     * // race, class, and specialization.
     * // It uses the generic calculation logic, specifically configured for mana.
     * @param playerStats The PlayerStats instance for transformation data.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param intPoints The player's Intelligence attribute points.
     * @return The calculated maximum mana.
     */
    public static float calculateMana(PlayerStats playerStats, String raceName, String className, String specializationName, int intPoints) {
        float multiplier = AttributeConfig.getInstance().getIntMultiplier();
        return calculateGenericStat(playerStats, raceName, className, specializationName,
                intPoints, multiplier, "MANA");
    }

    /**
     * // Calculates the player's maximum **vigor** based on their Dexterity attribute,
     * // race, class, and specialization.
     * // It uses the generic calculation logic, specifically configured for vigor.
     * @param playerStats The PlayerStats instance for transformation data.
     * @param raceName The player's race name.
     * @param className The player's class name.
     * @param specializationName The player's specialization name.
     * @param dexPoints The player's Dexterity attribute points.
     * @return The calculated maximum vigor.
     */
    public static float calculateVigor(PlayerStats playerStats, String raceName, String className, String specializationName, int dexPoints) {
        float multiplier = AttributeConfig.getInstance().getDexMultiplier();
        return calculateGenericStat(playerStats, raceName, className, specializationName,
                dexPoints, multiplier, "VIGOR");
    }

    /**
     * // Calculates the player's **protection value** from Strength, based on their Strength attribute,
     * // race, class, and specialization. This value represents the amount of damage that can be absorbed.
     * // It uses the generic calculation logic, specifically configured for protection.
     * @param playerStats The PlayerStats instance for transformation data.
     * @param raceName The name of the player's race.
     * @param className The name of the player's class.
     * @param specializationName The player's specialization name.
     * @param strPoints The player's Strength attribute points.
     * @return The calculated protection value.
     */
    public static float calculateProtectionFromSTR(PlayerStats playerStats, String raceName, String className, String specializationName, int strPoints) {
        float multiplier = AttributeConfig.getInstance().getStrMultiplier();
        return calculateGenericStat(playerStats, raceName, className, specializationName,
                strPoints, multiplier, "PROTECTION");
    }

    /**
     * // Calculates innate protection based on player level and race.
     * // Innate protection is a passive damage reduction that scales with level.
     * @param playerStats The PlayerStats instance for transformation data.
     * @param raceName The player's race name.
     * @param currentLevel The player's current level.
     * @return The calculated innate protection value.
     */
    public static float calculateInnateProtection(PlayerStats playerStats, String raceName, int currentLevel) {
        float innateProtectionPerLevelIncrease = AttributeConfig.getInstance().getInnateProtectionPerLevelIncrease();
        RaceDataConfig.RaceSettings raceSettings = RaceDataConfig.getInstance().getRaceSettings(raceName);
        float innateBaseValue = raceSettings.getProtectionInnate();

        // Only apply per-level increase if the base value is greater than 0.
        if (innateBaseValue > 0) {
            innateBaseValue += innateProtectionPerLevelIncrease * (currentLevel - 1);
        }

        // Apply chaotic transformation percentage for innate protection (if active for Chimera)
        if ("CHIMERA".equalsIgnoreCase(raceName) && playerStats.isInChaoticTransformation()) {
            float adjustmentPercentage = playerStats.getChaoticStatAdjustment("INNATE_PROTECTION");
            innateBaseValue *= (1.0f + adjustmentPercentage);
        }

        return (float) Math.round(innateBaseValue);
    }

    // --- Regeneration Calculations ---

    /**
     * // Calculates the cooldown ticks for health regeneration.
     * // A lower cooldown means faster regeneration.
     * // The cooldown is primarily determined by configuration, as Constitution now scales the
     * // amount of healing rather than its frequency.
     *
     * @param constitution The player's Constitution attribute points (used for healing amount, not cooldown here).
     * @param regenSpeedBonusTicks Bonus ticks to reduce cooldown (e.g., from effects or gear).
     * @param inCombat True if the player is currently in combat.
     * @param lastCombatExitTick The game tick when the player last exited combat.
     * @param currentTick The current game tick.
     * @return The effective health regeneration cooldown in ticks.
     */
    public static int calculateHealthRegenCooldown(int constitution, float regenSpeedBonusTicks, boolean inCombat, long lastCombatExitTick, long currentTick) {
        int baseRegenPulseCooldownTicks = RegenDataConfig.getInstance().getBaseRegenPulseCooldownTicks();
        int healthDelayAfterCombatTicks = RegenDataConfig.getInstance().getHealthDelayAfterCombatTicks();

        if (inCombat || (currentTick - lastCombatExitTick < healthDelayAfterCombatTicks)) {
            // Logic handled by canRegenHealth condition in PlayerStatEventHandler.
        }
        return baseRegenPulseCooldownTicks;
    }

    /**
     * // Calculates the amount of mana regenerated per tick.
     * // Regeneration rate differs between in-combat and out-of-combat states,
     * // and is influenced by Intelligence.
     * @param intelligence The player's Intelligence attribute points.
     * @param inCombat True if the player is currently in combat.
     * @return The amount of mana regenerated per tick.
     */
    public static float calculateManaRegenPerTick(int intelligence, boolean inCombat) {
        float manaRegenOutOfCombatBase = RegenDataConfig.getInstance().getManaRegenOutOfCombatBase();
        float manaRegenInCombatBase = RegenDataConfig.getInstance().getManaRegenInCombatBase();
        float manaRegenBonusPerInt = RegenDataConfig.getInstance().getManaRegenBonusPerInt();
        int baseRegenPulseCooldownTicks = RegenDataConfig.getInstance().getBaseRegenPulseCooldownTicks();

        // Use different base regeneration rates depending on combat status.
        float baseRegen = inCombat ? manaRegenInCombatBase : manaRegenOutOfCombatBase;
        return baseRegen + ((intelligence * manaRegenBonusPerInt) / baseRegenPulseCooldownTicks);
    }

    /**
     * // Calculates the amount of vigor regenerated per tick.
     * // Regeneration rate differs between in-combat and out-of-combat states,
     * // and is influenced by Dexterity.
     * @param dexterity The player's Dexterity attribute points.
     * @param inCombat True if the player is currently in combat.
     * @return The amount of vigor regenerated per tick.
     */
    public static float calculateVigorRegenPerTick(int dexterity, boolean inCombat) {
        float vigorRegenOutOfCombatBase = RegenDataConfig.getInstance().getVigorRegenOutOfCombatBase();
        float vigorRegenInCombatBase = RegenDataConfig.getInstance().getVigorRegenInCombatBase();
        float vigorRegenBonusPerDex = RegenDataConfig.getInstance().getVigorRegenBonusPerDex();
        int baseRegenPulseCooldownTicks = RegenDataConfig.getInstance().getBaseRegenPulseCooldownTicks();

        // Use different base regeneration rates depending on combat status.
        float baseRegen = inCombat ? vigorRegenInCombatBase : vigorRegenOutOfCombatBase;
        return baseRegen + ((dexterity * vigorRegenBonusPerDex) / baseRegenPulseCooldownTicks);
    }

    /**
     * // Applies chaotic transformation effects to a base stat value.
     * // This method should be called from PlayerStats before returning the final stat values
     * // when the Chimera is in its chaotic transformation state.
     * @param baseStatValue The stat value before chaotic modification.
     * @param randomChangeMin The minimum percentage change (e.g., -0.15 for -15%).
     * @param randomChangeMax The maximum percentage change (e.g., 0.15 for +15%).
     * @return The modified stat value after applying a random percentage change.
     */
    public static float applyChaoticTransformationToStat(float baseStatValue, float randomChangeMin, float randomChangeMax) {
        // Generate a random percentage between min and max
        float randomPercentage = randomChangeMin + (randomChangeMax - randomChangeMin) * RANDOM.nextFloat();
        BrokenPath.LOGGER.debug("StatCalc Debug: Chaotic Transformation applied {}: {}% (raw) to base {}.", baseStatValue, randomPercentage * 100, baseStatValue * (1.0f + randomPercentage));
        return baseStatValue * (1.0f + randomPercentage);
    }
}
